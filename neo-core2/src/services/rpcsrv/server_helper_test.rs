use std::fs::File;
use std::path::Path;
use std::sync::Arc;
use std::time::Duration;

use bigint::U256;
use hyper::Server;
use log::error;
use tokio::runtime::Runtime;

use neo_core2::config::{Config, NetMode, P2PNotary, Wallet};
use neo_core2::core::{Blockchain, Block};
use neo_core2::core::interop;
use neo_core2::core::native;
use neo_core2::core::storage::MemoryStore;
use neo_core2::io::BinReader;
use neo_core2::network::{ServerConfig, ServerHandle};
use neo_core2::services::oracle::{Oracle, OracleConfig};
use neo_core2::util::Uint160;

const NOTARY_PATH: &str = "../notary/testdata/notary1.json";
const NOTARY_PASS: &str = "one";

fn get_unit_test_chain(
    enable_oracle: bool,
    enable_notary: bool,
    disable_iterator_sessions: bool,
) -> (Arc<Blockchain>, Option<Arc<dyn OracleHandler>>, Config, slog::Logger) {
    get_unit_test_chain_with_custom_config(enable_oracle, enable_notary, |cfg| {
        if disable_iterator_sessions {
            cfg.application_configuration.rpc.session_enabled = false;
        }
        if enable_notary {
            cfg.protocol_configuration.p2p_sig_extensions = true;
            cfg.protocol_configuration.p2p_notary_request_payload_pool_size = 1000;
            cfg.application_configuration.p2p_notary = P2PNotary {
                enabled: true,
                unlock_wallet: Wallet {
                    path: NOTARY_PATH.into(),
                    password: NOTARY_PASS.into(),
                },
            };
        } else {
            cfg.application_configuration.p2p_notary.enabled = false;
        }
        if enable_oracle {
            cfg.application_configuration.oracle.enabled = true;
            cfg.application_configuration.oracle.unlock_wallet = Wallet {
                path: "../oracle/testdata/oracle1.json".into(),
                password: "one".into(),
            };
        }
    })
}

fn get_unit_test_chain_with_custom_config<F>(
    enable_oracle: bool,
    enable_notary: bool,
    custom_cfg: F,
) -> (Arc<Blockchain>, Option<Arc<dyn OracleHandler>>, Config, slog::Logger)
where
    F: FnOnce(&mut Config),
{
    let net = NetMode::UnitTestNet;
    let config_path = "../../../config";
    let mut cfg = Config::load(config_path, net).expect("could not load config");
    custom_cfg(&mut cfg);

    let memory_store = Arc::new(MemoryStore::new());
    let logger = slog::Logger::root(slog::Discard, slog::o!());
    let chain = Arc::new(Blockchain::new(memory_store, cfg.blockchain(), logger.clone()).expect("could not create chain"));

    let orc = if enable_oracle {
        let orc = Oracle::new(OracleConfig {
            log: logger.clone(),
            network: NetMode::UnitTestNet,
            main_cfg: cfg.application_configuration.oracle.clone(),
            chain: chain.clone(),
        }).expect("could not create oracle");
        chain.set_oracle(Arc::new(orc.clone()));
        Some(Arc::new(orc) as Arc<dyn OracleHandler>)
    } else {
        None
    };

    let rt = Runtime::new().unwrap();
    rt.spawn(async move {
        chain.run().await;
    });

    (chain, orc, cfg, logger)
}

fn get_test_blocks() -> Vec<Block> {
    // File "./testdata/testblocks.acc" was generated by function core.TestCreateBasicChain
    // ("neo-go/pkg/core/helper_test.go").
    // To generate new "./testdata/testblocks.acc", follow the steps:
    //      1. Rename the function
    //      2. Add specific test-case into "neo-go/pkg/core/blockchain_test.go"
    //      3. Run tests with `$ make test`
    let f = File::open("testdata/testblocks.acc").expect("could not open testblocks.acc");
    let mut br = BinReader::new(f);
    let n_blocks = br.read_u32_le().expect("could not read number of blocks");
    let mut blocks = Vec::with_capacity(n_blocks as usize);
    for _ in 0..n_blocks {
        let _ = br.read_u32_le().expect("could not read block size");
        let mut b = Block::new(false);
        b.decode_binary(&mut br).expect("could not decode block");
        blocks.push(b);
    }
    blocks
}

fn init_clear_server_with_services(
    need_oracle: bool,
    need_notary: bool,
    disable_iterators_sessions: bool,
) -> (Arc<Blockchain>, Arc<Server>, hyper::Server<hyper::server::conn::AddrIncoming>) {
    let (chain, orc, cfg, logger) = get_unit_test_chain(need_oracle, need_notary, disable_iterators_sessions);
    wrap_unit_test_chain(chain, orc, cfg, logger)
}

fn wrap_unit_test_chain(
    chain: Arc<Blockchain>,
    orc: Option<Arc<dyn OracleHandler>>,
    cfg: Config,
    logger: slog::Logger,
) -> (Arc<Blockchain>, Arc<Server>, hyper::Server<hyper::server::conn::AddrIncoming>) {
    let server_config = ServerConfig::new(&cfg).expect("could not create server config");
    let server_config = ServerConfig {
        user_agent: format!("{}-test", env!("CARGO_PKG_VERSION")),
        addresses: vec![":0".parse().unwrap()],
        ..server_config
    };
    let server = ServerHandle::new(server_config, chain.clone(), chain.get_state_sync_module(), logger.clone())
        .expect("could not create server");
    
    let err_ch = tokio::sync::mpsc::channel(2).0;
    let rpc_server = Server::new(chain.clone(), cfg.application_configuration.rpc, server, orc, logger, err_ch);
    rpc_server.start();

    let rt = Runtime::new().unwrap();
    let srv = rt.block_on(async {
        hyper::Server::bind(&([127, 0, 0, 1], 0).into())
            .serve(hyper::service::make_service_fn(|_| {
                let rpc_server = rpc_server.clone();
                async move {
                    Ok::<_, hyper::Error>(hyper::service::service_fn(move |req| {
                        let rpc_server = rpc_server.clone();
                        async move { rpc_server.handle_http_request(req).await }
                    }))
                }
            }))
    });

    (chain, rpc_server, srv)
}

fn init_clear_server_with_custom_config<F>(
    ccfg: F,
) -> (Arc<Blockchain>, Arc<Server>, hyper::Server<hyper::server::conn::AddrIncoming>)
where
    F: FnOnce(&mut Config),
{
    let (chain, orc, cfg, logger) = get_unit_test_chain_with_custom_config(false, false, ccfg);
    wrap_unit_test_chain(chain, orc, cfg, logger)
}

fn init_clear_server_with_in_memory_chain() -> (Arc<Blockchain>, Arc<Server>, hyper::Server<hyper::server::conn::AddrIncoming>) {
    init_clear_server_with_services(false, true, false)
}

fn init_server_with_in_memory_chain() -> (Arc<Blockchain>, Arc<Server>, hyper::Server<hyper::server::conn::AddrIncoming>) {
    let (chain, rpc_server, srv) = init_clear_server_with_in_memory_chain();

    for b in get_test_blocks() {
        chain.add_block(b).expect("could not add block");
    }
    (chain, rpc_server, srv)
}

fn init_server_with_in_memory_chain_and_services(
    need_oracle: bool,
    need_notary: bool,
    disable_iterator_sessions: bool,
) -> (Arc<Blockchain>, Arc<Server>, hyper::Server<hyper::server::conn::AddrIncoming>) {
    let (chain, rpc_server, srv) = init_clear_server_with_services(need_oracle, need_notary, disable_iterator_sessions);

    for b in get_test_blocks() {
        chain.add_block(b).expect("could not add block");
    }
    (chain, rpc_server, srv)
}

struct FeerStub;

impl FeerStub {
    fn fee_per_byte(&self) -> i64 {
        0
    }

    fn block_height(&self) -> u32 {
        0
    }

    fn get_utility_token_balance(&self, _acc: Uint160) -> U256 {
        U256::from(1000000) * native::GAS_FACTOR
    }

    fn get_base_exec_fee(&self) -> i64 {
        interop::DEFAULT_BASE_EXEC_FEE
    }
}
