// Package zkpbinding contains a set of helper functions aimed to generate and
// interact with Verifier smart contract written in Rust and using Groth-16 proving
// system over BLS12-381 elliptic curve to verify proofs. The zkpbinding module
// provides the Verifier contract generation functionality itself as well as a
// helper that converts groth16::Proof to the Verifier-specific set of arguments.
//
// Please, check out the example of zkpbinding module usage to generate and
// verify proofs on the Neo chain:
// https://github.com/nspcc-dev/neo-go/blob/91c928e8d35164055e5b2e8efbc898440cc2b486/examples/zkp/cubic_circuit/README.md

use std::io::{self, Write};
use ark_bls12_381::{Fr, G1Affine, G2Affine};
use ark_groth16::{VerifyingKey, Proof};
use ark_serialize::CanonicalSerialize;

// Config represents a configuration for Verifier Rust smart contract generator.
pub struct Config<W: Write> {
    // verifying_key must be a Groth-16 BLS12-381 specific verifier key,
    // parameters of which will be used to generate Verifier Neo smart contract.
    pub verifying_key: VerifyingKey<ark_bls12_381::Bls12_381>,
    // output is a writer for the resulting Verifier Rust smart contract, it must
    // not be None.
    pub output: W,
    // cfg_output is a writer for the resulting Verifier Rust smart contract YAML
    // configuration file needed to compile the contract. It may be None if the
    // contract configuration file generation should be omitted.
    pub cfg_output: Option<W>,
    // cargo_toml_output is a writer for the resulting Cargo.toml file of the Verifier Rust
    // smart contract needed to compile it. It may be None if the Cargo.toml file
    // generation should be omitted.
    pub cargo_toml_output: Option<W>,
}

// A set of Verifier smart contract template related constants.
const RUST_VERIFICATION_TMPL: &str = r#"// Code generated by neo-core2 zkpbinding::generate_verifier; DO NOT EDIT.

// This module contains a verification smart contract that uses Neo BLS12-381
// curves interoperability functionality to verify provided proof against provided
// public input. The contract contains a single 'verify_proof' function that accepts
// a proof represented as three BLS12-381 curve points and public witnesses
// required for verification represented as a list of serialized 32-bytes field
// elements in the LE form. This contract is circuit-specific and cannot be used
// to verify other circuits.
//
// Use the Neo Rust smart contract compiler to compile this contract.
// You will need to create a contract YAML configuration file and a proper Cargo.toml
// file required for compilation. Please refer to the Neo Rust ZKP example
// to see how to verify proofs via the Verifier contract.

use neo_sdk::prelude::*;

// A set of circuit-specific variables required for verification. Should be generated
// using MPC process.
const ALPHA: &[u8] = &{{ byteSliceToStr .Alpha }};
const BETA: &[u8] = &{{ byteSliceToStr .Beta }};
const GAMMA: &[u8] = &{{ byteSliceToStr .Gamma }};
const DELTA: &[u8] = &{{ byteSliceToStr .Delta }};
const IC: &[&[u8]] = &[
    {{- range $i := .ICs }}
    &{{ byteSliceToStr $i }},{{ end -}}
];

#[no_mangle]
pub extern "C" fn _deploy(_data: *mut u8, _size: u32) -> u32 {
    0
}

#[no_mangle]
pub extern "C" fn verify_proof(a: &[u8], b: &[u8], c: &[u8], public_input: Vec<Vec<u8>>) -> bool {
    let alpha_point = crypto::bls12381_deserialize(ALPHA);
    let beta_point = crypto::bls12381_deserialize(BETA);
    let gamma_point = crypto::bls12381_deserialize(GAMMA);
    let delta_point = crypto::bls12381_deserialize(DELTA);

    let a_point = crypto::bls12381_deserialize(a);
    let b_point = crypto::bls12381_deserialize(b);
    let c_point = crypto::bls12381_deserialize(c);

    // Equation left1: A*B
    let lt = crypto::bls12381_pairing(&a_point, &b_point);

    // Equation right1: alpha*beta
    let rt1 = crypto::bls12381_pairing(&alpha_point, &beta_point);

    // Equation right2: sum(pub_input[i]*(beta*u_i(x)+alpha*v_i(x)+w_i(x))/gamma)*gamma
    let input_len = public_input.len();
    let ic_len = IC.len();

    if ic_len != input_len + 1 {
        panic!("error: input_len or ic_len");
    }
    let mut ic_points = Vec::with_capacity(ic_len);
    for ic_bytes in IC.iter() {
        ic_points.push(crypto::bls12381_deserialize(ic_bytes));
    }
    let mut acc = ic_points[0].clone();
    for i in 0..input_len {
        let scalar = &public_input[i]; // 32-bytes LE field element.
        let temp = crypto::bls12381_mul(&ic_points[i + 1], scalar, false);
        acc = crypto::bls12381_add(&acc, &temp);
    }
    let rt2 = crypto::bls12381_pairing(&acc, &gamma_point);

    // Equation right3: C*delta
    let rt3 = crypto::bls12381_pairing(&c_point, &delta_point);

    // Check equality.
    let t1 = crypto::bls12381_add(&rt1, &rt2);
    let t2 = crypto::bls12381_add(&t1, &rt3);

    lt == t2
}
"#;

const VERIFY_CFG: &str = r#"name: "Groth-16 Verifier contract"
sourceurl: https://github.com/nspcc-dev/neo-core2/
supportedstandards: []"#;

const VERIFY_CARGO_TOML: &str = r#"[package]
name = "verify"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
neo-sdk = "0.4"
"#;

// VerifyProofArgs is the set of arguments of `verify_proof` function of a
// Verifier contract in serialized form (as the contract accepts them).
pub struct VerifyProofArgs {
    pub a: Vec<u8>,
    pub b: Vec<u8>,
    pub c: Vec<u8>,
    pub public_witnesses: Vec<Vec<u8>>,
}

// TmplParams is a set of parameters used by verification contract template.
struct TmplParams {
    alpha: Vec<u8>,
    beta: Vec<u8>,
    gamma: Vec<u8>,
    delta: Vec<u8>,
    ics: Vec<Vec<u8>>,
}

// generate_verifier generates a Verifier smart contract written in Rust for Neo
// blockchain. The contract contains a single `verify_proof` function that accepts
// a proof represented as three BLS12-381 curve points and public witnesses
// required for verification represented as a list of serialized 32-bytes field
// elements in the LE form. The boolean result of `verify_proof` is either `true`
// (if the proof is valid) or `false` (if the proof is invalid). The smart
// contract generated from this template can be immediately compiled without
// any additional changes using the Neo Rust compiler, deployed to the Neo chain and
// invoked. The verification contract is circuit-specific, i.e. corresponds to
// a specific constraint system. Thus, every new circuit requires its own
// verification contract to be generated and deployed to the chain.
//
// generate_verifier also generates a proper contract YAML configuration file and
// Cargo.toml file if the corresponding writers are provided via cfg.
pub fn generate_verifier<W: Write>(cfg: Config<W>) -> io::Result<()> {
    // Fetch the contract's public verification parameters.
    let vk = &cfg.verifying_key;
    let alpha_g1 = vk.alpha_g1.into_affine().serialize_compressed();
    let beta_g2 = vk.beta_g2.into_affine().serialize_compressed();
    let gamma_g2 = vk.gamma_g2.into_affine().serialize_compressed();
    let delta_g2 = vk.delta_g2.into_affine().serialize_compressed();
    let kvks: Vec<Vec<u8>> = vk.gamma_abc_g1
        .iter()
        .map(|point| point.into_affine().serialize_compressed())
        .collect();

    // Generate verification contract from the template using the retrieved
    // verification parameters.
    let tmpl_params = TmplParams {
        alpha: alpha_g1,
        beta: beta_g2,
        gamma: gamma_g2,
        delta: delta_g2,
        ics: kvks,
    };

    // TODO: Implement template rendering logic here
    // This would involve replacing placeholders in RUST_VERIFICATION_TMPL with actual values from tmpl_params

    if let Some(mut cfg_output) = cfg.cfg_output {
        cfg_output.write_all(VERIFY_CFG.as_bytes())?;
    }

    if let Some(mut cargo_toml_output) = cfg.cargo_toml_output {
        cargo_toml_output.write_all(VERIFY_CARGO_TOML.as_bytes())?;
    }

    Ok(())
}

// byte_slice_to_str is a codegen helper that converts byte slice to a Rust-like slice.
fn byte_slice_to_str(s: &[u8]) -> String {
    s.iter()
        .map(|b| format!("{}", b))
        .collect::<Vec<String>>()
        .join(", ")
}

// get_verify_proof_args returns a serialized set of arguments `verify_proof` function
// of a generated Verifier contract accepts. The set of arguments may be directly
// used as parameters to contract invocation.
pub fn get_verify_proof_args(proof: &Proof<ark_bls12_381::Bls12_381>, public_witness: &[Fr]) -> io::Result<VerifyProofArgs> {
    // Get the proof bytes (points are in the compressed form, as Verification contract accepts it).
    let a_bytes = proof.a.into_affine().serialize_compressed();
    let b_bytes = proof.b.into_affine().serialize_compressed();
    let c_bytes = proof.c.into_affine().serialize_compressed();

    // Create public witness input.
    let input: Vec<Vec<u8>> = public_witness
        .iter()
        .map(|fr| {
            let mut bytes = fr.into_repr().to_bytes_le();
            bytes.reverse(); // Convert to LE as native CryptoLib accepts LE-encoded field elements.
            bytes
        })
        .collect();

    Ok(VerifyProofArgs {
        a: a_bytes,
        b: b_bytes,
        c: c_bytes,
        public_witnesses: input,
    })
}
