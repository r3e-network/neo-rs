#!/usr/bin/env python3
"""
Apply Simple Refactoring Script for Neo-RS

This script applies simple, safe refactorings to improve code maintainability:
1. Extract validation helper functions
2. Extract error handling blocks  
3. Split long parameter lists
4. Extract constant definitions
"""

import os
import re
import sys
from typing import List, Tuple, Dict
import tempfile
import shutil

class SimpleRefactorer:
    """Applies simple, safe refactorings."""
    
    def __init__(self, dry_run: bool = True):
        self.dry_run = dry_run
        self.changes_made = 0
        
    def refactor_file(self, file_path: str) -> bool:
        """Apply refactorings to a single file."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
        except (UnicodeDecodeError, IOError):
            return False
            
        content = original_content
        file_changed = False
        
        # Apply various refactoring strategies
        content, changed = self.extract_validation_helpers(content, file_path)
        file_changed |= changed
        
        content, changed = self.extract_error_handling(content, file_path)
        file_changed |= changed
        
        content, changed = self.simplify_complex_conditions(content)
        file_changed |= changed
        
        content, changed = self.extract_magic_numbers(content)
        file_changed |= changed
        
        # Write back if changed and not dry run
        if file_changed and not self.dry_run:
            # Create backup
            backup_path = f"{file_path}.backup"
            shutil.copy2(file_path, backup_path)
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            print(f"✅ Refactored: {file_path}")
            self.changes_made += 1
        elif file_changed and self.dry_run:
            print(f"🔍 Would refactor: {file_path}")
            
        return file_changed
        
    def extract_validation_helpers(self, content: str, file_path: str) -> Tuple[str, bool]:
        """Extract validation logic into helper functions."""
        lines = content.split('\n')
        modified_lines = []
        changes_made = False
        
        i = 0
        while i < len(lines):
            line = lines[i]
            
            # Look for simple validation patterns that can be extracted
            if self.is_simple_validation_block(lines, i):
                # Extract 3-5 line validation blocks
                validation_block = []
                start_idx = i
                
                # Collect validation lines
                while (i < len(lines) and 
                       len(validation_block) < 6 and
                       (lines[i].strip().startswith('if ') or
                        'return Err(' in lines[i] or
                        lines[i].strip() == '' or
                        lines[i].strip().startswith('//'))):
                    validation_block.append(lines[i])
                    i += 1
                    
                if len(validation_block) >= 3 and self.can_extract_validation(validation_block):
                    # Generate helper function call
                    validation_call = self.generate_validation_call(validation_block, file_path)
                    modified_lines.append(validation_call)
                    changes_made = True
                    
                                        if not hasattr(self, 'helper_functions'):
                        self.helper_functions = []
                    self.helper_functions.append(self.generate_validation_helper(validation_block))
                else:
                    # Add original lines if we can't extract
                    modified_lines.extend(validation_block)
            else:
                modified_lines.append(line)
                i += 1
                
        if changes_made and hasattr(self, 'helper_functions'):
            # Add helper functions at the end
            modified_lines.append('\n// Helper functions generated by refactoring tool\n')
            modified_lines.extend(self.helper_functions)
            
        return '\n'.join(modified_lines), changes_made
        
    def is_simple_validation_block(self, lines: List[str], start_idx: int) -> bool:
        """Check if this looks like a simple validation block."""
        if start_idx >= len(lines):
            return False
            
        line = lines[start_idx].strip()
        
        # Look for validation patterns
        return (line.startswith('if ') and 
                any(keyword in line.lower() for keyword in [
                    'is_empty', 'len()', 'is_none', 'is_null', 
                    '== 0', '< ', '> ', 'validate', 'check'
                ]))
                
    def can_extract_validation(self, block: List[str]) -> bool:
        """Check if validation block can be safely extracted."""
        block_text = ' '.join(block)
        
        # Must have error return
        if 'return Err(' not in block_text:
            return False
            
        # Must be relatively simple (no complex state modifications)
        if any(keyword in block_text for keyword in ['self.', 'mut ', 'write()', 'lock()']):
            return False
            
        return True
        
    def generate_validation_call(self, block: List[str], file_path: str) -> str:
        """Generate a call to the validation helper function."""
        func_name = f"validate_input_{hash(str(block)) % 1000}"
        return f"        self.{func_name}()?;"
        
    def generate_validation_helper(self, block: List[str]) -> str:
        """Generate the validation helper function."""
        func_name = f"validate_input_{hash(str(block)) % 1000}"
        
        helper = f"""
    /// Extracted validation logic
    fn {func_name}(&self) -> Result<(), Error> {{
        {"".join(f"        {line}" for line in block if line.strip())}
        Ok(())
    }}"""
        
        return helper
        
    def extract_error_handling(self, content: str, file_path: str) -> Tuple[str, bool]:
        """Extract common error handling patterns."""
        # Simple pattern: convert .unwrap() to proper error handling
        unwrap_pattern = r'\.unwrap\(\)'
        
        if '.unwrap()' in content:
            # Only replace in non-test files
            if 'test' not in file_path.lower():
                new_content = re.sub(
                    unwrap_pattern, 
                    '.map_err(|e| Error::Other(format!("Operation failed: {}", e)))?',
                    content
                )
                return new_content, new_content != content
                
        return content, False
        
    def simplify_complex_conditions(self, content: str) -> Tuple[str, bool]:
        """Simplify complex conditional expressions."""
        lines = content.split('\n')
        modified_lines = []
        changes_made = False
        
        for line in lines:
                        if self.is_complex_condition(line):
                simplified = self.simplify_condition(line)
                if simplified != line:
                    modified_lines.append(simplified)
                    changes_made = True
                else:
                    modified_lines.append(line)
            else:
                modified_lines.append(line)
                
        return '\n'.join(modified_lines), changes_made
        
    def is_complex_condition(self, line: str) -> bool:
        """Check if a line contains a complex condition."""
        stripped = line.strip()
        
        # Look for complex boolean expressions
        if ('if ' in stripped and 
            stripped.count('&&') + stripped.count('||') >= 2):
            return True
            
        # Look for long conditions
        if 'if ' in stripped and len(stripped) > 80:
            return True
            
        return False
        
    def simplify_condition(self, line: str) -> str:
        """Simplify a complex condition line."""
        # Extract the condition part
        if_match = re.match(r'(\s*if\s+)(.+?)(\s*\{.*)', line)
        if not if_match:
            return line
            
        prefix, condition, suffix = if_match.groups()
        
        # Simple optimizations
        # Convert double negations
        condition = re.sub(r'!\(!([^)]+)\)', r'\1', condition)
        
        # Convert common patterns
        condition = condition.replace('== true', '')
        condition = condition.replace('== false', ' == false')
        condition = condition.replace('!= false', '')
        condition = condition.replace('!= true', ' == false')
        
        return f"{prefix}{condition}{suffix}"
        
    def extract_magic_numbers(self, content: str) -> Tuple[str, bool]:
        """Extract magic numbers into named constants."""
        # Look for numeric literals that appear multiple times
        numbers = re.findall(r'\b\d{2,}\b', content)
        number_counts = {}
        
        for num in numbers:
            # Skip common values
            if int(num) in [0, 1, 2, 8, 16, 32, 64, 100, 256, 1000, 1024]:
                continue
            number_counts[num] = number_counts.get(num, 0) + 1
            
        # Extract numbers that appear multiple times
        constants_to_add = []
        modified_content = content
        changes_made = False
        
        for num, count in number_counts.items():
            if count >= 2:
                const_name = f"CONST_{num}"
                
                # Add constant definition
                constants_to_add.append(f"const {const_name}: u32 = {num};")
                
                # Replace occurrences (be careful not to replace parts of other numbers)
                pattern = r'\b' + re.escape(num) + r'\b'
                modified_content = re.sub(pattern, const_name, modified_content)
                changes_made = True
                
        # Add constants at the top of the file
        if constants_to_add:
            lines = modified_content.split('\n')
            
            # Find where to insert constants (after use statements)
            insert_idx = 0
            for i, line in enumerate(lines):
                if line.strip().startswith('use ') or line.strip().startswith('//'):
                    insert_idx = i + 1
                else:
                    break
                    
            # Insert constants
            for const in reversed(constants_to_add):
                lines.insert(insert_idx, const)
                lines.insert(insert_idx + 1, '')
                
            modified_content = '\n'.join(lines)
            
        return modified_content, changes_made
        
    def refactor_directory(self, directory: str) -> int:
        """Refactor all Rust files in a directory."""
        total_files = 0
        
        for root, dirs, files in os.walk(directory):
            # Skip target directory and test directories for complex refactorings
            dirs[:] = [d for d in dirs if d not in ['.git', 'target', 'tests']]
            
            for file in files:
                if file.endswith('.rs') and not file.startswith('test_'):
                    file_path = os.path.join(root, file)
                    total_files += 1
                    
                    if self.refactor_file(file_path):
                        print(f"Refactored: {file_path}")
                        
        return total_files

def main():
    """Main function."""
    dry_run = '--dry-run' in sys.argv or '-n' in sys.argv
    directory = sys.argv[1] if len(sys.argv) > 1 and not sys.argv[1].startswith('-') else '.'
    
    print("🔧 Neo-RS Simple Refactoring Tool")
    print("=================================")
    print(f"Mode: {'DRY RUN' if dry_run else 'LIVE'}")
    print(f"Directory: {directory}")
    print()
    
    refactorer = SimpleRefactorer(dry_run=dry_run)
    
    # Focus on the most problematic files first
    priority_files = [
        './crates/vm/src/interop_service.rs',
        './crates/network/src/messages/protocol.rs', 
        './crates/mpt_trie/src/trie.rs',
        './crates/vm/src/application_engine.rs',
        './crates/ledger/src/blockchain/state.rs'
    ]
    
    print("🎯 Refactoring priority files:")
    for file_path in priority_files:
        if os.path.exists(file_path):
            refactorer.refactor_file(file_path)
        else:
            print(f"⚠️ File not found: {file_path}")
            
    print()
    print("📁 Refactoring remaining files in directory:")
    total_files = refactorer.refactor_directory(directory)
    
    print()
    print("📊 Refactoring Summary:")
    print(f"Total files processed: {total_files}")
    print(f"Files modified: {refactorer.changes_made}")
    
    if dry_run:
        print("\n💡 To apply changes, run without --dry-run flag")
    else:
        print("\n✅ Refactoring complete!")
        print("⚠️ Remember to run tests after refactoring")

if __name__ == "__main__":
    main()