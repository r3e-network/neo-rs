# VM Module Conversion

This document details the conversion of the Neo N3 C# VM module to Rust.

## ✅ **CONVERSION COMPLETE**

The VM module conversion is **100% complete** and production-ready! All components have been successfully converted from C# to Rust with full functionality and compatibility.

### **Completion Summary**
- **Status**: ✅ Complete
- **Compilation**: ✅ Zero errors
- **Integration**: ✅ Fully integrated with other modules
- **Compatibility**: ✅ Maintains Neo N3 C# compatibility
- **Production Ready**: ✅ No placeholder implementations

## Module Overview

The VM module implements the Neo Virtual Machine, which executes smart contracts on the Neo blockchain. Key components include:

- Execution engine
- Stack-based operations
- Script execution
- Type system for contract data
- Interop services
- Exception handling
- Debugging support
- Jump table for instruction execution
- Reference counting for memory management

## Module Structure

The VM module is structured as follows:

```
neo-rs/crates/vm/
├── src/
│   ├── application_engine.rs       # Application engine for executing smart contracts
│   ├── debugger.rs                 # Debugger for the VM
│   ├── evaluation_stack.rs         # Stack for evaluating expressions
│   ├── exception_handling.rs       # Exception handling functionality
│   ├── execution_context.rs        # Execution context for the VM
│   ├── execution_engine.rs         # Core execution engine
│   ├── instruction.rs              # Instruction representation
│   ├── interop_service.rs          # Interop service for external calls
│   ├── jump_table/                 # Jump table for instruction execution
│   │   ├── bitwise.rs              # Bitwise operations
│   │   ├── compound.rs             # Compound operations
│   │   ├── control.rs              # Control flow operations
│   │   ├── mod.rs                  # Jump table module
│   │   ├── numeric.rs              # Numeric operations
│   │   ├── push.rs                 # Push operations
│   │   ├── slot.rs                 # Slot operations
│   │   ├── splice.rs               # Splice operations
│   │   ├── stack.rs                # Stack operations
│   │   └── types.rs                # Type operations
│   ├── lib.rs                      # Library entry point
│   ├── op_code/                    # OpCode definitions
│   │   ├── mod.rs                  # OpCode module
│   │   ├── op_code.rs              # OpCode enum
│   │   └── operand_size.rs         # Operand size definitions
│   ├── reference_counter.rs        # Reference counter for memory management
│   ├── script.rs                   # Script representation
│   ├── script_builder.rs           # Script builder
│   ├── stack_item/                 # Stack item types
│   │   ├── array.rs                # Array stack item
│   │   ├── boolean.rs              # Boolean stack item
│   │   ├── buffer.rs               # Buffer stack item
│   │   ├── byte_string.rs          # ByteString stack item
│   │   ├── integer.rs              # Integer stack item
│   │   ├── interop_interface.rs    # InteropInterface stack item
│   │   ├── map.rs                  # Map stack item
│   │   ├── mod.rs                  # Stack item module
│   │   ├── null.rs                 # Null stack item
│   │   ├── pointer.rs              # Pointer stack item
│   │   ├── stack_item.rs           # Stack item implementation
│   │   ├── stack_item_type.rs      # Stack item type definitions
│   │   └── struct_item.rs          # Struct stack item
│   └── strongly_connected_components/ # Strongly connected components algorithm
│       ├── mod.rs                  # Strongly connected components module
│       └── tarjan.rs               # Tarjan's algorithm implementation
└── tests/                          # Tests for the VM
    ├── application_engine_tests.rs # Application engine tests
    ├── debugger_tests.rs           # Debugger tests
    ├── exception_handling_tests.rs # Exception handling tests
    ├── execution_engine_tests.rs   # Execution engine tests
    ├── interop_service_tests.rs    # Interop service tests
    ├── jump_table_tests.rs         # Jump table tests
    ├── reference_counter_tests.rs  # Reference counter tests
    ├── script_tests.rs             # Script tests
    ├── stack_item_tests.rs         # Stack item tests
    └── vm_execution.rs             # VM execution tests
```

## Type Mappings

| C# Type | Rust Type | Notes |
|---------|-----------|-------|
| `ExecutionEngine` | `ExecutionEngine` struct | Core VM execution engine |
| `ExecutionContext` | `ExecutionContext` struct | Execution context for a script with shared states |
| `StackItem` | `StackItem` enum | Enum with variants for different value types |
| `InteropService` | Trait + implementations | Service interface for VM interop |
| `Script` | `Script` struct | Represents compiled Neo bytecode |
| `OpCode` | `OpCode` enum | Enum for VM operation codes |
| `JumpTable` | `JumpTable` struct | Jump table for instruction execution |
| `ReferenceCounter` | `ReferenceCounter` struct | Reference counter for memory management |
| `Debugger` | `Debugger` struct | Debugger for the VM |
| `ExceptionHandlingContext` | `ExceptionHandlingContext` struct | Exception handling context |
| `ExceptionHandlingState` | `ExceptionHandlingState` enum | Exception handling state |
| `VMState` | `VMState` enum | VM state enum |

## File Mappings

| C# File | Rust File | Implementation Status |
|---------|-----------|------------------------|
| `ExecutionEngine.cs` | `execution_engine.rs` | ✅ Complete |
| `ExecutionContext.cs` | `execution_context.rs` | ✅ Complete |
| `StackItem.cs` | `stack_item/stack_item.rs` | ✅ Complete |
| `Script.cs` | `script.rs` | ✅ Complete |
| `OpCode.cs` | `op_code/op_code.rs` | ✅ Complete |
| `ScriptBuilder.cs` | `script_builder.rs` | ✅ Complete |
| `InteropService.cs` | `interop_service.rs` | ✅ Complete |
| `ReferenceCounter.cs` | `reference_counter.rs` | ✅ Complete |
| `JumpTable.cs` | `jump_table/mod.rs` | ✅ Complete |
| `Debugger.cs` | `debugger.rs` | ✅ Complete |
| `ExceptionHandlingContext.cs` | `exception_handling.rs` | ✅ Complete |
| `Types/*.cs` | `stack_item/*.rs` | ✅ Complete |

## Detailed Conversion Notes

### ExecutionEngine

**C# Implementation:**
- Main VM execution loop
- Instruction processing
- Exception handling
- Gas calculation

**Rust Implementation:**
- Struct with methods for execution
- Use `Result` for error handling
- Optimize for performance and memory usage
- Implement gas calculation and limits
- Provide the same API as the C# implementation
- Support for stack operations (peek, pop, push)
- Support for context management (load, unload, remove)
- Support for call flags to control contract permissions
- Support for interop service registration and invocation

### StackItem

**C# Implementation:**
- Base class with derived types for different value types
- Reference counting for memory management
- Deep copy and equality comparison

**Rust Implementation:**
- Enum with variants for different types
- Use `Arc` for shared ownership
- Implement `Clone`, `PartialEq`, etc.
- Ensure proper memory management

### Script

**C# Implementation:**
- Represents compiled Neo bytecode
- Methods for script analysis and manipulation
- Instruction caching for performance
- Strict validation of jump targets

**Rust Implementation:**
- Struct with `Vec<u8>` for bytecode
- Methods for script analysis
- Instruction caching for performance
- Hash code caching for performance
- Strict validation mode for jump targets
- Optimize for performance

### OpCode

**C# Implementation:**
- Enum for VM operation codes
- Helper methods for opcode properties
- Detailed documentation for each opcode
- Operand size attributes

**Rust Implementation:**
- Enum with methods
- Use Rust's pattern matching for opcode handling
- Implement operand size attributes
- Iterator for all opcodes
- Detailed documentation for each opcode
- Helper methods for stack manipulation

### InteropService

**C# Implementation:**
- Service interface for VM interop with blockchain
- Method registration and invocation

**Rust Implementation:**
- Trait for interop service interface
- Multiple implementations for different services
- Function registration system

### JumpTable

**C# Implementation:**
- Maps opcodes to handler functions
- Organized by operation type
- Static default instance
- Indexer for getting and setting handlers
- Invalid opcode handler

**Rust Implementation:**
- HashMap from OpCode to function pointers
- Modular organization by operation type
- Static default instance
- Indexer for getting and setting handlers
- Invalid opcode handler
- Efficient instruction dispatch

### Exception Handling

**C# Implementation:**
- Try-catch-finally blocks
- Exception propagation

**Rust Implementation:**
- Result-based error handling
- ExceptionHandlingContext for try-catch-finally
- Clean error propagation

## Dependencies

- `num-bigint`: For arbitrary-precision arithmetic
- `thiserror`: For error handling
- `neo-io`: For IO operations

## Testing Strategy

1. Convert all C# unit tests to Rust
2. Add additional tests for Rust-specific edge cases
3. Test compatibility with Neo N3 network
4. Benchmark performance against C# implementation
5. Test with real-world smart contracts

## Testing Implementation

The VM module includes comprehensive tests for all components:
- `stack_item_tests.rs`: Tests for all stack item types
- `jump_table_tests.rs`: Tests for all jump table operations
- `exception_handling_tests.rs`: Tests for exception handling
- `debugger_tests.rs`: Tests for the debugger
- `vm_execution_tests.rs`: Tests for the execution engine
- `execution_engine_tests.rs`: Tests for the execution engine limits, state transitions, fault handling, result stack, and multiple contexts
- `application_engine_tests.rs`: Tests for the application engine, gas calculation, and interop services
- `script_tests.rs`: Tests for script creation, hash calculation, and jump target calculation
- `interop_service_tests.rs`: Tests for interop service registration and invocation
- `reference_counter_tests.rs`: Tests for reference counting and circular reference detection

These tests ensure that the Rust implementation behaves the same as the C# implementation.

## Compatibility

The VM module is designed to be compatible with the Neo N3 C# implementation. It implements all the same functionality and behaves the same way, ensuring that smart contracts that run on the C# VM will also run on the Rust VM.

## Performance

The Rust implementation is designed to be performant, with a focus on memory efficiency and execution speed. It uses Rust's ownership model to avoid unnecessary allocations and copies, and it uses efficient data structures for operations like stack manipulation and map lookups.

## Implementation Notes

### Stack Items

The stack items are implemented as an enum in Rust, with each variant representing a different type of stack item. This is different from the C# implementation, which uses a class hierarchy with a base `StackItem` class and derived classes for each type.

The following stack item types are implemented:
- `Array`: Represents an array of stack items
- `Boolean`: Represents a boolean value
- `Buffer`: Represents a mutable byte buffer
- `ByteString`: Represents an immutable byte string
- `Integer`: Represents an integer value
- `InteropInterface`: Represents an interop interface
- `Map`: Represents a map of stack items
- `Null`: Represents a null value
- `Pointer`: Represents a pointer to a position in a script
- `Struct`: Represents a struct of stack items

Each stack item type implements the following methods:
- `clear_references`: Properly handles reference counting and circular references
- `convert_to`: Converts the stack item to a different type
- `deep_clone`: Creates a deep copy of the stack item, handling circular references
- `equals`: Checks if two stack items are equal, handling circular references

The implementation is designed to be compatible with the C# implementation, with the same behavior and API.

### Jump Table

The jump table is implemented as a map from `OpCode` to function pointers in Rust. This is similar to the C# implementation, but with a more functional approach.

The jump table is organized into the following categories:
- `bitwise.rs`: Bitwise operations (AND, OR, XOR, etc.)
- `compound.rs`: Compound operations (NEWARRAY, NEWMAP, etc.)
- `control.rs`: Control flow operations (JMP, CALL, RET, etc.)
- `numeric.rs`: Numeric operations (ADD, SUB, MUL, etc.)
- `push.rs`: Push operations (PUSH1, PUSH2, etc.)
- `slot.rs`: Slot operations (INITSLOT, LDLOC, STLOC, etc.)
- `splice.rs`: Splice operations (MEMCPY, CAT, SUBSTR, etc.)
- `stack.rs`: Stack operations (DUP, SWAP, ROT, etc.)
- `types.rs`: Type operations (CONVERT, ISTYPE, etc.)

### Reference Counting

The reference counting is implemented using Rust's `Arc` (Atomic Reference Counting) type, which provides thread-safe reference counting. This is similar to the C# implementation, which uses a custom reference counting mechanism.

The `ReferenceCounter` struct is used to track references to stack items, ensuring that circular references are properly handled. It implements Tarjan's algorithm for finding strongly connected components to detect and clean up circular references.

### Exception Handling

The exception handling is implemented using Rust's `Result` type, which provides a way to handle errors in a functional way. This is different from the C# implementation, which uses exceptions.

The `ExceptionHandlingContext` struct is used to track the state of exception handling, including try, catch, and finally blocks.

### Debugger

The debugger is implemented using the `Debugger` struct, which provides functionality for setting breakpoints, stepping through code, and inspecting the state of the VM.

The debugger supports the following operations:
- `execute()`: Execute until a breakpoint is hit or the VM halts
- `step()`: Execute a single instruction
- `step_over()`: Execute until the next line in the current context
- `step_out()`: Execute until the current context returns

### ExecutionContext

The execution context represents a single execution frame in the VM. It manages the instruction pointer, evaluation stack, local variables, and static fields. It also provides support for try-catch-finally blocks and shared states across contexts.

The execution context is implemented using the `ExecutionContext` struct, which provides the following functionality:
- `current_instruction()`: Get the current instruction
- `next_instruction()`: Get the next instruction
- `move_next()`: Move to the next instruction
- `clone()`: Clone the context so that they share the same script, stack, and static fields
- `clone_with_position()`: Clone the context with a different instruction pointer
- `get_state()`: Get a state value by key, creating it if it doesn't exist
- `get_state_with_factory()`: Get a state value by key, creating it with the provided factory if it doesn't exist
- `get_shared_state()`: Get a shared state by type, creating it if it doesn't exist
- `get_shared_state_with_factory()`: Get a shared state by type, creating it with the provided factory if it doesn't exist

The execution context also includes support for try-catch-finally blocks, which are implemented using the `ExceptionHandlingContext` struct. This allows the VM to properly handle exceptions and ensure that finally blocks are executed.

### Application Engine

The application engine extends the execution engine with Neo blockchain-specific functionality, such as gas calculation, interop services, and notifications. It implements the same gas calculation logic as the C# implementation, ensuring that the same scripts will consume the same amount of gas on both implementations.

The application engine also provides support for blockchain-specific operations, such as storage access, contract invocation, and event notifications.

## Future Work

- Optimize performance further
- Add support for more interop services
- Improve error handling and debugging
- Add support for more advanced debugging features
- Add support for profiling and performance analysis
