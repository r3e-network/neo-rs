//! Implementation of the OpCode enum for the Neo Virtual Machine.

use super::operand_size::OperandSize;

const HASH_SIZE: usize = 32;

/// Represents the opcode of an instruction in the Neo Virtual Machine.
#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum OpCode {
    // Constants
    PUSHINT8 = 0x00,
    PUSHINT16 = 0x01,
    PUSHINT32 = 0x02,
    PUSHINT64 = 0x03,
    PUSHINT128 = 0x04,
    PUSHINT256 = 0x05,
    PUSHT = 0x08,
    PUSHF = 0x09,
    PUSHA = 0x0A,
    PUSHNULL = 0x0B,
    PUSHDATA1 = 0x0C,
    PUSHDATA2 = 0x0D,
    PUSHDATA4 = 0x0E,
    PUSHM1 = 0x0F,
    PUSH0 = 0x10,
    PUSH1 = 0x11,
    PUSH2 = 0x12,
    PUSH3 = 0x13,
    PUSH4 = 0x14,
    PUSH5 = 0x15,
    PUSH6 = 0x16,
    PUSH7 = 0x17,
    PUSH8 = 0x18,
    PUSH9 = 0x19,
    PUSH10 = 0x1A,
    PUSH11 = 0x1B,
    PUSH12 = 0x1C,
    PUSH13 = 0x1D,
    PUSH14 = 0x1E,
    PUSH15 = 0x1F,
    PUSH16 = 0x20,

    // Flow control
    NOP = 0x21,
    JMP = 0x22,
    JMP_L = 0x23,
    JMPIF = 0x24,
    JMPIF_L = 0x25,
    JMPIFNOT = 0x26,
    JMPIFNOT_L = 0x27,
    JMPEQ = 0x28,
    JMPEQ_L = 0x29,
    JMPNE = 0x2A,
    JMPNE_L = 0x2B,
    JMPGT = 0x2C,
    JMPGT_L = 0x2D,
    JMPGE = 0x2E,
    JMPGE_L = 0x2F,
    JMPLT = 0x30,
    JMPLT_L = 0x31,
    JMPLE = 0x32,
    JMPLE_L = 0x33,
    CALL = 0x34,
    CALL_L = 0x35,
    CALLA = 0x36,
    CALLT = 0x37,
    ABORT = 0x38,
    ASSERT = 0x39,
    THROW = 0x3A,
    TRY = 0x3B,
    TRY_L = 0x3C,
    ENDTRY = 0x3D,
    ENDTRY_L = 0x3E,
    ENDFINALLY = 0x3F,
    RET = 0x40,
    SYSCALL = 0x41,

    // Stack
    DEPTH = 0x43,
    DROP = 0x45,
    NIP = 0x46,
    XDROP = 0x48,
    CLEAR = 0x49,
    DUP = 0x4A,
    OVER = 0x4B,
    // 0x4C TOALTSTACK not in C# Neo
    PICK = 0x4D,
    TUCK = 0x4E,
    // 0x4F FROMALTSTACK not in C# Neo
    SWAP = 0x50,
    ROT = 0x51,
    ROLL = 0x52,
    REVERSE3 = 0x53,
    REVERSE4 = 0x54,
    REVERSEN = 0x55,

    // Slot
    INITSSLOT = 0x56,
    INITSLOT = 0x57,
    LDSFLD0 = 0x58,
    LDSFLD1 = 0x59,
    LDSFLD2 = 0x5A,
    LDSFLD3 = 0x5B,
    LDSFLD4 = 0x5C,
    LDSFLD5 = 0x5D,
    LDSFLD6 = 0x5E,
    LDSFLD = 0x5F,
    STSFLD0 = 0x60,
    STSFLD1 = 0x61,
    STSFLD2 = 0x62,
    STSFLD3 = 0x63,
    STSFLD4 = 0x64,
    STSFLD5 = 0x65,
    STSFLD6 = 0x66,
    STSFLD = 0x67,
    LDLOC0 = 0x68,
    LDLOC1 = 0x69,
    LDLOC2 = 0x6A,
    LDLOC3 = 0x6B,
    LDLOC4 = 0x6C,
    LDLOC5 = 0x6D,
    LDLOC6 = 0x6E,
    LDLOC = 0x6F,
    STLOC0 = 0x70,
    STLOC1 = 0x71,
    STLOC2 = 0x72,
    STLOC3 = 0x73,
    STLOC4 = 0x74,
    STLOC5 = 0x75,
    STLOC6 = 0x76,
    STLOC = 0x77,
    LDARG0 = 0x78,
    LDARG1 = 0x79,
    LDARG2 = 0x7A,
    LDARG3 = 0x7B,
    LDARG4 = 0x7C,
    LDARG5 = 0x7D,
    LDARG6 = 0x7E,
    LDARG = 0x7F,
    STARG0 = 0x80,
    STARG1 = 0x81,
    STARG2 = 0x82,
    STARG3 = 0x83,
    STARG4 = 0x84,
    STARG5 = 0x85,
    STARG6 = 0x86,
    STARG = 0x87,

    // Splice
    NEWBUFFER = 0x88,
    MEMCPY = 0x89,
    // 0x8A is not used in C# Neo
    CAT = 0x8B,
    SUBSTR = 0x8C,
    LEFT = 0x8D,
    RIGHT = 0x8E,

    // Bitwise
    INVERT = 0x90,
    AND = 0x91,
    OR = 0x92,
    XOR = 0x93,
    EQUAL = 0x97,
    NOTEQUAL = 0x98,

    // Numeric
    SIGN = 0x99,
    ABS = 0x9A,
    NEGATE = 0x9B,
    INC = 0x9C,
    DEC = 0x9D,
    ADD = 0x9E,
    SUB = 0x9F,
    MUL = 0xA0,
    DIV = 0xA1,
    MOD = 0xA2,
    POW = 0xA3,
    SQRT = 0xA4,
    MODMUL = 0xA5,
    MODPOW = 0xA6,
    SHL = 0xA8,
    SHR = 0xA9,
    NOT = 0xAA,
    BOOLAND = 0xAB,
    BOOLOR = 0xAC,
    NZ = 0xB1,
    NUMEQUAL = 0xB3,
    NUMNOTEQUAL = 0xB4,
    LT = 0xB5,
    LE = 0xB6,
    GT = 0xB7,
    GE = 0xB8,
    MIN = 0xB9,
    MAX = 0xBA,
    WITHIN = 0xBB,

    // Compound
    PACKMAP = 0xBE,
    PACKSTRUCT = 0xBF,
    PACK = 0xC0,
    UNPACK = 0xC1,
    NEWARRAY0 = 0xC2,
    NEWARRAY = 0xC3,
    NEWARRAY_T = 0xC4,
    NEWSTRUCT0 = 0xC5,
    NEWSTRUCT = 0xC6,
    NEWMAP = 0xC8,
    SIZE = 0xCA,
    HASKEY = 0xCB,
    KEYS = 0xCC,
    VALUES = 0xCD,
    PICKITEM = 0xCE,
    APPEND = 0xCF,
    SETITEM = 0xD0,
    REVERSEITEMS = 0xD1,
    REMOVE = 0xD2,
    CLEARITEMS = 0xD3,
    POPITEM = 0xD4,

    // Types
    ISNULL = 0xD8,
    ISTYPE = 0xD9,
    CONVERT = 0xDB,

    // Extensions
    ABORTMSG = 0xE0,
    ASSERTMSG = 0xE1,
}

impl OpCode {
    /// Returns an iterator over all OpCode variants.
    pub fn iter() -> impl Iterator<Item = OpCode> {
        // Create a vector of all OpCode variants
        // This matches the C# Neo implementation exactly
        vec![
            Self::PUSHINT8,
            Self::PUSHINT16,
            Self::PUSHINT32,
            Self::PUSHINT64,
            Self::PUSHINT128,
            Self::PUSHINT256,
            Self::PUSHT,
            Self::PUSHF,
            Self::PUSHA,
            Self::PUSHNULL,
            Self::PUSHDATA1,
            Self::PUSHDATA2,
            Self::PUSHDATA4,
            Self::PUSHM1,
            Self::PUSH0,
            Self::PUSH1,
            Self::PUSH2,
            Self::PUSH3,
            Self::PUSH4,
            Self::PUSH5,
            Self::PUSH6,
            Self::PUSH7,
            Self::PUSH8,
            Self::PUSH9,
            Self::PUSH10,
            Self::PUSH11,
            Self::PUSH12,
            Self::PUSH13,
            Self::PUSH14,
            Self::PUSH15,
            Self::PUSH16,
            Self::NOP,
            Self::JMP,
            Self::JMP_L,
            Self::JMPIF,
            Self::JMPIF_L,
            Self::JMPIFNOT,
            Self::JMPIFNOT_L,
            Self::JMPEQ,
            Self::JMPEQ_L,
            Self::JMPNE,
            Self::JMPNE_L,
            Self::JMPGT,
            Self::JMPGT_L,
            Self::JMPGE,
            Self::JMPGE_L,
            Self::JMPLT,
            Self::JMPLT_L,
            Self::JMPLE,
            Self::JMPLE_L,
            Self::CALL,
            Self::CALL_L,
            Self::CALLA,
            Self::CALLT,
            Self::ABORT,
            Self::ASSERT,
            Self::THROW,
            Self::TRY,
            Self::TRY_L,
            Self::ENDTRY,
            Self::ENDTRY_L,
            Self::ENDFINALLY,
            Self::RET,
            Self::SYSCALL,
            Self::DEPTH,
            Self::DROP,
            Self::NIP,
            Self::XDROP,
            Self::CLEAR,
            Self::DUP,
            Self::OVER,
            // TOALTSTACK removed - not in C# Neo
            Self::PICK,
            Self::TUCK,
            // FROMALTSTACK removed - not in C# Neo
            Self::SWAP,
            Self::ROT,
            Self::ROLL,
            Self::REVERSE3,
            Self::REVERSE4,
            Self::REVERSEN,
            Self::INITSSLOT,
            Self::INITSLOT,
            Self::LDSFLD0,
            Self::LDSFLD1,
            Self::LDSFLD2,
            Self::LDSFLD3,
            Self::LDSFLD4,
            Self::LDSFLD5,
            Self::LDSFLD6,
            Self::LDSFLD,
            Self::STSFLD0,
            Self::STSFLD1,
            Self::STSFLD2,
            Self::STSFLD3,
            Self::STSFLD4,
            Self::STSFLD5,
            Self::STSFLD6,
            Self::STSFLD,
            Self::LDLOC0,
            Self::LDLOC1,
            Self::LDLOC2,
            Self::LDLOC3,
            Self::LDLOC4,
            Self::LDLOC5,
            Self::LDLOC6,
            Self::LDLOC,
            Self::STLOC0,
            Self::STLOC1,
            Self::STLOC2,
            Self::STLOC3,
            Self::STLOC4,
            Self::STLOC5,
            Self::STLOC6,
            Self::STLOC,
            Self::LDARG0,
            Self::LDARG1,
            Self::LDARG2,
            Self::LDARG3,
            Self::LDARG4,
            Self::LDARG5,
            Self::LDARG6,
            Self::LDARG,
            Self::STARG0,
            Self::STARG1,
            Self::STARG2,
            Self::STARG3,
            Self::STARG4,
            Self::STARG5,
            Self::STARG6,
            Self::STARG,
            Self::NEWBUFFER,
            Self::MEMCPY,
            Self::CAT,
            Self::SUBSTR,
            Self::LEFT,
            Self::RIGHT,
            Self::INVERT,
            Self::AND,
            Self::OR,
            Self::XOR,
            Self::EQUAL,
            Self::NOTEQUAL,
            Self::SIGN,
            Self::ABS,
            Self::NEGATE,
            Self::INC,
            Self::DEC,
            Self::ADD,
            Self::SUB,
            Self::MUL,
            Self::DIV,
            Self::MOD,
            Self::POW,
            Self::SQRT,
            Self::MODMUL,
            Self::MODPOW,
            Self::SHL,
            Self::SHR,
            Self::NOT,
            Self::BOOLAND,
            Self::BOOLOR,
            Self::NZ,
            Self::NUMEQUAL,
            Self::NUMNOTEQUAL,
            Self::LT,
            Self::LE,
            Self::GT,
            Self::GE,
            Self::MIN,
            Self::MAX,
            Self::WITHIN,
            Self::PACKMAP,
            Self::PACKSTRUCT,
            Self::PACK,
            Self::UNPACK,
            Self::NEWARRAY0,
            Self::NEWARRAY,
            Self::NEWARRAY_T,
            Self::NEWSTRUCT0,
            Self::NEWSTRUCT,
            Self::NEWMAP,
            Self::SIZE,
            Self::HASKEY,
            Self::KEYS,
            Self::VALUES,
            Self::PICKITEM,
            Self::APPEND,
            Self::SETITEM,
            Self::REVERSEITEMS,
            Self::REMOVE,
            Self::CLEARITEMS,
            Self::POPITEM,
            Self::ISNULL,
            Self::ISTYPE,
            Self::CONVERT,
            Self::ABORTMSG,
            Self::ASSERTMSG,
        ]
        .into_iter()
    }

    /// Creates an OpCode from a byte value.
    pub fn from_byte(byte: u8) -> Option<Self> {
        match byte {
            0x00 => Some(Self::PUSHINT8),
            0x01 => Some(Self::PUSHINT16),
            0x02 => Some(Self::PUSHINT32),
            0x03 => Some(Self::PUSHINT64),
            0x04 => Some(Self::PUSHINT128),
            0x05 => Some(Self::PUSHINT256),
            0x08 => Some(Self::PUSHT),
            0x09 => Some(Self::PUSHF),
            0x0A => Some(Self::PUSHA),
            0x0B => Some(Self::PUSHNULL),
            0x0C => Some(Self::PUSHDATA1),
            0x0D => Some(Self::PUSHDATA2),
            0x0E => Some(Self::PUSHDATA4),
            0x0F => Some(Self::PUSHM1),
            0x10 => Some(Self::PUSH0),
            0x11 => Some(Self::PUSH1),
            0x12 => Some(Self::PUSH2),
            0x13 => Some(Self::PUSH3),
            0x14 => Some(Self::PUSH4),
            0x15 => Some(Self::PUSH5),
            0x16 => Some(Self::PUSH6),
            0x17 => Some(Self::PUSH7),
            0x18 => Some(Self::PUSH8),
            0x19 => Some(Self::PUSH9),
            0x1A => Some(Self::PUSH10),
            0x1B => Some(Self::PUSH11),
            0x1C => Some(Self::PUSH12),
            0x1D => Some(Self::PUSH13),
            0x1E => Some(Self::PUSH14),
            0x1F => Some(Self::PUSH15),
            0x20 => Some(Self::PUSH16),
            0x21 => Some(Self::NOP),
            0x22 => Some(Self::JMP),
            0x23 => Some(Self::JMP_L),
            0x24 => Some(Self::JMPIF),
            0x25 => Some(Self::JMPIF_L),
            0x26 => Some(Self::JMPIFNOT),
            0x27 => Some(Self::JMPIFNOT_L),
            0x28 => Some(Self::JMPEQ),
            0x29 => Some(Self::JMPEQ_L),
            0x2A => Some(Self::JMPNE),
            0x2B => Some(Self::JMPNE_L),
            0x2C => Some(Self::JMPGT),
            0x2D => Some(Self::JMPGT_L),
            0x2E => Some(Self::JMPGE),
            0x2F => Some(Self::JMPGE_L),
            0x30 => Some(Self::JMPLT),
            0x31 => Some(Self::JMPLT_L),
            0x32 => Some(Self::JMPLE),
            0x33 => Some(Self::JMPLE_L),
            0x34 => Some(Self::CALL),
            0x35 => Some(Self::CALL_L),
            0x36 => Some(Self::CALLA),
            0x37 => Some(Self::CALLT),
            0x38 => Some(Self::ABORT),
            0x39 => Some(Self::ASSERT),
            0x3A => Some(Self::THROW),
            0x3B => Some(Self::TRY),
            0x3C => Some(Self::TRY_L),
            0x3D => Some(Self::ENDTRY),
            0x3E => Some(Self::ENDTRY_L),
            0x3F => Some(Self::ENDFINALLY),
            0x40 => Some(Self::RET),
            0x41 => Some(Self::SYSCALL),
            0x43 => Some(Self::DEPTH),
            0x45 => Some(Self::DROP),
            0x46 => Some(Self::NIP),
            0x48 => Some(Self::XDROP),
            0x49 => Some(Self::CLEAR),
            0x4A => Some(Self::DUP),
            0x4B => Some(Self::OVER),
            // 0x4C TOALTSTACK not in C# Neo
            0x4D => Some(Self::PICK),
            0x4E => Some(Self::TUCK),
            // 0x4F FROMALTSTACK not in C# Neo
            0x50 => Some(Self::SWAP),
            0x51 => Some(Self::ROT),
            0x52 => Some(Self::ROLL),
            0x53 => Some(Self::REVERSE3),
            0x54 => Some(Self::REVERSE4),
            0x55 => Some(Self::REVERSEN),
            0x56 => Some(Self::INITSSLOT),
            0x57 => Some(Self::INITSLOT),
            0x58 => Some(Self::LDSFLD0),
            0x59 => Some(Self::LDSFLD1),
            0x5A => Some(Self::LDSFLD2),
            0x5B => Some(Self::LDSFLD3),
            0x5C => Some(Self::LDSFLD4),
            0x5D => Some(Self::LDSFLD5),
            0x5E => Some(Self::LDSFLD6),
            0x5F => Some(Self::LDSFLD),
            0x60 => Some(Self::STSFLD0),
            0x61 => Some(Self::STSFLD1),
            0x62 => Some(Self::STSFLD2),
            0x63 => Some(Self::STSFLD3),
            0x64 => Some(Self::STSFLD4),
            0x65 => Some(Self::STSFLD5),
            0x66 => Some(Self::STSFLD6),
            0x67 => Some(Self::STSFLD),
            0x68 => Some(Self::LDLOC0),
            0x69 => Some(Self::LDLOC1),
            0x6A => Some(Self::LDLOC2),
            0x6B => Some(Self::LDLOC3),
            0x6C => Some(Self::LDLOC4),
            0x6D => Some(Self::LDLOC5),
            0x6E => Some(Self::LDLOC6),
            0x6F => Some(Self::LDLOC),
            0x70 => Some(Self::STLOC0),
            0x71 => Some(Self::STLOC1),
            0x72 => Some(Self::STLOC2),
            0x73 => Some(Self::STLOC3),
            0x74 => Some(Self::STLOC4),
            0x75 => Some(Self::STLOC5),
            0x76 => Some(Self::STLOC6),
            0x77 => Some(Self::STLOC),
            0x78 => Some(Self::LDARG0),
            0x79 => Some(Self::LDARG1),
            0x7A => Some(Self::LDARG2),
            0x7B => Some(Self::LDARG3),
            0x7C => Some(Self::LDARG4),
            0x7D => Some(Self::LDARG5),
            0x7E => Some(Self::LDARG6),
            0x7F => Some(Self::LDARG),
            0x80 => Some(Self::STARG0),
            0x81 => Some(Self::STARG1),
            0x82 => Some(Self::STARG2),
            0x83 => Some(Self::STARG3),
            0x84 => Some(Self::STARG4),
            0x85 => Some(Self::STARG5),
            0x86 => Some(Self::STARG6),
            0x87 => Some(Self::STARG),
            0x88 => Some(Self::NEWBUFFER),
            0x89 => Some(Self::MEMCPY),
            // 0x8A is not used in C# Neo
            0x8B => Some(Self::CAT),
            0x8C => Some(Self::SUBSTR),
            0x8D => Some(Self::LEFT),
            0x8E => Some(Self::RIGHT),
            0x90 => Some(Self::INVERT),
            0x91 => Some(Self::AND),
            0x92 => Some(Self::OR),
            0x93 => Some(Self::XOR),
            0x97 => Some(Self::EQUAL),
            0x98 => Some(Self::NOTEQUAL),
            0x99 => Some(Self::SIGN),
            0x9A => Some(Self::ABS),
            0x9B => Some(Self::NEGATE),
            0x9C => Some(Self::INC),
            0x9D => Some(Self::DEC),
            0x9E => Some(Self::ADD),
            0x9F => Some(Self::SUB),
            0xA0 => Some(Self::MUL),
            0xA1 => Some(Self::DIV),
            0xA2 => Some(Self::MOD),
            0xA3 => Some(Self::POW),
            0xA4 => Some(Self::SQRT),
            0xA5 => Some(Self::MODMUL),
            0xA6 => Some(Self::MODPOW),
            0xA8 => Some(Self::SHL),
            0xA9 => Some(Self::SHR),
            0xAA => Some(Self::NOT),
            0xAB => Some(Self::BOOLAND),
            0xAC => Some(Self::BOOLOR),
            0xB1 => Some(Self::NZ),
            0xB3 => Some(Self::NUMEQUAL),
            0xB4 => Some(Self::NUMNOTEQUAL),
            0xB5 => Some(Self::LT),
            0xB6 => Some(Self::LE),
            0xB7 => Some(Self::GT),
            0xB8 => Some(Self::GE),
            0xB9 => Some(Self::MIN),
            0xBA => Some(Self::MAX),
            0xBB => Some(Self::WITHIN),
            0xBE => Some(Self::PACKMAP),
            0xBF => Some(Self::PACKSTRUCT),
            0xC0 => Some(Self::PACK),
            0xC1 => Some(Self::UNPACK),
            0xC2 => Some(Self::NEWARRAY0),
            0xC3 => Some(Self::NEWARRAY),
            0xC4 => Some(Self::NEWARRAY_T),
            0xC5 => Some(Self::NEWSTRUCT0),
            0xC6 => Some(Self::NEWSTRUCT),
            0xC8 => Some(Self::NEWMAP),
            0xCA => Some(Self::SIZE),
            0xCB => Some(Self::HASKEY),
            0xCC => Some(Self::KEYS),
            0xCD => Some(Self::VALUES),
            0xCE => Some(Self::PICKITEM),
            0xCF => Some(Self::APPEND),
            0xD0 => Some(Self::SETITEM),
            0xD1 => Some(Self::REVERSEITEMS),
            0xD2 => Some(Self::REMOVE),
            0xD3 => Some(Self::CLEARITEMS),
            0xD4 => Some(Self::POPITEM),
            0xD8 => Some(Self::ISNULL),
            0xD9 => Some(Self::ISTYPE),
            0xDB => Some(Self::CONVERT),
            0xE0 => Some(Self::ABORTMSG),
            0xE1 => Some(Self::ASSERTMSG),
            _ => None,
        }
    }

    /// Returns the operand size for this opcode.
    pub fn operand_size(&self) -> OperandSize {
        match self {
            Self::PUSHINT8 => OperandSize::fixed(1),
            Self::PUSHINT16 => OperandSize::fixed(2),
            Self::PUSHINT32 => OperandSize::fixed(4),
            Self::PUSHINT64 => OperandSize::fixed(8),
            Self::PUSHINT128 => OperandSize::fixed(16),
            Self::PUSHINT256 => OperandSize::fixed(HASH_SIZE as i32),
            Self::PUSHA => OperandSize::fixed(4),
            Self::PUSHDATA1 => OperandSize::prefix(1),
            Self::PUSHDATA2 => OperandSize::prefix(2),
            Self::PUSHDATA4 => OperandSize::prefix(4),
            Self::JMP => OperandSize::fixed(1),
            Self::JMP_L => OperandSize::fixed(4),
            Self::JMPIF => OperandSize::fixed(1),
            Self::JMPIF_L => OperandSize::fixed(4),
            Self::JMPIFNOT => OperandSize::fixed(1),
            Self::JMPIFNOT_L => OperandSize::fixed(4),
            Self::JMPEQ => OperandSize::fixed(1),
            Self::JMPEQ_L => OperandSize::fixed(4),
            Self::JMPNE => OperandSize::fixed(1),
            Self::JMPNE_L => OperandSize::fixed(4),
            Self::JMPGT => OperandSize::fixed(1),
            Self::JMPGT_L => OperandSize::fixed(4),
            Self::JMPGE => OperandSize::fixed(1),
            Self::JMPGE_L => OperandSize::fixed(4),
            Self::JMPLT => OperandSize::fixed(1),
            Self::JMPLT_L => OperandSize::fixed(4),
            Self::JMPLE => OperandSize::fixed(1),
            Self::JMPLE_L => OperandSize::fixed(4),
            Self::CALL => OperandSize::fixed(1),
            Self::CALL_L => OperandSize::fixed(4),
            Self::CALLT => OperandSize::fixed(2),
            Self::TRY => OperandSize::fixed(2),
            Self::TRY_L => OperandSize::fixed(8),
            Self::ENDTRY => OperandSize::fixed(1),
            Self::ENDTRY_L => OperandSize::fixed(4),
            Self::SYSCALL => OperandSize::fixed(4),
            Self::INITSSLOT => OperandSize::fixed(1),
            Self::INITSLOT => OperandSize::fixed(2),
            Self::LDSFLD => OperandSize::fixed(1),
            Self::STSFLD => OperandSize::fixed(1),
            Self::LDLOC => OperandSize::fixed(1),
            Self::STLOC => OperandSize::fixed(1),
            Self::LDARG => OperandSize::fixed(1),
            Self::STARG => OperandSize::fixed(1),
            Self::NEWARRAY_T => OperandSize::fixed(1),
            Self::ISTYPE => OperandSize::fixed(1),
            Self::CONVERT => OperandSize::fixed(1),
            _ => OperandSize::fixed(0),
        }
    }
}

impl TryFrom<u8> for OpCode {
    type Error = crate::VmError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        Self::from_byte(value).ok_or_else(|| crate::VmError::invalid_opcode(value))
    }
}
