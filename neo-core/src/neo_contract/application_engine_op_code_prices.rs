use std::collections::HashMap;
use neo_vm::OpCode;
use crate::neo_contract::application_engine::ApplicationEngine;

impl ApplicationEngine {
    /// The prices of all the opcodes.
    #[deprecated(note = "You should use OP_CODE_PRICE_TABLE")]
    pub const  OP_CODE_PRICES: HashMap<OpCode, i64> = {
        let mut map = HashMap::new();
        map.insert(OpCode::PushInt8, 1 << 0);
        map.insert(OpCode::PushInt16, 1 << 0);
        map.insert(OpCode::PushInt32, 1 << 0);
        map.insert(OpCode::PushInt64, 1 << 0);
        map.insert(OpCode::PushInt128, 1 << 2);
        map.insert(OpCode::PushInt256, 1 << 2);
        map.insert(OpCode::PushTrue, 1 << 0);
        map.insert(OpCode::PushFalse, 1 << 0);
        map.insert(OpCode::PushA, 1 << 2);
        map.insert(OpCode::PushNull, 1 << 0);
        map.insert(OpCode::PushData1, 1 << 3);
        map.insert(OpCode::PushData2, 1 << 9);
        map.insert(OpCode::PushData4, 1 << 12);
        map.insert(OpCode::PushM1, 1 << 0);
        map.insert(OpCode::Push0, 1 << 0);
        map.insert(OpCode::Push1, 1 << 0);
        map.insert(OpCode::Push2, 1 << 0);
        map.insert(OpCode::Push3, 1 << 0);
        map.insert(OpCode::Push4, 1 << 0);
        map.insert(OpCode::Push5, 1 << 0);
        map.insert(OpCode::Push6, 1 << 0);
        map.insert(OpCode::Push7, 1 << 0);
        map.insert(OpCode::Push8, 1 << 0);
        map.insert(OpCode::Push9, 1 << 0);
        map.insert(OpCode::Push10, 1 << 0);
        map.insert(OpCode::Push11, 1 << 0);
        map.insert(OpCode::Push12, 1 << 0);
        map.insert(OpCode::Push13, 1 << 0);
        map.insert(OpCode::Push14, 1 << 0);
        map.insert(OpCode::Push15, 1 << 0);
        map.insert(OpCode::Push16, 1 << 0);
        map.insert(OpCode::Nop, 1 << 0);
        map.insert(OpCode::Jmp, 1 << 1);
        map.insert(OpCode::JmpL, 1 << 1);
        map.insert(OpCode::JmpIf, 1 << 1);
        map.insert(OpCode::JmpIfL, 1 << 1);
        map.insert(OpCode::JmpIfNot, 1 << 1);
        map.insert(OpCode::JmpIfNotL, 1 << 1);
        map.insert(OpCode::JmpEq, 1 << 1);
        map.insert(OpCode::JmpEqL, 1 << 1);
        map.insert(OpCode::JmpNe, 1 << 1);
        map.insert(OpCode::JmpNeL, 1 << 1);
        map.insert(OpCode::JmpGt, 1 << 1);
        map.insert(OpCode::JmpGtL, 1 << 1);
        map.insert(OpCode::JmpGe, 1 << 1);
        map.insert(OpCode::JmpGeL, 1 << 1);
        map.insert(OpCode::JmpLt, 1 << 1);
        map.insert(OpCode::JmpLtL, 1 << 1);
        map.insert(OpCode::JmpLe, 1 << 1);
        map.insert(OpCode::JmpLeL, 1 << 1);
        map.insert(OpCode::Call, 1 << 9);
        map.insert(OpCode::CallL, 1 << 9);
        map.insert(OpCode::CallA, 1 << 9);
        map.insert(OpCode::CallT, 1 << 15);
        map.insert(OpCode::Abort, 0);
        map.insert(OpCode::AbortMsg, 0);
        map.insert(OpCode::Assert, 1 << 0);
        map.insert(OpCode::AssertMsg, 1 << 0);
        map.insert(OpCode::Throw, 1 << 9);
        map.insert(OpCode::Try, 1 << 2);
        map.insert(OpCode::TryL, 1 << 2);
        map.insert(OpCode::EndTry, 1 << 2);
        map.insert(OpCode::EndTryL, 1 << 2);
        map.insert(OpCode::EndFinally, 1 << 2);
        map.insert(OpCode::Ret, 0);
        map.insert(OpCode::Syscall, 0);
        map.insert(OpCode::Depth, 1 << 1);
        map.insert(OpCode::Drop, 1 << 1);
        map.insert(OpCode::Nip, 1 << 1);
        map.insert(OpCode::Xdrop, 1 << 4);
        map.insert(OpCode::Clear, 1 << 4);
        map.insert(OpCode::Dup, 1 << 1);
        map.insert(OpCode::Over, 1 << 1);
        map.insert(OpCode::Pick, 1 << 1);
        map.insert(OpCode::Tuck, 1 << 1);
        map.insert(OpCode::Swap, 1 << 1);
        map.insert(OpCode::Rot, 1 << 1);
        map.insert(OpCode::Roll, 1 << 4);
        map.insert(OpCode::Reverse3, 1 << 1);
        map.insert(OpCode::Reverse4, 1 << 1);
        map.insert(OpCode::ReverseN, 1 << 4);
        map.insert(OpCode::InitSSLot, 1 << 4);
        map.insert(OpCode::InitSlot, 1 << 6);
        map.insert(OpCode::LdSFLd0, 1 << 1);
        map.insert(OpCode::LdSFLd1, 1 << 1);
        map.insert(OpCode::LdSFLd2, 1 << 1);
        map.insert(OpCode::LdSFLd3, 1 << 1);
        map.insert(OpCode::LdSFLd4, 1 << 1);
        map.insert(OpCode::LdSFLd5, 1 << 1);
        map.insert(OpCode::LdSFLd6, 1 << 1);
        map.insert(OpCode::LdSFLd, 1 << 1);
        map.insert(OpCode::StSFLd0, 1 << 1);
        map.insert(OpCode::StSFLd1, 1 << 1);
        map.insert(OpCode::StSFLd2, 1 << 1);
        map.insert(OpCode::StSFLd3, 1 << 1);
        map.insert(OpCode::StSFLd4, 1 << 1);
        map.insert(OpCode::StSFLd5, 1 << 1);
        map.insert(OpCode::StSFLd6, 1 << 1);
        map.insert(OpCode::StSFLd, 1 << 1);
        map.insert(OpCode::LdLoc0, 1 << 1);
        map.insert(OpCode::LdLoc1, 1 << 1);
        map.insert(OpCode::LdLoc2, 1 << 1);
        map.insert(OpCode::LdLoc3, 1 << 1);
        map.insert(OpCode::LdLoc4, 1 << 1);
        map.insert(OpCode::LdLoc5, 1 << 1);
        map.insert(OpCode::LdLoc6, 1 << 1);
        map.insert(OpCode::LdLoc, 1 << 1);
        map.insert(OpCode::StLoc0, 1 << 1);
        map.insert(OpCode::StLoc1, 1 << 1);
        map.insert(OpCode::StLoc2, 1 << 1);
        map.insert(OpCode::StLoc3, 1 << 1);
        map.insert(OpCode::StLoc4, 1 << 1);
        map.insert(OpCode::StLoc5, 1 << 1);
        map.insert(OpCode::StLoc6, 1 << 1);
        map.insert(OpCode::StLoc, 1 << 1);
        map.insert(OpCode::LdArg0, 1 << 1);
        map.insert(OpCode::LdArg1, 1 << 1);
        map.insert(OpCode::LdArg2, 1 << 1);
        map.insert(OpCode::LdArg3, 1 << 1);
        map.insert(OpCode::LdArg4, 1 << 1);
        map.insert(OpCode::LdArg5, 1 << 1);
        map.insert(OpCode::LdArg6, 1 << 1);
        map.insert(OpCode::LdArg, 1 << 1);
        map.insert(OpCode::StArg0, 1 << 1);
        map.insert(OpCode::StArg1, 1 << 1);
        map.insert(OpCode::StArg2, 1 << 1);
        map.insert(OpCode::StArg3, 1 << 1);
        map.insert(OpCode::StArg4, 1 << 1);
        map.insert(OpCode::StArg5, 1 << 1);
        map.insert(OpCode::StArg6, 1 << 1);
        map.insert(OpCode::StArg, 1 << 1);
        map.insert(OpCode::NewBuffer, 1 << 8);
        map.insert(OpCode::MemCpy, 1 << 11);
        map.insert(OpCode::Cat, 1 << 11);
        map.insert(OpCode::Substr, 1 << 11);
        map.insert(OpCode::Left, 1 << 11);
        map.insert(OpCode::Right, 1 << 11);
        map.insert(OpCode::Invert, 1 << 2);
        map.insert(OpCode::And, 1 << 3);
        map.insert(OpCode::Or, 1 << 3);
        map.insert(OpCode::Xor, 1 << 3);
        map.insert(OpCode::Equal, 1 << 5);
        map.insert(OpCode::NotEqual, 1 << 5);
        map.insert(OpCode::Sign, 1 << 2);
        map.insert(OpCode::Abs, 1 << 2);
        map.insert(OpCode::Negate, 1 << 2);
        map.insert(OpCode::Inc, 1 << 2);
        map.insert(OpCode::Dec, 1 << 2);
        map.insert(OpCode::Add, 1 << 3);
        map.insert(OpCode::Sub, 1 << 3);
        map.insert(OpCode::Mul, 1 << 3);
        map.insert(OpCode::Div, 1 << 3);
        map.insert(OpCode::Mod, 1 << 3);
        map.insert(OpCode::Pow, 1 << 6);
        map.insert(OpCode::Sqrt, 1 << 6);
        map.insert(OpCode::ModMul, 1 << 5);
        map.insert(OpCode::ModPow, 1 << 11);
        map.insert(OpCode::Shl, 1 << 3);
        map.insert(OpCode::Shr, 1 << 3);
        map.insert(OpCode::Not, 1 << 2);
        map.insert(OpCode::BoolAnd, 1 << 3);
        map.insert(OpCode::BoolOr, 1 << 3);
        map.insert(OpCode::Nz, 1 << 2);
        map.insert(OpCode::NumEqual, 1 << 3);
        map.insert(OpCode::NumNotEqual, 1 << 3);
        map.insert(OpCode::Lt, 1 << 3);
        map.insert(OpCode::Le, 1 << 3);
        map.insert(OpCode::Gt, 1 << 3);
        map.insert(OpCode::Ge, 1 << 3);
        map.insert(OpCode::Min, 1 << 3);
        map.insert(OpCode::Max, 1 << 3);
        map.insert(OpCode::Within, 1 << 3);
        map.insert(OpCode::PackMap, 1 << 11);
        map.insert(OpCode::PackStruct, 1 << 11);
        map.insert(OpCode::Pack, 1 << 11);
        map.insert(OpCode::Unpack, 1 << 11);
        map.insert(OpCode::NewArray0, 1 << 4);
        map.insert(OpCode::NewArray, 1 << 9);
        map.insert(OpCode::NewArrayT, 1 << 9);
        map.insert(OpCode::NewStruct0, 1 << 4);
        map.insert(OpCode::NewStruct, 1 << 9);
        map.insert(OpCode::NewMap, 1 << 3);
        map.insert(OpCode::Size, 1 << 2);
        map.insert(OpCode::HasKey, 1 << 6);
        map.insert(OpCode::Keys, 1 << 4);
        map.insert(OpCode::Values, 1 << 13);
        map.insert(OpCode::PickItem, 1 << 6);
        map.insert(OpCode::Append, 1 << 13);
        map.insert(OpCode::SetItem, 1 << 13);
        map.insert(OpCode::ReverseItems, 1 << 13);
        map.insert(OpCode::Remove, 1 << 4);
        map.insert(OpCode::ClearItems, 1 << 4);
        map.insert(OpCode::PopItem, 1 << 4);
        map.insert(OpCode::IsNull, 1 << 1);
        map.insert(OpCode::IsType, 1 << 1);
        map.insert(OpCode::Convert, 1 << 13);
        map
    };

    /// The prices of all the opcodes.
    /// In the unit of datoshi, 1 datoshi = 1e-8 GAS
    pub const OP_CODE_PRICE_TABLE: [i64; 256] = {
        let mut table = [0; 256];
        for (op_code, price) in Self::OP_CODE_PRICES.iter() {
            table[*op_code as usize] = *price;
        }
        table
    };
}
