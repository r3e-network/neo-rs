use neo::io::Serializable;
use std::io::{Cursor, Write};
use byteorder::{BigEndian, WriteBytesExt};

/// Used to build storage keys for native contracts.
pub struct KeyBuilder {
    buffer: Vec<u8>,
}

impl KeyBuilder {
    /// Initializes a new instance of the KeyBuilder struct.
    ///
    /// # Arguments
    ///
    /// * `id` - The id of the contract.
    /// * `prefix` - The prefix of the key.
    pub fn new(id: i32, prefix: u8) -> Self {
        let mut buffer = Vec::new();
        buffer.extend_from_slice(&id.to_le_bytes());
        buffer.push(prefix);
        Self { buffer }
    }

    /// Adds part of the key to the builder.
    ///
    /// # Arguments
    ///
    /// * `key` - Part of the key.
    pub fn add(&mut self, key: u8) -> &mut Self {
        self.buffer.push(key);
        self
    }

    /// Adds part of the key to the builder.
    ///
    /// # Arguments
    ///
    /// * `key` - Part of the key.
    pub fn add_slice(&mut self, key: &[u8]) -> &mut Self {
        self.buffer.extend_from_slice(key);
        self
    }

    /// Adds part of the key to the builder.
    ///
    /// # Arguments
    ///
    /// * `key` - Part of the key.
    pub fn add_serializable<T: Serializable>(&mut self, key: &T) -> &mut Self {
        let mut cursor = Cursor::new(Vec::new());
        key.serialize(&mut cursor).unwrap();
        self.buffer.extend_from_slice(cursor.get_ref());
        self
    }

    /// Adds part of the key to the builder in BigEndian.
    ///
    /// # Arguments
    ///
    /// * `key` - Part of the key.
    pub fn add_big_endian_i32(&mut self, key: i32) -> &mut Self {
        self.buffer.write_i32::<BigEndian>(key).unwrap();
        self
    }

    /// Adds part of the key to the builder in BigEndian.
    ///
    /// # Arguments
    ///
    /// * `key` - Part of the key.
    pub fn add_big_endian_u32(&mut self, key: u32) -> &mut Self {
        self.buffer.write_u32::<BigEndian>(key).unwrap();
        self
    }

    /// Adds part of the key to the builder in BigEndian.
    ///
    /// # Arguments
    ///
    /// * `key` - Part of the key.
    pub fn add_big_endian_i64(&mut self, key: i64) -> &mut Self {
        self.buffer.write_i64::<BigEndian>(key).unwrap();
        self
    }

    /// Adds part of the key to the builder in BigEndian.
    ///
    /// # Arguments
    ///
    /// * `key` - Part of the key.
    pub fn add_big_endian_u64(&mut self, key: u64) -> &mut Self {
        self.buffer.write_u64::<BigEndian>(key).unwrap();
        self
    }

    /// Gets the storage key generated by the builder.
    pub fn to_vec(&self) -> Vec<u8> {
        self.buffer.clone()
    }
}

impl From<KeyBuilder> for StorageKey {
    fn from(builder: KeyBuilder) -> Self {
        StorageKey::new(builder.buffer)
    }
}
