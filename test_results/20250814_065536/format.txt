Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:1:
 // Comprehensive Performance Benchmarking Suite for Neo-RS
 // Uses criterion for statistical analysis and comparison
 
[31m-use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
(B[m[32m+use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};
(B[m use std::time::Duration;
 
 // Benchmark cryptographic operations
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:8:
 fn bench_cryptography(c: &mut Criterion) {
     let mut group = c.benchmark_group("cryptography");
[31m-    
(B[m[32m+
(B[m     // SHA256 hashing performance
     group.bench_function("sha256_small", |b| {
         let data = vec![0u8; 32];
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:14:
[31m-        b.iter(|| {
(B[m[31m-            black_box(sha256(&data))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(sha256(&data)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     group.bench_function("sha256_medium", |b| {
         let data = vec![0u8; 1024];
[31m-        b.iter(|| {
(B[m[31m-            black_box(sha256(&data))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(sha256(&data)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     group.bench_function("sha256_large", |b| {
         let data = vec![0u8; 1_000_000];
[31m-        b.iter(|| {
(B[m[31m-            black_box(sha256(&data))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(sha256(&data)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // ECDSA signature verification
     group.bench_function("ecdsa_verify", |b| {
         let message = vec![0u8; 32];
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:36:
         let signature = vec![0u8; 64];
         let public_key = vec![0u8; 33];
[31m-        b.iter(|| {
(B[m[31m-            black_box(verify_signature(&message, &signature, &public_key))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(verify_signature(&message, &signature, &public_key)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // BLS signature aggregation
     for size in [10, 100, 1000].iter() {
[31m-        group.bench_with_input(
(B[m[31m-            BenchmarkId::new("bls_aggregate", size),
(B[m[31m-            size,
(B[m[31m-            |b, &size| {
(B[m[31m-                let signatures = vec![vec![0u8; 96]; size];
(B[m[31m-                b.iter(|| {
(B[m[31m-                    black_box(aggregate_bls_signatures(&signatures))
(B[m[31m-                });
(B[m[31m-            },
(B[m[31m-        );
(B[m[32m+        group.bench_with_input(BenchmarkId::new("bls_aggregate", size), size, |b, &size| {
(B[m[32m+            let signatures = vec![vec![0u8; 96]; size];
(B[m[32m+            b.iter(|| black_box(aggregate_bls_signatures(&signatures)));
(B[m[32m+        });
(B[m     }
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:61:
 fn bench_vm_execution(c: &mut Criterion) {
     let mut group = c.benchmark_group("vm_execution");
     group.measurement_time(Duration::from_secs(10));
[31m-    
(B[m[32m+
(B[m     // Simple arithmetic operations
     group.bench_function("vm_add", |b| {
         let script = compile_script("PUSH1 PUSH2 ADD");
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:70:
             black_box(vm.execute(&script))
         });
     });
[31m-    
(B[m[32m+
(B[m     // Complex script execution
     group.bench_function("vm_complex_script", |b| {
         let script = compile_complex_script();
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:79:
             black_box(vm.execute(&script))
         });
     });
[31m-    
(B[m[32m+
(B[m     // Stack operations
     for stack_size in [10, 100, 1000].iter() {
         group.bench_with_input(
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:94:
             },
         );
     }
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:101:
 // Benchmark transaction processing
 fn bench_transaction_processing(c: &mut Criterion) {
     let mut group = c.benchmark_group("transactions");
[31m-    
(B[m[32m+
(B[m     // Transaction validation
     group.bench_function("tx_validate", |b| {
         let tx = create_sample_transaction();
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:108:
[31m-        b.iter(|| {
(B[m[31m-            black_box(validate_transaction(&tx))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(validate_transaction(&tx)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // Transaction serialization
     group.bench_function("tx_serialize", |b| {
         let tx = create_sample_transaction();
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:116:
[31m-        b.iter(|| {
(B[m[31m-            black_box(tx.serialize())
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(tx.serialize()));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // Transaction deserialization
     group.bench_function("tx_deserialize", |b| {
         let data = create_sample_transaction().serialize();
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:124:
[31m-        b.iter(|| {
(B[m[31m-            black_box(Transaction::deserialize(&data))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(Transaction::deserialize(&data)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // Batch transaction processing
     for batch_size in [10, 100, 1000].iter() {
         group.bench_with_input(
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:135:
                 let transactions = (0..size)
                     .map(|_| create_sample_transaction())
                     .collect::<Vec<_>>();
[31m-                b.iter(|| {
(B[m[31m-                    black_box(process_transaction_batch(&transactions))
(B[m[31m-                });
(B[m[32m+                b.iter(|| black_box(process_transaction_batch(&transactions)));
(B[m             },
         );
     }
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:144:
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:148:
 // Benchmark block operations
 fn bench_block_operations(c: &mut Criterion) {
     let mut group = c.benchmark_group("blocks");
[31m-    
(B[m[32m+
(B[m     // Block creation
     group.bench_function("block_create", |b| {
         let transactions = (0..100)
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:155:
             .map(|_| create_sample_transaction())
             .collect::<Vec<_>>();
[31m-        b.iter(|| {
(B[m[31m-            black_box(create_block(&transactions))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(create_block(&transactions)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // Block validation
     group.bench_function("block_validate", |b| {
         let block = create_sample_block();
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:165:
[31m-        b.iter(|| {
(B[m[31m-            black_box(validate_block(&block))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(validate_block(&block)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // Merkle tree generation
     for leaf_count in [10, 100, 1000, 10000].iter() {
         group.bench_with_input(
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:173:
             BenchmarkId::new("merkle_tree", leaf_count),
             leaf_count,
             |b, &count| {
[31m-                let leaves = (0..count)
(B[m[31m-                    .map(|i| vec![i as u8; 32])
(B[m[31m-                    .collect::<Vec<_>>();
(B[m[31m-                b.iter(|| {
(B[m[31m-                    black_box(calculate_merkle_root(&leaves))
(B[m[31m-                });
(B[m[32m+                let leaves = (0..count).map(|i| vec![i as u8; 32]).collect::<Vec<_>>();
(B[m[32m+                b.iter(|| black_box(calculate_merkle_root(&leaves)));
(B[m             },
         );
     }
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:185:
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:189:
 // Benchmark network operations
 fn bench_network_operations(c: &mut Criterion) {
     let mut group = c.benchmark_group("network");
[31m-    
(B[m[32m+
(B[m     // Message serialization
     group.bench_function("msg_serialize", |b| {
         let msg = create_network_message();
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:196:
[31m-        b.iter(|| {
(B[m[31m-            black_box(msg.serialize())
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(msg.serialize()));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // Message parsing
     group.bench_function("msg_parse", |b| {
         let data = create_network_message().serialize();
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:204:
[31m-        b.iter(|| {
(B[m[31m-            black_box(parse_network_message(&data))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(parse_network_message(&data)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // Peer discovery simulation
     group.bench_function("peer_discovery", |b| {
         let peers = create_peer_list(100);
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:212:
[31m-        b.iter(|| {
(B[m[31m-            black_box(discover_peers(&peers))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(discover_peers(&peers)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:220:
 // Benchmark storage operations
 fn bench_storage_operations(c: &mut Criterion) {
     let mut group = c.benchmark_group("storage");
[31m-    
(B[m[32m+
(B[m     // Key-value store operations
     group.bench_function("kv_write", |b| {
         let mut store = InMemoryStore::new();
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:227:
         let key = vec![0u8; 32];
         let value = vec![0u8; 1024];
[31m-        b.iter(|| {
(B[m[31m-            black_box(store.put(&key, &value))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(store.put(&key, &value)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     group.bench_function("kv_read", |b| {
         let mut store = InMemoryStore::new();
         let key = vec![0u8; 32];
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:237:
         let value = vec![0u8; 1024];
         store.put(&key, &value);
[31m-        b.iter(|| {
(B[m[31m-            black_box(store.get(&key))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(store.get(&key)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // Batch operations
     for batch_size in [10, 100, 1000].iter() {
         group.bench_with_input(
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:251:
                 let batch = (0..size)
                     .map(|i| (vec![i as u8; 32], vec![i as u8; 1024]))
                     .collect::<Vec<_>>();
[31m-                b.iter(|| {
(B[m[31m-                    black_box(store.put_batch(&batch))
(B[m[31m-                });
(B[m[32m+                b.iter(|| black_box(store.put_batch(&batch)));
(B[m             },
         );
     }
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:260:
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:264:
 // Benchmark consensus operations
 fn bench_consensus_operations(c: &mut Criterion) {
     let mut group = c.benchmark_group("consensus");
[31m-    
(B[m[32m+
(B[m     // View change
     group.bench_function("view_change", |b| {
         let mut consensus = ConsensusEngine::new(7);
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:271:
[31m-        b.iter(|| {
(B[m[31m-            black_box(consensus.change_view())
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(consensus.change_view()));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // Proposal validation
     group.bench_function("proposal_validate", |b| {
         let proposal = create_block_proposal();
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:279:
[31m-        b.iter(|| {
(B[m[31m-            black_box(validate_proposal(&proposal))
(B[m[31m-        });
(B[m[32m+        b.iter(|| black_box(validate_proposal(&proposal)));
(B[m     });
[31m-    
(B[m[32m+
(B[m     // Signature aggregation for different validator counts
     for validator_count in [4, 7, 21].iter() {
         group.bench_with_input(
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:287:
             BenchmarkId::new("signature_aggregate", validator_count),
             validator_count,
             |b, &count| {
[31m-                let signatures = (0..count)
(B[m[31m-                    .map(|_| vec![0u8; 64])
(B[m[31m-                    .collect::<Vec<_>>();
(B[m[31m-                b.iter(|| {
(B[m[31m-                    black_box(aggregate_signatures(&signatures))
(B[m[31m-                });
(B[m[32m+                let signatures = (0..count).map(|_| vec![0u8; 64]).collect::<Vec<_>>();
(B[m[32m+                b.iter(|| black_box(aggregate_signatures(&signatures)));
(B[m             },
         );
     }
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:299:
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:303:
 // Helper functions (placeholder implementations)
[31m-fn sha256(_data: &[u8]) -> Vec<u8> { vec![0u8; 32] }
(B[m[31m-fn verify_signature(_msg: &[u8], _sig: &[u8], _pk: &[u8]) -> bool { true }
(B[m[31m-fn aggregate_bls_signatures(_sigs: &[Vec<u8>]) -> Vec<u8> { vec![0u8; 96] }
(B[m[31m-fn compile_script(_script: &str) -> Vec<u8> { vec![0u8; 10] }
(B[m[31m-fn compile_complex_script() -> Vec<u8> { vec![0u8; 100] }
(B[m[31m-fn generate_stack_operations(size: usize) -> Vec<u8> { vec![0u8; size * 2] }
(B[m[31m-fn validate_transaction(_tx: &Transaction) -> bool { true }
(B[m[31m-fn create_sample_transaction() -> Transaction { Transaction::default() }
(B[m[31m-fn process_transaction_batch(_txs: &[Transaction]) -> Vec<bool> { vec![true; _txs.len()] }
(B[m[31m-fn create_block(_txs: &[Transaction]) -> Block { Block::default() }
(B[m[31m-fn create_sample_block() -> Block { Block::default() }
(B[m[31m-fn validate_block(_block: &Block) -> bool { true }
(B[m[31m-fn calculate_merkle_root(_leaves: &[Vec<u8>]) -> Vec<u8> { vec![0u8; 32] }
(B[m[31m-fn create_network_message() -> NetworkMessage { NetworkMessage::default() }
(B[m[31m-fn parse_network_message(_data: &[u8]) -> NetworkMessage { NetworkMessage::default() }
(B[m[31m-fn create_peer_list(count: usize) -> Vec<Peer> { vec![Peer::default(); count] }
(B[m[31m-fn discover_peers(_peers: &[Peer]) -> Vec<Peer> { vec![] }
(B[m[31m-fn create_block_proposal() -> Proposal { Proposal::default() }
(B[m[31m-fn validate_proposal(_proposal: &Proposal) -> bool { true }
(B[m[31m-fn aggregate_signatures(_sigs: &[Vec<u8>]) -> Vec<u8> { vec![0u8; 64] }
(B[m[32m+fn sha256(_data: &[u8]) -> Vec<u8> {
(B[m[32m+    vec![0u8; 32]
(B[m[32m+}
(B[m[32m+fn verify_signature(_msg: &[u8], _sig: &[u8], _pk: &[u8]) -> bool {
(B[m[32m+    true
(B[m[32m+}
(B[m[32m+fn aggregate_bls_signatures(_sigs: &[Vec<u8>]) -> Vec<u8> {
(B[m[32m+    vec![0u8; 96]
(B[m[32m+}
(B[m[32m+fn compile_script(_script: &str) -> Vec<u8> {
(B[m[32m+    vec![0u8; 10]
(B[m[32m+}
(B[m[32m+fn compile_complex_script() -> Vec<u8> {
(B[m[32m+    vec![0u8; 100]
(B[m[32m+}
(B[m[32m+fn generate_stack_operations(size: usize) -> Vec<u8> {
(B[m[32m+    vec![0u8; size * 2]
(B[m[32m+}
(B[m[32m+fn validate_transaction(_tx: &Transaction) -> bool {
(B[m[32m+    true
(B[m[32m+}
(B[m[32m+fn create_sample_transaction() -> Transaction {
(B[m[32m+    Transaction::default()
(B[m[32m+}
(B[m[32m+fn process_transaction_batch(_txs: &[Transaction]) -> Vec<bool> {
(B[m[32m+    vec![true; _txs.len()]
(B[m[32m+}
(B[m[32m+fn create_block(_txs: &[Transaction]) -> Block {
(B[m[32m+    Block::default()
(B[m[32m+}
(B[m[32m+fn create_sample_block() -> Block {
(B[m[32m+    Block::default()
(B[m[32m+}
(B[m[32m+fn validate_block(_block: &Block) -> bool {
(B[m[32m+    true
(B[m[32m+}
(B[m[32m+fn calculate_merkle_root(_leaves: &[Vec<u8>]) -> Vec<u8> {
(B[m[32m+    vec![0u8; 32]
(B[m[32m+}
(B[m[32m+fn create_network_message() -> NetworkMessage {
(B[m[32m+    NetworkMessage::default()
(B[m[32m+}
(B[m[32m+fn parse_network_message(_data: &[u8]) -> NetworkMessage {
(B[m[32m+    NetworkMessage::default()
(B[m[32m+}
(B[m[32m+fn create_peer_list(count: usize) -> Vec<Peer> {
(B[m[32m+    vec![Peer::default(); count]
(B[m[32m+}
(B[m[32m+fn discover_peers(_peers: &[Peer]) -> Vec<Peer> {
(B[m[32m+    vec![]
(B[m[32m+}
(B[m[32m+fn create_block_proposal() -> Proposal {
(B[m[32m+    Proposal::default()
(B[m[32m+}
(B[m[32m+fn validate_proposal(_proposal: &Proposal) -> bool {
(B[m[32m+    true
(B[m[32m+}
(B[m[32m+fn aggregate_signatures(_sigs: &[Vec<u8>]) -> Vec<u8> {
(B[m[32m+    vec![0u8; 64]
(B[m[32m+}
(B[m 
 // Data structures
 #[derive(Default, Clone)]
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:327:
 struct Transaction;
 impl Transaction {
[31m-    fn serialize(&self) -> Vec<u8> { vec![0u8; 250] }
(B[m[31m-    fn deserialize(_data: &[u8]) -> Self { Transaction::default() }
(B[m[32m+    fn serialize(&self) -> Vec<u8> {
(B[m[32m+        vec![0u8; 250]
(B[m[32m+    }
(B[m[32m+    fn deserialize(_data: &[u8]) -> Self {
(B[m[32m+        Transaction::default()
(B[m[32m+    }
(B[m }
 
 #[derive(Default)]
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:336:
 #[derive(Default)]
 struct NetworkMessage;
 impl NetworkMessage {
[31m-    fn serialize(&self) -> Vec<u8> { vec![0u8; 100] }
(B[m[32m+    fn serialize(&self) -> Vec<u8> {
(B[m[32m+        vec![0u8; 100]
(B[m[32m+    }
(B[m }
 
 #[derive(Default, Clone)]
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:347:
 
 struct VM;
 impl VM {
[31m-    fn new() -> Self { VM }
(B[m[31m-    fn execute(&mut self, _script: &[u8]) -> bool { true }
(B[m[32m+    fn new() -> Self {
(B[m[32m+        VM
(B[m[32m+    }
(B[m[32m+    fn execute(&mut self, _script: &[u8]) -> bool {
(B[m[32m+        true
(B[m[32m+    }
(B[m }
 
 struct InMemoryStore;
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:355:
 impl InMemoryStore {
[31m-    fn new() -> Self { InMemoryStore }
(B[m[32m+    fn new() -> Self {
(B[m[32m+        InMemoryStore
(B[m[32m+    }
(B[m     fn put(&mut self, _key: &[u8], _value: &[u8]) {}
[31m-    fn get(&self, _key: &[u8]) -> Option<Vec<u8>> { Some(vec![]) }
(B[m[32m+    fn get(&self, _key: &[u8]) -> Option<Vec<u8>> {
(B[m[32m+        Some(vec![])
(B[m[32m+    }
(B[m     fn put_batch(&mut self, _batch: &[(Vec<u8>, Vec<u8>)]) {}
 }
 
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:362:
 struct ConsensusEngine;
 impl ConsensusEngine {
[31m-    fn new(_validators: usize) -> Self { ConsensusEngine }
(B[m[31m-    fn change_view(&mut self) -> bool { true }
(B[m[32m+    fn new(_validators: usize) -> Self {
(B[m[32m+        ConsensusEngine
(B[m[32m+    }
(B[m[32m+    fn change_view(&mut self) -> bool {
(B[m[32m+        true
(B[m[32m+    }
(B[m }
 
 // Define benchmark groups
Diff in /home/ubuntu/neo-rs/benches/performance_suite.rs:378:
 );
 
 criterion_main!(benches);
[32m+
(B[mDiff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:3:
 //! This file benchmarks the performance impact of our safety improvements
 //! to ensure they don't introduce significant overhead.
 
[31m-use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
(B[m[32m+use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};
(B[m use neo_core::{
     safe_error_handling::SafeError,
[31m-    safe_memory::{SafeBuffer, MemoryPool},
(B[m[31m-    transaction_validator::TransactionValidator,
(B[m[32m+    safe_memory::{MemoryPool, SafeBuffer},
(B[m     system_monitoring::{self, SYSTEM_MONITOR},
[32m+    transaction_validator::TransactionValidator,
(B[m };
 use neo_vm::{
[31m-    safe_execution::{SafeVmExecutor, ExecutionGuard},
(B[m[31m-    safe_type_conversion::SafeTypeConverter,
(B[m     performance_opt::SmartCloneStrategy,
[32m+    safe_execution::{ExecutionGuard, SafeVmExecutor},
(B[m[32m+    safe_type_conversion::SafeTypeConverter,
(B[m };
[31m-use std::time::Duration;
(B[m use std::sync::Arc;
[32m+use std::time::Duration;
(B[m 
 /// Benchmark safe error handling vs traditional error handling
 fn bench_error_handling(c: &mut Criterion) {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:23:
     let mut group = c.benchmark_group("error_handling");
[31m-    
(B[m[32m+
(B[m     // Traditional Result<T, String> error
     group.bench_function("traditional_error", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:29:
             black_box(result)
         })
     });
[31m-    
(B[m[32m+
(B[m     // SafeError with full context
     group.bench_function("safe_error", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:37:
                 "test error",
                 "bench_module",
                 42,
[31m-                "BenchError"
(B[m[32m+                "BenchError",
(B[m             ));
             black_box(result)
         })
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:44:
     });
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:49:
 /// Benchmark memory pool performance
 fn bench_memory_pool(c: &mut Criterion) {
     let mut group = c.benchmark_group("memory_pool");
[31m-    
(B[m[32m+
(B[m     // Direct allocation
     group.bench_function("direct_allocation", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:57:
             black_box(buffer)
         })
     });
[31m-    
(B[m[32m+
(B[m     // Memory pool allocation
     let pool: MemoryPool<Vec<u8>> = MemoryPool::new(100);
     group.bench_function("pool_allocation", |b| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:66:
             pool.return_item(buffer);
         })
     });
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:73:
 /// Benchmark monitoring overhead
 fn bench_monitoring(c: &mut Criterion) {
     let mut group = c.benchmark_group("monitoring");
[31m-    
(B[m[32m+
(B[m     // Transaction without monitoring
     group.bench_function("transaction_no_monitoring", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:83:
             let _ = black_box(true);
         })
     });
[31m-    
(B[m[32m+
(B[m     // Transaction with monitoring
     group.bench_function("transaction_with_monitoring", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:90:
[31m-            system_monitoring::record_transaction(
(B[m[31m-                1024,
(B[m[31m-                Duration::from_micros(100),
(B[m[31m-                true
(B[m[31m-            );
(B[m[32m+            system_monitoring::record_transaction(1024, Duration::from_micros(100), true);
(B[m         })
     });
[31m-    
(B[m[32m+
(B[m     // Block without monitoring
     group.bench_function("block_no_monitoring", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:103:
             let _ = black_box(150u64);
         })
     });
[31m-    
(B[m[32m+
(B[m     // Block with monitoring
     group.bench_function("block_with_monitoring", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:110:
             system_monitoring::record_block(12345, 50000, 150);
         })
     });
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:117:
 /// Benchmark smart cloning strategies
 fn bench_smart_cloning(c: &mut Criterion) {
     let mut group = c.benchmark_group("smart_cloning");
[31m-    
(B[m[32m+
(B[m     let strategy = SmartCloneStrategy::default();
[31m-    
(B[m[32m+
(B[m     // Small data (should clone)
     let small_data = vec![1u8; 100];
     group.bench_function("small_data_clone", |b| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:131:
             }
         })
     });
[31m-    
(B[m[32m+
(B[m     // Large data (should use Arc)
     let large_data = vec![1u8; 10000];
     group.bench_function("large_data_arc", |b| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:143:
             }
         })
     });
[31m-    
(B[m[32m+
(B[m     // Arc clone vs deep clone
     let arc_data = Arc::new(vec![1u8; 10000]);
[31m-    group.bench_function("arc_clone", |b| {
(B[m[31m-        b.iter(|| {
(B[m[31m-            arc_data.clone()
(B[m[31m-        })
(B[m[31m-    });
(B[m[31m-    
(B[m[31m-    group.bench_function("deep_clone", |b| {
(B[m[31m-        b.iter(|| {
(B[m[31m-            (*arc_data).clone()
(B[m[31m-        })
(B[m[31m-    });
(B[m[31m-    
(B[m[32m+    group.bench_function("arc_clone", |b| b.iter(|| arc_data.clone()));
(B[m[32m+
(B[m[32m+    group.bench_function("deep_clone", |b| b.iter(|| (*arc_data).clone()));
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:164:
 /// Benchmark safe buffer operations
 fn bench_safe_buffer(c: &mut Criterion) {
     let mut group = c.benchmark_group("safe_buffer");
[31m-    
(B[m[32m+
(B[m     // Unsafe buffer write
     group.bench_function("unsafe_write", |b| {
         let mut buffer = vec![0u8; 1024];
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:176:
             }
         })
     });
[31m-    
(B[m[32m+
(B[m     // Safe buffer write
     group.bench_function("safe_write", |b| {
         let mut buffer = SafeBuffer::new(1024);
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:185:
             buffer.clear();
         })
     });
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:192:
 /// Benchmark monitoring snapshot generation
 fn bench_snapshot_generation(c: &mut Criterion) {
     let mut group = c.benchmark_group("snapshot");
[31m-    
(B[m[32m+
(B[m     // Populate some metrics
     for i in 0..100 {
[31m-        system_monitoring::record_transaction(
(B[m[31m-            i * 1024,
(B[m[31m-            Duration::from_micros(i),
(B[m[31m-            i % 2 == 0
(B[m[31m-        );
(B[m[32m+        system_monitoring::record_transaction(i * 1024, Duration::from_micros(i), i % 2 == 0);
(B[m     }
[31m-    
(B[m[32m+
(B[m     group.bench_function("generate_snapshot", |b| {
         b.iter(|| {
             let snapshot = SYSTEM_MONITOR.snapshot();
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:208:
             black_box(snapshot)
         })
     });
[31m-    
(B[m[32m+
(B[m     group.bench_function("serialize_snapshot", |b| {
         let snapshot = SYSTEM_MONITOR.snapshot();
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:216:
             black_box(json)
         })
     });
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:223:
 /// Benchmark execution guard overhead
 fn bench_execution_guard(c: &mut Criterion) {
     let mut group = c.benchmark_group("execution_guard");
[31m-    
(B[m[32m+
(B[m     // Execution without guard
     group.bench_function("no_guard", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:235:
             black_box(sum)
         })
     });
[31m-    
(B[m[32m+
(B[m     // Execution with guard
     group.bench_function("with_guard", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:248:
             black_box(sum)
         })
     });
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:255:
 /// Benchmark type conversion safety
 fn bench_type_conversion(c: &mut Criterion) {
     let mut group = c.benchmark_group("type_conversion");
[31m-    
(B[m[32m+
(B[m     // Unsafe transmute (simulated)
     group.bench_function("unsafe_transmute", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:264:
             black_box(bytes)
         })
     });
[31m-    
(B[m[32m+
(B[m     // Safe type conversion
     group.bench_function("safe_conversion", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:276:
             }
         })
     });
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:283:
 /// Benchmark concurrent monitoring
 fn bench_concurrent_monitoring(c: &mut Criterion) {
     let mut group = c.benchmark_group("concurrent_monitoring");
[31m-    
(B[m[31m-    use std::thread;
(B[m[32m+
(B[m     use std::sync::Arc;
[31m-    
(B[m[32m+    use std::thread;
(B[m[32m+
(B[m     // Single-threaded monitoring
     group.bench_function("single_thread", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:293:
             for i in 0..100 {
[31m-                system_monitoring::record_transaction(
(B[m[31m-                    i,
(B[m[31m-                    Duration::from_micros(1),
(B[m[31m-                    true
(B[m[31m-                );
(B[m[32m+                system_monitoring::record_transaction(i, Duration::from_micros(1), true);
(B[m             }
         })
     });
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:302:
[31m-    
(B[m[32m+
(B[m     // Multi-threaded monitoring
     group.bench_function("multi_thread", |b| {
         b.iter(|| {
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:310:
                         system_monitoring::record_transaction(
                             t * 25 + i,
                             Duration::from_micros(1),
[31m-                            true
(B[m[32m+                            true,
(B[m                         );
                     }
                 });
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:321:
             }
         })
     });
[31m-    
(B[m[32m+
(B[m     group.finish();
 }
 
Diff in /home/ubuntu/neo-rs/benches/safety_benchmarks.rs:339:
 );
 
 criterion_main!(benches);
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:21:
 pub mod messages;
 pub mod proposal;
 pub mod recovery;
[32m+pub mod safe_consensus;
(B[m pub mod service;
 pub mod signature;
 pub mod validators;
Diff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:27:
[31m-pub mod safe_consensus;
(B[m 
 // Re-export main types
 pub use context::{ConsensusContext, ConsensusPhase, ConsensusRound, ConsensusTimer};
Diff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:44:
     ConsensusEvent, ConsensusService, ConsensusServiceConfig, ConsensusStats, LedgerService,
     MempoolService, NetworkService,
 };
[31m-pub use signature::{MessageSigner, SignatureProvider};
(B[m use sha2::{Digest, Sha256};
[32m+pub use signature::{MessageSigner, SignatureProvider};
(B[m use std::fmt;
 use thiserror::Error;
 pub use validators::{Validator, ValidatorConfig, ValidatorManager, ValidatorSet, ValidatorStats};
Diff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:52:
 
[31m-
(B[m /// Result type for consensus operations
 pub type Result<T> = std::result::Result<T, Error>;
 
Diff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:96:
     /// Configuration error
     #[error("Configuration error: {0}")]
     Configuration(String),
[31m-    
(B[m[32m+
(B[m     /// Invalid configuration
     #[error("Invalid configuration: {0}")]
     InvalidConfig(String),
Diff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:103:
[31m-    
(B[m[32m+
(B[m     /// Invalid view
     #[error("Invalid view: {0}")]
     InvalidView(String),
Diff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:107:
[31m-    
(B[m[32m+
(B[m     /// Invalid state
     #[error("Invalid state: {0}")]
     InvalidState(String),
Diff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:111:
[31m-    
(B[m[32m+
(B[m     /// Invalid vote
     #[error("Invalid vote: {0}")]
     InvalidVote(String),
Diff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:115:
[31m-    
(B[m[32m+
(B[m     /// Rate limit exceeded
     #[error("Rate limit exceeded: {0}")]
     RateLimitExceeded(String),
Diff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:119:
[31m-    
(B[m[32m+
(B[m     /// Circuit breaker open
     #[error("Circuit breaker open: {0}")]
     CircuitBreakerOpen(String),
Diff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:123:
[31m-    
(B[m[32m+
(B[m     /// Recovery failed
     #[error("Recovery failed: {0}")]
     RecoveryFailed(String),
Diff in /home/ubuntu/neo-rs/crates/consensus/src/lib.rs:127:
[31m-    
(B[m[32m+
(B[m     /// Recovery too soon
     #[error("Recovery too soon: {0}")]
     RecoveryTooSoon(String),
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:109:
         message_type: ConsensusMessageType,
     ) -> neo_io::IoResult<Self> {
         match message_type {
[31m-            ConsensusMessageType::PrepareRequest => {
(B[m[31m-                Ok(Self::PrepareRequest(<PrepareRequest as Serializable>::deserialize(reader)?))
(B[m[32m+            ConsensusMessageType::PrepareRequest => Ok(Self::PrepareRequest(
(B[m[32m+                <PrepareRequest as Serializable>::deserialize(reader)?,
(B[m[32m+            )),
(B[m[32m+            ConsensusMessageType::PrepareResponse => Ok(Self::PrepareResponse(
(B[m[32m+                <PrepareResponse as Serializable>::deserialize(reader)?,
(B[m[32m+            )),
(B[m[32m+            ConsensusMessageType::Commit => {
(B[m[32m+                Ok(Self::Commit(<Commit as Serializable>::deserialize(reader)?))
(B[m             }
[31m-            ConsensusMessageType::PrepareResponse => {
(B[m[31m-                Ok(Self::PrepareResponse(<PrepareResponse as Serializable>::deserialize(reader)?))
(B[m[31m-            }
(B[m[31m-            ConsensusMessageType::Commit => Ok(Self::Commit(<Commit as Serializable>::deserialize(reader)?)),
(B[m[31m-            ConsensusMessageType::ChangeView => {
(B[m[31m-                Ok(Self::ChangeView(<ChangeView as Serializable>::deserialize(reader)?))
(B[m[31m-            }
(B[m[31m-            ConsensusMessageType::RecoveryRequest => {
(B[m[31m-                Ok(Self::RecoveryRequest(<RecoveryRequest as Serializable>::deserialize(reader)?))
(B[m[31m-            }
(B[m[32m+            ConsensusMessageType::ChangeView => Ok(Self::ChangeView(
(B[m[32m+                <ChangeView as Serializable>::deserialize(reader)?,
(B[m[32m+            )),
(B[m[32m+            ConsensusMessageType::RecoveryRequest => Ok(Self::RecoveryRequest(
(B[m[32m+                <RecoveryRequest as Serializable>::deserialize(reader)?,
(B[m[32m+            )),
(B[m             ConsensusMessageType::RecoveryResponse => Ok(Self::RecoveryResponse(
                 <RecoveryResponse as Serializable>::deserialize(reader)?,
             )),
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:233:
         // Serialize message type
         let _ = writer.write_u8(self.message_type.to_byte())?;
 
[31m-        // Serialize payload  
(B[m[32m+        // Serialize payload
(B[m         let _ = writer.write_u8(self.payload.validator_index)?;
         let _ = writer.write_u32(self.payload.block_index.value())?;
         let _ = writer.write_u8(self.payload.view_number.value())?;
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:251:
     }
 
     fn deserialize(reader: &mut MemoryReader) -> neo_io::IoResult<Self> {
[31m-        let message_type = ConsensusMessageType::from_byte(reader.read_byte()?)
(B[m[31m-            .ok_or_else(|| neo_io::IoError::InvalidFormat {
(B[m[31m-                expected_format: "ConsensusMessageType".to_string(),
(B[m[31m-                reason: "Unknown message type".to_string(),
(B[m[32m+        let message_type =
(B[m[32m+            ConsensusMessageType::from_byte(reader.read_byte()?).ok_or_else(|| {
(B[m[32m+                neo_io::IoError::InvalidFormat {
(B[m[32m+                    expected_format: "ConsensusMessageType".to_string(),
(B[m[32m+                    reason: "Unknown message type".to_string(),
(B[m[32m+                }
(B[m             })?;
 
         let validator_index = reader.read_byte()?;
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:262:
         let view_number = ViewNumber::new(reader.read_byte()?);
         let timestamp = reader.read_u64()?;
         let payload_data = reader.read_var_bytes(1024)?; // Payload data
[31m-        
(B[m[32m+
(B[m         let payload = ConsensusPayload {
             validator_index,
             block_index,
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:378:
     fn serialize(&self, writer: &mut BinaryWriter) -> neo_io::IoResult<()> {
         writer.write_serializable(&self.preparation_hash)?;
         let _ = writer.write_u8(if self.accepted { 1 } else { 0 })?;
[31m-        let _ = writer.write_u8(if self.rejection_reason.is_some() { 1 } else { 0 })?;
(B[m[32m+        let _ = writer.write_u8(if self.rejection_reason.is_some() {
(B[m[32m+            1
(B[m[32m+        } else {
(B[m[32m+            0
(B[m[32m+        })?;
(B[m         if let Some(ref reason) = self.rejection_reason {
             let _ = writer.write_var_string(reason)?;
         }
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:462:
         neo_io::helper::get_var_size(self.commits.len() as u64) +
         self.prepare_request.as_ref().map_or(1, |m| 1 + m.size())
     }
[31m-    
(B[m[32m+
(B[m     fn serialize(&self, writer: &mut BinaryWriter) -> neo_io::IoResult<()> {
         // Serialize block index and view number
         let _ = writer.write_u32(self.block_index.value())?;
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:469:
         let _ = writer.write_u8(self.view_number.value())?;
[31m-        
(B[m[32m+
(B[m         // Serialize change views
         let _ = writer.write_var_int(self.change_views.len() as u64)?;
         for (_, cv) in &self.change_views {
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:474:
             Serializable::serialize(cv, writer)?;
         }
[31m-        
(B[m[32m+
(B[m         // Serialize prepare responses
         let _ = writer.write_var_int(self.prepare_responses.len() as u64)?;
         for (_, pr) in &self.prepare_responses {
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:480:
             Serializable::serialize(pr, writer)?;
         }
[31m-        
(B[m[32m+
(B[m         // Serialize commits
         let _ = writer.write_var_int(self.commits.len() as u64)?;
         for (_, c) in &self.commits {
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:486:
             Serializable::serialize(c, writer)?;
         }
[31m-        
(B[m[32m+
(B[m         // Serialize prepare request
         let _ = writer.write_u8(if self.prepare_request.is_some() { 1 } else { 0 })?;
         if let Some(ref pr) = self.prepare_request {
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:492:
             Serializable::serialize(pr, writer)?;
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     fn deserialize(reader: &mut MemoryReader) -> neo_io::IoResult<Self> {
         let block_index = BlockIndex::new(reader.read_u32()?);
         let view_number = ViewNumber::new(reader.read_byte()?);
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:501:
[31m-        
(B[m[32m+
(B[m         // Read change views
         let cv_count = reader.read_var_int(1000)? as usize;
         let mut change_views = HashMap::new();
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:506:
             let cv = <ChangeView as Serializable>::deserialize(reader)?;
             change_views.insert(i as u8, cv);
         }
[31m-        
(B[m[32m+
(B[m         // Read prepare responses
         let pr_count = reader.read_var_int(1000)? as usize;
         let mut prepare_responses = HashMap::new();
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:514:
             let pr = <PrepareResponse as Serializable>::deserialize(reader)?;
             prepare_responses.insert(i as u8, pr);
         }
[31m-        
(B[m[32m+
(B[m         // Read commits
         let c_count = reader.read_var_int(1000)? as usize;
         let mut commits = HashMap::new();
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:522:
             let c = <Commit as Serializable>::deserialize(reader)?;
             commits.insert(i as u8, c);
         }
[31m-        
(B[m[32m+
(B[m         // Read prepare request
         let has_prepare = reader.read_byte()? != 0;
         let prepare_request = if has_prepare {
Diff in /home/ubuntu/neo-rs/crates/consensus/src/messages.rs:530:
         } else {
             None
         };
[31m-        
(B[m[32m+
(B[m         Ok(Self {
             block_index,
             view_number,
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:28:
     pub fn new(node_index: u32, node_count: u32) -> ConsensusResult<Self> {
         if node_count == 0 {
             return Err(ConsensusError::InvalidConfig(
[31m-                "Node count cannot be zero".to_string()
(B[m[32m+                "Node count cannot be zero".to_string(),
(B[m             ));
         }
[31m-        
(B[m[32m+
(B[m         if node_index >= node_count {
[31m-            return Err(ConsensusError::InvalidConfig(
(B[m[31m-                format!("Node index {} >= node count {}", node_index, node_count)
(B[m[31m-            ));
(B[m[32m+            return Err(ConsensusError::InvalidConfig(format!(
(B[m[32m+                "Node index {} >= node count {}",
(B[m[32m+                node_index, node_count
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[32m+
(B[m         Ok(Self {
             view: 0,
             height: 0,
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:47:
             error_count: 0,
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Safely change view
     pub fn change_view(&mut self, new_view: u32) -> ConsensusResult<()> {
         // Prevent view from going backwards
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:54:
         if new_view < self.view {
[31m-            return Err(ConsensusError::InvalidView(
(B[m[31m-                format!("Cannot decrease view from {} to {}", self.view, new_view)
(B[m[31m-            ));
(B[m[32m+            return Err(ConsensusError::InvalidView(format!(
(B[m[32m+                "Cannot decrease view from {} to {}",
(B[m[32m+                self.view, new_view
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[32m+
(B[m         // Prevent excessive view changes (possible attack)
         const MAX_VIEW_JUMP: u32 = 10;
         if new_view > self.view + MAX_VIEW_JUMP {
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:63:
[31m-            return Err(ConsensusError::InvalidView(
(B[m[31m-                format!("View jump too large: {} -> {}", self.view, new_view)
(B[m[31m-            ));
(B[m[32m+            return Err(ConsensusError::InvalidView(format!(
(B[m[32m+                "View jump too large: {} -> {}",
(B[m[32m+                self.view, new_view
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[32m+
(B[m         self.view = new_view;
         Ok(())
     }
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:71:
[31m-    
(B[m[32m+
(B[m     /// Safely increment height
     pub fn increment_height(&mut self) -> ConsensusResult<()> {
         // Check for height overflow
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:75:
         if self.height == u32::MAX {
             return Err(ConsensusError::InvalidState(
[31m-                "Height overflow detected".to_string()
(B[m[32m+                "Height overflow detected".to_string(),
(B[m             ));
         }
[31m-        
(B[m[32m+
(B[m         self.height += 1;
         self.view = 0; // Reset view on new height
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:84:
     }
[31m-    
(B[m[32m+
(B[m     /// Get primary node index for current view
     pub fn get_primary_index(&self) -> u32 {
         (self.height - self.view) % self.node_count
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:89:
     }
[31m-    
(B[m[32m+
(B[m     /// Check if this node is primary
     pub fn is_primary(&self) -> bool {
         self.get_primary_index() == self.node_index
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:94:
     }
[31m-    
(B[m[32m+
(B[m     /// Record an error with rate limiting
     pub fn record_error(&mut self) -> ConsensusResult<()> {
         let now = Instant::now();
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:99:
[31m-        
(B[m[32m+
(B[m         // Rate limit errors
         if let Some(last_time) = self.last_error_time {
             if now.duration_since(last_time) < Duration::from_millis(100) {
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:103:
                 return Err(ConsensusError::RateLimitExceeded(
[31m-                    "Too many errors in short time".to_string()
(B[m[32m+                    "Too many errors in short time".to_string(),
(B[m                 ));
             }
         }
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:108:
[31m-        
(B[m[32m+
(B[m         self.last_error_time = Some(now);
         self.error_count += 1;
[31m-        
(B[m[32m+
(B[m         // Circuit breaker pattern
         const MAX_ERRORS: u32 = 10;
         if self.error_count > MAX_ERRORS {
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:115:
[31m-            return Err(ConsensusError::CircuitBreakerOpen(
(B[m[31m-                format!("Too many errors: {}", self.error_count)
(B[m[31m-            ));
(B[m[32m+            return Err(ConsensusError::CircuitBreakerOpen(format!(
(B[m[32m+                "Too many errors: {}",
(B[m[32m+                self.error_count
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Reset error count (e.g., after successful operation)
     pub fn reset_errors(&mut self) {
         self.error_count = 0;
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:143:
             validate_signatures: true,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Validate consensus message safely
     pub fn validate_message(&self, message: &[u8]) -> ConsensusResult<()> {
         // Check message size
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:150:
         if message.is_empty() {
             return Err(ConsensusError::InvalidMessage(
[31m-                "Empty consensus message".to_string()
(B[m[32m+                "Empty consensus message".to_string(),
(B[m             ));
         }
[31m-        
(B[m[32m+
(B[m         if message.len() > self.max_message_size {
[31m-            return Err(ConsensusError::InvalidMessage(
(B[m[31m-                format!("Message size {} exceeds maximum {}", 
(B[m[31m-                    message.len(), self.max_message_size)
(B[m[31m-            ));
(B[m[32m+            return Err(ConsensusError::InvalidMessage(format!(
(B[m[32m+                "Message size {} exceeds maximum {}",
(B[m[32m+                message.len(),
(B[m[32m+                self.max_message_size
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[32m+
(B[m         // Additional validation could be added here
         // e.g., message type validation, signature verification
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Validate proposal
     pub fn validate_proposal(
         &self,
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:172:
         proposal_view: u32,
         current_view: u32,
         proposal_height: u32,
[31m-        current_height: u32
(B[m[32m+        current_height: u32,
(B[m     ) -> ConsensusResult<()> {
         // Proposal must be for current or future view
         if proposal_view < current_view {
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:179:
[31m-            return Err(ConsensusError::InvalidProposal(
(B[m[31m-                format!("Proposal view {} < current view {}", proposal_view, current_view)
(B[m[31m-            ));
(B[m[32m+            return Err(ConsensusError::InvalidProposal(format!(
(B[m[32m+                "Proposal view {} < current view {}",
(B[m[32m+                proposal_view, current_view
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[32m+
(B[m         // Proposal must be for current height
         if proposal_height != current_height {
[31m-            return Err(ConsensusError::InvalidProposal(
(B[m[31m-                format!("Proposal height {} != current height {}", 
(B[m[31m-                    proposal_height, current_height)
(B[m[31m-            ));
(B[m[32m+            return Err(ConsensusError::InvalidProposal(format!(
(B[m[32m+                "Proposal height {} != current height {}",
(B[m[32m+                proposal_height, current_height
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Validate vote
     pub fn validate_vote(
         &self,
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:198:
         vote_view: u32,
         current_view: u32,
         vote_height: u32,
[31m-        current_height: u32
(B[m[32m+        current_height: u32,
(B[m     ) -> ConsensusResult<()> {
         // Vote must be for current view and height
         if vote_view != current_view {
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:205:
[31m-            return Err(ConsensusError::InvalidVote(
(B[m[31m-                format!("Vote view {} != current view {}", vote_view, current_view)
(B[m[31m-            ));
(B[m[32m+            return Err(ConsensusError::InvalidVote(format!(
(B[m[32m+                "Vote view {} != current view {}",
(B[m[32m+                vote_view, current_view
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[32m+
(B[m         if vote_height != current_height {
[31m-            return Err(ConsensusError::InvalidVote(
(B[m[31m-                format!("Vote height {} != current height {}", vote_height, current_height)
(B[m[31m-            ));
(B[m[32m+            return Err(ConsensusError::InvalidVote(format!(
(B[m[32m+                "Vote height {} != current height {}",
(B[m[32m+                vote_height, current_height
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:236:
             timeout_multiplier: 1,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get current timeout duration
     pub fn get_timeout(&self) -> Duration {
         let timeout = self.base_timeout * self.timeout_multiplier;
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:243:
         timeout.min(self.max_timeout)
     }
[31m-    
(B[m[32m+
(B[m     /// Increase timeout (exponential backoff)
     pub fn increase_timeout(&mut self) {
         const MAX_MULTIPLIER: u32 = 32;
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:250:
             self.timeout_multiplier *= 2;
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Reset timeout to base value
     pub fn reset_timeout(&mut self) {
         self.timeout_multiplier = 1;
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:257:
     }
[31m-    
(B[m[32m+
(B[m     /// Check if timeout has expired
     pub fn is_expired(&self, start_time: Instant) -> bool {
         start_time.elapsed() > self.get_timeout()
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:281:
             last_recovery: None,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Attempt recovery
     pub fn attempt_recovery(&mut self) -> ConsensusResult<()> {
         // Check if we've exceeded max attempts
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:288:
         if self.recovery_attempts >= self.max_attempts {
[31m-            return Err(ConsensusError::RecoveryFailed(
(B[m[31m-                format!("Exceeded maximum recovery attempts: {}", self.max_attempts)
(B[m[31m-            ));
(B[m[32m+            return Err(ConsensusError::RecoveryFailed(format!(
(B[m[32m+                "Exceeded maximum recovery attempts: {}",
(B[m[32m+                self.max_attempts
(B[m[32m+            )));
(B[m         }
[31m-        
(B[m[32m+
(B[m         // Rate limit recovery attempts
         if let Some(last_time) = self.last_recovery {
             const MIN_RECOVERY_INTERVAL: Duration = Duration::from_secs(5);
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:297:
             if last_time.elapsed() < MIN_RECOVERY_INTERVAL {
                 return Err(ConsensusError::RecoveryTooSoon(
[31m-                    "Recovery attempted too soon after last attempt".to_string()
(B[m[32m+                    "Recovery attempted too soon after last attempt".to_string(),
(B[m                 ));
             }
         }
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:303:
[31m-        
(B[m[32m+
(B[m         self.recovery_attempts += 1;
         self.last_recovery = Some(Instant::now());
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:307:
     }
[31m-    
(B[m[32m+
(B[m     /// Reset recovery state after successful consensus
     pub fn reset(&mut self) {
         self.recovery_attempts = 0;
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:312:
         self.last_recovery = None;
     }
[31m-    
(B[m[32m+
(B[m     /// Check if recovery is needed based on error patterns
     pub fn needs_recovery(&self, consecutive_errors: u32) -> bool {
         consecutive_errors >= 3 && self.recovery_attempts < self.max_attempts
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:321:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_consensus_state() {
         // Valid creation
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:328:
         let mut state = SafeConsensusState::new(1, 4).unwrap();
         assert_eq!(state.view, 0);
         assert_eq!(state.height, 0);
[31m-        
(B[m[32m+
(B[m         // Invalid creation
         assert!(SafeConsensusState::new(0, 0).is_err());
         assert!(SafeConsensusState::new(5, 4).is_err());
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:335:
[31m-        
(B[m[32m+
(B[m         // View change
         assert!(state.change_view(1).is_ok());
         assert!(state.change_view(0).is_err()); // Can't go backwards
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:339:
         assert!(state.change_view(100).is_err()); // Too large jump
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_message_validator() {
         let validator = SafeMessageValidator::new(1024);
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:345:
[31m-        
(B[m[32m+
(B[m         // Valid message
         assert!(validator.validate_message(b"valid message").is_ok());
[31m-        
(B[m[32m+
(B[m         // Empty message
         assert!(validator.validate_message(b"").is_err());
[31m-        
(B[m[32m+
(B[m         // Too large message
         let large_message = vec![0u8; 1025];
         assert!(validator.validate_message(&large_message).is_err());
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:355:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_timeout_manager() {
[31m-        let mut manager = SafeTimeoutManager::new(
(B[m[31m-            Duration::from_secs(1),
(B[m[31m-            Duration::from_secs(30)
(B[m[31m-        );
(B[m[31m-        
(B[m[32m+        let mut manager = SafeTimeoutManager::new(Duration::from_secs(1), Duration::from_secs(30));
(B[m[32m+
(B[m         assert_eq!(manager.get_timeout(), Duration::from_secs(1));
[31m-        
(B[m[32m+
(B[m         manager.increase_timeout();
         assert_eq!(manager.get_timeout(), Duration::from_secs(2));
[31m-        
(B[m[32m+
(B[m         manager.increase_timeout();
         assert_eq!(manager.get_timeout(), Duration::from_secs(4));
[31m-        
(B[m[32m+
(B[m         manager.reset_timeout();
         assert_eq!(manager.get_timeout(), Duration::from_secs(1));
     }
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:375:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_recovery_manager() {
         let mut manager = SafeRecoveryManager::new(3);
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:379:
[31m-        
(B[m[32m+
(B[m         // First recovery should succeed
         assert!(manager.attempt_recovery().is_ok());
[31m-        
(B[m[32m+
(B[m         // Too soon for another recovery
         assert!(manager.attempt_recovery().is_err());
[31m-        
(B[m[32m+
(B[m         // After waiting, recovery should work
         std::thread::sleep(Duration::from_secs(6));
         assert!(manager.attempt_recovery().is_ok());
Diff in /home/ubuntu/neo-rs/crates/consensus/src/safe_consensus.rs:389:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/error.rs:10:
 pub enum CoreError {
     /// Invalid format error with detailed description
     #[error("Invalid format: {message}")]
[31m-    InvalidFormat { 
(B[m[32m+    InvalidFormat {
(B[m         /// Error message describing the format issue
[31m-        message: String 
(B[m[32m+        message: String,
(B[m     },
 
     /// Invalid data error with context
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:19:
     #[error("Invalid data: {message}")]
[31m-    InvalidData { 
(B[m[32m+    InvalidData {
(B[m         /// Error message describing the data issue
[31m-        message: String 
(B[m[32m+        message: String,
(B[m     },
 
     /// I/O operation failed
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:26:
     #[error("I/O error: {message}")]
[31m-    Io { 
(B[m[32m+    Io {
(B[m         /// Error message describing the I/O issue
[31m-        message: String 
(B[m[32m+        message: String,
(B[m     },
 
     /// Serialization failed
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:33:
     #[error("Serialization error: {message}")]
[31m-    Serialization { 
(B[m[32m+    Serialization {
(B[m         /// Error message describing the serialization issue
[31m-        message: String 
(B[m[32m+        message: String,
(B[m     },
 
     /// Deserialization failed
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:40:
     #[error("Deserialization error: {message}")]
[31m-    Deserialization { 
(B[m[32m+    Deserialization {
(B[m         /// Error message describing the deserialization issue
[31m-        message: String 
(B[m[32m+        message: String,
(B[m     },
 
     /// Invalid operation attempted
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:47:
     #[error("Invalid operation: {message}")]
[31m-    InvalidOperation { 
(B[m[32m+    InvalidOperation {
(B[m         /// Error message describing the invalid operation
[31m-        message: String 
(B[m[32m+        message: String,
(B[m     },
 
     /// System-level error
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:54:
     #[error("System error: {message}")]
[31m-    System { 
(B[m[32m+    System {
(B[m         /// Error message describing the system issue
[31m-        message: String 
(B[m[32m+        message: String,
(B[m     },
 
     /// Insufficient gas for operation
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:61:
     #[error("Insufficient gas: required {required}, available {available}")]
[31m-    InsufficientGas { 
(B[m[32m+    InsufficientGas {
(B[m         /// Amount of gas required for the operation
[31m-        required: u64, 
(B[m[32m+        required: u64,
(B[m         /// Amount of gas available
[31m-        available: u64 
(B[m[32m+        available: u64,
(B[m     },
 
     /// Cryptographic operation failed
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:70:
     #[error("Cryptographic error: {message}")]
[31m-    Cryptographic { 
(B[m[32m+    Cryptographic {
(B[m         /// Error message describing the cryptographic issue
[31m-        message: String 
(B[m[32m+        message: String,
(B[m     },
 
     /// Buffer overflow or underflow
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:77:
     #[error(
         "Buffer overflow: attempted to read {requested} bytes, but only {available} available"
     )]
[31m-    BufferOverflow { 
(B[m[32m+    BufferOverflow {
(B[m         /// Amount of space requested
[31m-        requested: usize, 
(B[m[32m+        requested: usize,
(B[m         /// Amount of space available
[31m-        available: usize 
(B[m[32m+        available: usize,
(B[m     },
 
     /// Unexpected end of stream
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:90:
 
     /// Configuration error
     #[error("Configuration error: {message}")]
[31m-    Configuration { 
(B[m[32m+    Configuration {
(B[m         /// Error message describing the configuration issue
[31m-        message: String 
(B[m[32m+        message: String,
(B[m     },
 
     /// Network-related error
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:99:
     #[error("Network error: {message}")]
[31m-    Network { 
(B[m[32m+    Network {
(B[m         /// Error message describing the network issue
[31m-        message: String 
(B[m[32m+        message: String,
(B[m     },
 
     /// Timeout error
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:106:
     #[error("Operation timed out after {duration_ms}ms")]
[31m-    Timeout { 
(B[m[32m+    Timeout {
(B[m         /// Duration in milliseconds before timeout
[31m-        duration_ms: u64 
(B[m[32m+        duration_ms: u64,
(B[m     },
 
     /// Resource not found
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:113:
     #[error("Resource not found: {resource}")]
[31m-    NotFound { 
(B[m[32m+    NotFound {
(B[m         /// Name of the resource that was not found
[31m-        resource: String 
(B[m[32m+        resource: String,
(B[m     },
 
     /// Resource already exists
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:120:
     #[error("Resource already exists: {resource}")]
[31m-    AlreadyExists { 
(B[m[32m+    AlreadyExists {
(B[m         /// Name of the resource that already exists
[31m-        resource: String 
(B[m[32m+        resource: String,
(B[m     },
 
     /// Validation failed
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:127:
     #[error("Validation failed: {reason}")]
[31m-    ValidationFailed { 
(B[m[32m+    ValidationFailed {
(B[m         /// Reason why validation failed
[31m-        reason: String 
(B[m[32m+        reason: String,
(B[m     },
 
     /// Type conversion failed
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:134:
     #[error("Type conversion failed: cannot convert {from} to {to}")]
[31m-    TypeConversion { 
(B[m[32m+    TypeConversion {
(B[m         /// Source type name
[31m-        from: String, 
(B[m[32m+        from: String,
(B[m         /// Target type name
[31m-        to: String 
(B[m[32m+        to: String,
(B[m     },
 
     /// Validation error
Diff in /home/ubuntu/neo-rs/crates/core/src/error.rs:143:
     #[error("Validation error: {message}")]
[31m-    Validation { 
(B[m[32m+    Validation {
(B[m         /// Validation error message
[31m-        message: String 
(B[m[32m+        message: String,
(B[m     },
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:1:
 //! Enhanced Error Handling Module
[31m-//! 
(B[m[32m+//!
(B[m //! Provides comprehensive error handling utilities to replace unwrap() and panic! patterns
 //! throughout the Neo Rust codebase.
 
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:191:
     fn context<C>(self, context: C) -> Result<T>
     where
         C: fmt::Display + Send + Sync + 'static;
[31m-    
(B[m[32m+
(B[m     /// Add context with a closure (lazy evaluation)
     fn with_context<C, F>(self, f: F) -> Result<T>
     where
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:212:
             NeoError::Internal(format!("{}: {}", context, base_error))
         })
     }
[31m-    
(B[m[32m+
(B[m     fn with_context<C, F>(self, f: F) -> Result<T>
     where
         C: fmt::Display + Send + Sync + 'static,
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:232:
     fn unwrap_or_default(self) -> T
     where
         T: Default;
[31m-    
(B[m[32m+
(B[m     /// Unwrap with a provided default
     fn unwrap_or_else_default<F>(self, f: F) -> T
     where
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:239:
         F: FnOnce() -> T;
[31m-    
(B[m[32m+
(B[m     /// Log error and return default
     fn unwrap_or_log(self, message: &str) -> T
     where
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:254:
             T::default()
         })
     }
[31m-    
(B[m[32m+
(B[m     fn unwrap_or_else_default<F>(self, f: F) -> T
     where
         F: FnOnce() -> T,
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:264:
             f()
         })
     }
[31m-    
(B[m[32m+
(B[m     fn unwrap_or_log(self, message: &str) -> T
     where
         T: Default,
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:292:
             backoff_ms,
         }
     }
[31m-    
(B[m[32m+
(B[m     pub async fn retry<F, Fut, T>(&self, mut f: F) -> Result<T>
     where
         F: FnMut() -> Fut,
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:299:
         Fut: std::future::Future<Output = Result<T>>,
     {
         let mut attempts = 0;
[31m-        
(B[m[32m+
(B[m         loop {
             attempts += 1;
[31m-            
(B[m[32m+
(B[m             match f().await {
                 Ok(value) => return Ok(value),
                 Err(e) if attempts >= self.max_attempts => return Err(e),
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:314:
                         e,
                         self.backoff_ms * attempts as u64
                     );
[31m-                    
(B[m[31m-                    tokio::time::sleep(
(B[m[31m-                        std::time::Duration::from_millis(self.backoff_ms * attempts as u64)
(B[m[31m-                    ).await;
(B[m[32m+
(B[m[32m+                    tokio::time::sleep(std::time::Duration::from_millis(
(B[m[32m+                        self.backoff_ms * attempts as u64,
(B[m[32m+                    ))
(B[m[32m+                    .await;
(B[m                 }
             }
         }
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:351:
             state: std::sync::Arc::new(std::sync::Mutex::new(CircuitState::Closed)),
         }
     }
[31m-    
(B[m[32m+
(B[m     pub async fn call<F, Fut, T>(&self, f: F) -> Result<T>
     where
         F: FnOnce() -> Fut,
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:358:
         Fut: std::future::Future<Output = Result<T>>,
     {
         let state = self.state.lock().unwrap().clone();
[31m-        
(B[m[32m+
(B[m         match state {
             CircuitState::Open(opened_at) => {
                 if opened_at.elapsed().as_millis() > self.timeout_ms as u128 {
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:370:
                             Ok(value)
                         }
                         Err(e) => {
[31m-                            *self.state.lock().unwrap() = CircuitState::Open(std::time::Instant::now());
(B[m[32m+                            *self.state.lock().unwrap() =
(B[m[32m+                                CircuitState::Open(std::time::Instant::now());
(B[m                             Err(e)
                         }
                     }
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:378:
                     Err(NeoError::Internal("Circuit breaker is open".to_string()))
                 }
             }
[31m-            CircuitState::HalfOpen | CircuitState::Closed => {
(B[m[31m-                match f().await {
(B[m[31m-                    Ok(value) => {
(B[m[31m-                        *self.state.lock().unwrap() = CircuitState::Closed;
(B[m[31m-                        Ok(value)
(B[m[31m-                    }
(B[m[31m-                    Err(e) => {
(B[m[31m-                        *self.state.lock().unwrap() = CircuitState::Open(std::time::Instant::now());
(B[m[31m-                        Err(e)
(B[m[31m-                    }
(B[m[32m+            CircuitState::HalfOpen | CircuitState::Closed => match f().await {
(B[m[32m+                Ok(value) => {
(B[m[32m+                    *self.state.lock().unwrap() = CircuitState::Closed;
(B[m[32m+                    Ok(value)
(B[m                 }
[31m-            }
(B[m[32m+                Err(e) => {
(B[m[32m+                    *self.state.lock().unwrap() = CircuitState::Open(std::time::Instant::now());
(B[m[32m+                    Err(e)
(B[m[32m+                }
(B[m[32m+            },
(B[m         }
     }
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:429:
 #[allow(dead_code)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_error_context() {
         let result: Result<()> = Err(NeoError::NotFound("block".to_string()));
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:436:
         let with_context = result.context("Failed to process block");
         assert!(with_context.is_err());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_unwrap() {
         let result: Result<i32> = Err(NeoError::Internal("test".to_string()));
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:443:
         let value = result.unwrap_or_default();
         assert_eq!(value, 0);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_retry_policy() {
         let policy = RetryPolicy::new(3, 100);
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:450:
         let attempts = std::sync::Arc::new(std::sync::Mutex::new(0));
         let attempts_clone = attempts.clone();
[31m-        
(B[m[31m-        let result = policy.retry(move || {
(B[m[31m-            let attempts = attempts_clone.clone();
(B[m[31m-            async move {
(B[m[31m-                let mut count = attempts.lock().unwrap();
(B[m[31m-                *count += 1;
(B[m[31m-                if *count < 3 {
(B[m[31m-                    Err(NeoError::Internal("retry test".to_string()))
(B[m[31m-                } else {
(B[m[31m-                    Ok(42)
(B[m[32m+
(B[m[32m+        let result = policy
(B[m[32m+            .retry(move || {
(B[m[32m+                let attempts = attempts_clone.clone();
(B[m[32m+                async move {
(B[m[32m+                    let mut count = attempts.lock().unwrap();
(B[m[32m+                    *count += 1;
(B[m[32m+                    if *count < 3 {
(B[m[32m+                        Err(NeoError::Internal("retry test".to_string()))
(B[m[32m+                    } else {
(B[m[32m+                        Ok(42)
(B[m[32m+                    }
(B[m                 }
[31m-            }
(B[m[31m-        }).await;
(B[m[31m-        
(B[m[32m+            })
(B[m[32m+            .await;
(B[m[32m+
(B[m         assert!(result.is_ok());
         assert_eq!(result.unwrap(), 42);
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/error_handling.rs:469:
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/lib.rs:27:
 //!
 //! // Create a new transaction hash
 //! let hash = UInt256::zero();
[31m-//! 
(B[m[32m+//!
(B[m //! // Work with transactions and blocks
 //! // let transaction = Transaction::new();
 //! // let block = Block::new();
Diff in /home/ubuntu/neo-rs/crates/core/src/lib.rs:60:
 pub mod error_handling;
 /// Error utility functions
 pub mod error_utils;
[31m-/// Safe arithmetic and type operations
(B[m[31m-pub mod safe_operations;
(B[m[31m-/// Enhanced safe error handling system
(B[m[31m-pub mod safe_error_handling;
(B[m[31m-/// Migration helpers for transitioning to safe error handling
(B[m[31m-pub mod migration_helpers;
(B[m[31m-/// Safe memory operations for core types
(B[m[31m-pub mod safe_memory;
(B[m[31m-/// Transaction validation module
(B[m[31m-pub mod transaction_validator;
(B[m[31m-/// System-wide monitoring and metrics
(B[m[31m-pub mod system_monitoring;
(B[m /// Event system for blockchain events
 pub mod events;
 /// Core extensions and utility traits
Diff in /home/ubuntu/neo-rs/crates/core/src/lib.rs:80:
 pub mod hardfork;
 /// System metrics collection
 pub mod metrics;
[32m+/// Migration helpers for transitioning to safe error handling
(B[m[32m+pub mod migration_helpers;
(B[m /// Monitoring and alerting system
 pub mod monitoring;
 /// Neo system management
Diff in /home/ubuntu/neo-rs/crates/core/src/lib.rs:86:
 pub mod neo_system;
[32m+/// Enhanced safe error handling system
(B[m[32m+pub mod safe_error_handling;
(B[m[32m+/// Safe memory operations for core types
(B[m[32m+pub mod safe_memory;
(B[m[32m+/// Safe arithmetic and type operations
(B[m[32m+pub mod safe_operations;
(B[m /// Graceful shutdown coordination
 pub mod shutdown;
 /// Transaction signer implementation
Diff in /home/ubuntu/neo-rs/crates/core/src/lib.rs:90:
 pub mod signer;
[32m+/// System-wide monitoring and metrics
(B[m[32m+pub mod system_monitoring;
(B[m /// Transaction structures and validation
 pub mod transaction;
 /// Transaction type definitions
Diff in /home/ubuntu/neo-rs/crates/core/src/lib.rs:94:
 pub mod transaction_type;
[32m+/// Transaction validation module
(B[m[32m+pub mod transaction_validator;
(B[m /// 160-bit unsigned integer implementation
 pub mod uint160;
 /// 256-bit unsigned integer implementation
Diff in /home/ubuntu/neo-rs/crates/core/src/lib.rs:204:
     /// A reference to self as a trait object.
     fn as_any(&self) -> &dyn std::any::Any;
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/metrics.rs:176:
 }
 
 /// Get metrics in Prometheus text format
[31m-    /// Gets a value from the internal state.
(B[m[32m+/// Gets a value from the internal state.
(B[m pub fn get_metrics() -> String {
     let encoder = TextEncoder::new();
     let metric_families = REGISTRY.read().unwrap().gather();
Diff in /home/ubuntu/neo-rs/crates/core/src/metrics.rs:186:
 }
 
 /// Update blockchain metrics
[31m-    /// Updates the internal state.
(B[m[32m+/// Updates the internal state.
(B[m pub fn update_blockchain_metrics(height: u64, processing_time: f64) {
     BLOCK_HEIGHT.set(height as i64);
     BLOCK_PROCESSING_TIME.observe(processing_time);
Diff in /home/ubuntu/neo-rs/crates/core/src/metrics.rs:194:
 }
 
 /// Update transaction metrics
[31m-    /// Updates the internal state.
(B[m[32m+/// Updates the internal state.
(B[m pub fn update_tx_metrics(tx_type: &str, validation_time: f64) {
     TX_PROCESSED.with_label_values(&[tx_type]).inc();
     TX_VALIDATION_TIME.observe(validation_time);
Diff in /home/ubuntu/neo-rs/crates/core/src/metrics.rs:201:
 }
 
 /// Update network metrics
[31m-    /// Updates the internal state.
(B[m[32m+/// Updates the internal state.
(B[m pub fn update_network_metrics(msg_type: &str, is_received: bool, bytes: usize) {
     if is_received {
         MESSAGES_RECEIVED.with_label_values(&[msg_type]).inc();
Diff in /home/ubuntu/neo-rs/crates/core/src/metrics.rs:213:
 }
 
 /// Update consensus metrics
[31m-    /// Updates the internal state.
(B[m[32m+/// Updates the internal state.
(B[m pub fn update_consensus_metrics(view: u64, duration: f64, success: bool) {
     CONSENSUS_VIEW.set(view as i64);
     CONSENSUS_DURATION.observe(duration);
Diff in /home/ubuntu/neo-rs/crates/core/src/metrics.rs:222:
 }
 
 /// Update VM metrics
[31m-    /// Updates the internal state.
(B[m[32m+/// Updates the internal state.
(B[m pub fn update_vm_metrics(gas_consumed: u64, execution_time: f64, success: bool) {
     VM_GAS_CONSUMED.inc_by(gas_consumed as f64);
     VM_EXECUTION_TIME.observe(execution_time);
Diff in /home/ubuntu/neo-rs/crates/core/src/metrics.rs:231:
 }
 
 /// Update peer count
[31m-    /// Updates the internal state.
(B[m[32m+/// Updates the internal state.
(B[m pub fn update_peer_count(connected: i64, connecting: i64, disconnected: i64) {
     PEER_COUNT.with_label_values(&["connected"]).set(connected);
     PEER_COUNT
Diff in /home/ubuntu/neo-rs/crates/core/src/metrics.rs:243:
 }
 
 /// Update system metrics
[31m-    /// Updates the internal state.
(B[m[32m+/// Updates the internal state.
(B[m pub fn update_system_metrics() {
     use std::process;
     use sysinfo::{CpuExt, Pid, ProcessExt, System, SystemExt};
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:1:
 //! Migration Helpers for Safe Error Handling
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides utilities to help migrate existing code from
 //! unsafe unwrap() and panic!() patterns to the new safe error handling system.
 
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:6:
[31m-use crate::safe_error_handling::{SafeUnwrap, SafeExpect, SafeError};
(B[m[32m+use crate::safe_error_handling::{SafeError, SafeExpect, SafeUnwrap};
(B[m use std::fmt::Debug;
 
 /// Helper macro to migrate unwrap() calls with minimal code changes
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:10:
[31m-/// 
(B[m[32m+///
(B[m /// Usage:
 /// ```ignore
 /// // Before:
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:14:
 /// let value = some_result.unwrap();
[31m-/// 
(B[m[32m+///
(B[m /// // After:
 /// let value = migrate_unwrap!(some_result, "operation context")?;
 /// ```
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:24:
 }
 
 /// Helper macro to migrate expect() calls
[31m-/// 
(B[m[32m+///
(B[m /// Usage:
 /// ```ignore
 /// // Before:
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:31:
 /// let value = some_option.expect("error message");
[31m-/// 
(B[m[32m+///
(B[m /// // After:
 /// let value = migrate_expect!(some_option, "error message")?;
 /// ```
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:54:
             context: context.into(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get the inner value
     pub fn into_inner(self) -> T {
         self.inner
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:61:
     }
[31m-    
(B[m[32m+
(B[m     /// Get a reference to the inner value
     pub fn as_ref(&self) -> &T {
         &self.inner
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:66:
     }
[31m-    
(B[m[32m+
(B[m     /// Get a mutable reference to the inner value
     pub fn as_mut(&mut self) -> &mut T {
         &mut self.inner
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:76:
     pub fn safe_unwrap(self) -> Result<T, SafeError> {
         self.inner.safe_expect(&self.context)
     }
[31m-    
(B[m[32m+
(B[m     /// Safe version of unwrap_or
     pub fn safe_unwrap_or(self, default: T) -> T {
         self.inner.unwrap_or(default)
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:91:
     pub fn safe_unwrap(self) -> Result<T, SafeError> {
         self.inner.safe_unwrap(&self.context)
     }
[31m-    
(B[m[32m+
(B[m     /// Safe version of unwrap_or for Result
     pub fn safe_unwrap_or(self, default: T) -> T {
         self.inner.unwrap_or(default)
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:118:
 
 /// Helper function to safely handle vector access
 pub fn safe_vec_get<T: Clone>(vec: &[T], index: usize, context: &str) -> Result<T, SafeError> {
[31m-    vec.get(index)
(B[m[31m-        .cloned()
(B[m[31m-        .ok_or_else(|| SafeError::new(
(B[m[31m-            format!("Index {} out of bounds for vector of length {}", index, vec.len()),
(B[m[31m-            context
(B[m[31m-        ))
(B[m[32m+    vec.get(index).cloned().ok_or_else(|| {
(B[m[32m+        SafeError::new(
(B[m[32m+            format!(
(B[m[32m+                "Index {} out of bounds for vector of length {}",
(B[m[32m+                index,
(B[m[32m+                vec.len()
(B[m[32m+            ),
(B[m[32m+            context,
(B[m[32m+        )
(B[m[32m+    })
(B[m }
 
 /// Helper function to safely handle hashmap access
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:130:
 pub fn safe_map_get<'a, K, V>(
[31m-    map: &'a std::collections::HashMap<K, V>, 
(B[m[31m-    key: &K, 
(B[m[31m-    context: &str
(B[m[32m+    map: &'a std::collections::HashMap<K, V>,
(B[m[32m+    key: &K,
(B[m[32m+    context: &str,
(B[m ) -> Result<&'a V, SafeError>
 where
     K: Debug + Eq + std::hash::Hash,
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:137:
 {
[31m-    map.get(key).ok_or_else(|| SafeError::new(
(B[m[31m-        format!("Key {:?} not found in map", key),
(B[m[31m-        context
(B[m[31m-    ))
(B[m[32m+    map.get(key)
(B[m[32m+        .ok_or_else(|| SafeError::new(format!("Key {:?} not found in map", key), context))
(B[m }
 
 /// Batch error handler for collecting multiple potential errors
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:155:
             context: context.into(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Try an operation and collect any errors
     pub fn try_operation<T, F>(&mut self, operation: F) -> Option<T>
     where
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:169:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Check if any errors occurred
     pub fn has_errors(&self) -> bool {
         !self.errors.is_empty()
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:176:
     }
[31m-    
(B[m[32m+
(B[m     /// Get all collected errors
     pub fn errors(&self) -> &[SafeError] {
         &self.errors
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:181:
     }
[31m-    
(B[m[32m+
(B[m     /// Convert to a result, returning error if any operations failed
     pub fn to_result<T>(self, success_value: T) -> Result<T, SafeError> {
         if self.errors.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:186:
             Ok(success_value)
         } else {
[31m-            let error_messages: Vec<String> = self.errors
(B[m[31m-                .iter()
(B[m[31m-                .map(|e| format!("{}", e))
(B[m[31m-                .collect();
(B[m[32m+            let error_messages: Vec<String> =
(B[m[32m+                self.errors.iter().map(|e| format!("{}", e)).collect();
(B[m             Err(SafeError::new(
                 format!("{} errors occurred", self.errors.len()),
[31m-                format!("{}: {}", self.context, error_messages.join("; "))
(B[m[32m+                format!("{}: {}", self.context, error_messages.join("; ")),
(B[m             ))
         }
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:200:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_migration_wrapper_option() {
         let wrapper = MigrationWrapper::new(Some(42), "test context");
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:208:
         assert!(result.is_ok());
         assert_eq!(result.unwrap(), 42);
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_migration_wrapper_none() {
         let wrapper = MigrationWrapper::new(None::<i32>, "test context");
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:215:
         let result = wrapper.safe_unwrap();
         assert!(result.is_err());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_batch_error_handler() {
         let mut handler = BatchErrorHandler::new("batch operation");
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:222:
[31m-        
(B[m[32m+
(B[m         // Successful operation
         let result1 = handler.try_operation(|| Ok(42));
         assert_eq!(result1, Some(42));
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:226:
[31m-        
(B[m[32m+
(B[m         // Failed operation
[31m-        let result2: Option<i32> = handler.try_operation(|| Err(SafeError::new("test error", "test")));
(B[m[32m+        let result2: Option<i32> =
(B[m[32m+            handler.try_operation(|| Err(SafeError::new("test error", "test")));
(B[m         assert_eq!(result2, None);
[31m-        
(B[m[32m+
(B[m         assert!(handler.has_errors());
         assert_eq!(handler.errors().len(), 1);
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:234:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_vec_get() {
         let vec = vec![1, 2, 3];
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:238:
[31m-        
(B[m[32m+
(B[m         // Valid index
         let result = safe_vec_get(&vec, 1, "getting element");
         assert!(result.is_ok());
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:242:
         assert_eq!(result.unwrap(), 2);
[31m-        
(B[m[32m+
(B[m         // Invalid index
         let result = safe_vec_get(&vec, 10, "getting element");
         assert!(result.is_err());
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:247:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_legacy_error_conversion() {
         let error_string = "legacy error".to_string();
Diff in /home/ubuntu/neo-rs/crates/core/src/migration_helpers.rs:254:
         assert_eq!(safe_error.context, "migration context");
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/monitoring/alerting.rs:188:
 pub trait NotificationChannel: Send + Sync {
     /// Send alert notification
     async fn send(&self, alert: &Alert) -> Result<()>;
[31m-    
(B[m[32m+
(B[m     /// Get channel name
     fn name(&self) -> &str;
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/alerting.rs:282:
             .json(&payload)
             .send()
             .await
[31m-            .map_err(|e| crate::error_handling::NeoError::Network(
(B[m[31m-                crate::error_handling::NetworkError::ConnectionFailed(e.to_string())
(B[m[31m-            ))?;
(B[m[32m+            .map_err(|e| {
(B[m[32m+                crate::error_handling::NeoError::Network(
(B[m[32m+                    crate::error_handling::NetworkError::ConnectionFailed(e.to_string()),
(B[m[32m+                )
(B[m[32m+            })?;
(B[m 
         if !response.status().is_success() {
             return Err(crate::error_handling::NeoError::Network(
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/alerting.rs:291:
[31m-                crate::error_handling::NetworkError::ProtocolViolation(
(B[m[31m-                    format!("Webhook returned status: {}", response.status())
(B[m[31m-                )
(B[m[32m+                crate::error_handling::NetworkError::ProtocolViolation(format!(
(B[m[32m+                    "Webhook returned status: {}",
(B[m[32m+                    response.status()
(B[m[32m+                )),
(B[m             ));
         }
 
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/alerting.rs:349:
     /// Evaluate metric value against all rules
     pub async fn evaluate(&self, metric: &str, value: f64) -> Result<()> {
         let rules = self.rules.read().await;
[31m-        
(B[m[32m+
(B[m         for rule in rules.values() {
             if rule.threshold.metric == metric && rule.enabled {
                 self.evaluate_rule(rule, value).await?;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/alerting.rs:356:
             }
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/alerting.rs:502:
         let total = alerts.len();
         let active = alerts.values().filter(|a| a.is_active()).count();
         let acknowledged = alerts.values().filter(|a| a.acknowledged).count();
[31m-        
(B[m[32m+
(B[m         let mut by_level = HashMap::new();
         for alert in alerts.values().filter(|a| a.is_active()) {
             *by_level.entry(alert.level).or_insert(0) += 1;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/alerting.rs:569:
     #[tokio::test]
     async fn test_alert_manager() {
         let manager = AlertManager::new();
[31m-        
(B[m[32m+
(B[m         // Add log channel
         let log_channel = Arc::new(LogChannel::new("log".to_string()));
         manager.add_channel(log_channel).await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/alerting.rs:591:
             channels: vec!["log".to_string()],
             cooldown_seconds: 300,
         };
[31m-        
(B[m[32m+
(B[m         manager.add_rule(rule).await;
 
         // Test evaluation
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/alerting.rs:598:
         manager.evaluate("cpu_usage", 80.0).await.unwrap();
[31m-        
(B[m[32m+
(B[m         let active_alerts = manager.get_active_alerts().await;
         assert_eq!(active_alerts.len(), 1);
         assert_eq!(active_alerts[0].level, AlertLevel::Warning);
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/alerting.rs:603:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:23:
 pub trait MetricsExporter: Send + Sync {
     /// Export metrics in the target format
     fn export(&self, report: &StatusReport) -> Result<String>;
[31m-    
(B[m[32m+
(B[m     /// Get the content type for HTTP responses
     fn content_type(&self) -> &str;
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:34:
 impl MetricsExporter for PrometheusExporter {
     fn export(&self, report: &StatusReport) -> Result<String> {
         let mut output = String::new();
[31m-        
(B[m[32m+
(B[m         // Add raw Prometheus metrics
         output.push_str(&report.metrics);
[31m-        
(B[m[32m+
(B[m         // Add health metrics
         writeln!(
             &mut output,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:44:
             "# HELP neo_health_status Overall health status (0=unknown, 1=healthy, 2=degraded, 3=unhealthy)"
         )?;
         writeln!(&mut output, "# TYPE neo_health_status gauge")?;
[31m-        
(B[m[32m+
(B[m         let health_value = match report.health.status {
             crate::monitoring::HealthStatus::Unknown => 0,
             crate::monitoring::HealthStatus::Healthy => 1,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:52:
             crate::monitoring::HealthStatus::Unhealthy => 3,
         };
         writeln!(&mut output, "neo_health_status {}", health_value)?;
[31m-        
(B[m[32m+
(B[m         // Add component health metrics
         for component in &report.health.components {
             let component_value = match component.status {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:61:
                 crate::monitoring::HealthStatus::Degraded => 2,
                 crate::monitoring::HealthStatus::Unhealthy => 3,
             };
[31m-            
(B[m[32m+
(B[m             writeln!(
                 &mut output,
                 "neo_component_health{{component=\"{}\"}} {}",
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:68:
                 component.component, component_value
             )?;
         }
[31m-        
(B[m[32m+
(B[m         // Add performance metrics
         for (metric_name, stats) in &report.performance {
             writeln!(
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:77:
                 metric_name, metric_name
             )?;
             writeln!(&mut output, "# TYPE neo_perf_{} summary", metric_name)?;
[31m-            
(B[m[32m+
(B[m             writeln!(
                 &mut output,
                 "neo_perf_{}_current {}",
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:91:
                 "neo_perf_{}_count {}",
                 metric_name, stats.count
             )?;
[31m-            
(B[m[32m+
(B[m             // Add percentiles
             writeln!(
                 &mut output,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:109:
                 metric_name, stats.p99
             )?;
         }
[31m-        
(B[m[32m+
(B[m         Ok(output)
     }
[31m-    
(B[m[32m+
(B[m     fn content_type(&self) -> &str {
         "text/plain; version=0.0.4"
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:138:
         } else {
             serde_json::to_string(report)?
         };
[31m-        
(B[m[32m+
(B[m         Ok(json)
     }
[31m-    
(B[m[32m+
(B[m     fn content_type(&self) -> &str {
         "application/json"
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:183:
             },
             metrics: self.convert_to_otlp_metrics(report),
         };
[31m-        
(B[m[32m+
(B[m         Ok(serde_json::to_string(&otlp)?)
     }
[31m-    
(B[m[32m+
(B[m     fn content_type(&self) -> &str {
         "application/json"
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:195:
 impl OpenTelemetryExporter {
     fn convert_to_otlp_metrics(&self, report: &StatusReport) -> Vec<OtlpMetric> {
         let mut metrics = Vec::new();
[31m-        
(B[m[32m+
(B[m         // Convert health metrics
         metrics.push(OtlpMetric {
             name: "health.status".to_string(),
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:210:
                 },
             },
         });
[31m-        
(B[m[32m+
(B[m         // Convert performance metrics
         for (name, stats) in &report.performance {
             metrics.push(OtlpMetric {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:237:
                 },
             });
         }
[31m-        
(B[m[32m+
(B[m         metrics
     }
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:271:
 #[derive(Debug, Serialize, Deserialize)]
 #[serde(tag = "type")]
 enum MetricData {
[31m-    Gauge { value: f64 },
(B[m[31m-    Counter { value: f64 },
(B[m[32m+    Gauge {
(B[m[32m+        value: f64,
(B[m[32m+    },
(B[m[32m+    Counter {
(B[m[32m+        value: f64,
(B[m[32m+    },
(B[m     Summary {
         count: u64,
         sum: f64,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:292:
 impl MetricsExporter for CsvExporter {
     fn export(&self, report: &StatusReport) -> Result<String> {
         let mut output = String::new();
[31m-        
(B[m[32m+
(B[m         // Header
         writeln!(
             &mut output,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:299:
             "timestamp,component,status,metric,value,min,max,avg,p50,p90,p99"
         )?;
[31m-        
(B[m[32m+
(B[m         let timestamp = chrono::Utc::now().to_rfc3339();
[31m-        
(B[m[32m+
(B[m         // Health data
         for component in &report.health.components {
             writeln!(
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:309:
                 timestamp, component.component, component.status
             )?;
         }
[31m-        
(B[m[32m+
(B[m         // Performance data
         for (metric_name, stats) in &report.performance {
             writeln!(
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:326:
                 stats.p99
             )?;
         }
[31m-        
(B[m[32m+
(B[m         Ok(output)
     }
[31m-    
(B[m[32m+
(B[m     fn content_type(&self) -> &str {
         "text/csv"
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:349:
             _ => None,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Create OpenTelemetry exporter
     pub fn create_otlp(endpoint: String, service_name: String) -> Box<dyn MetricsExporter> {
         Box::new(OpenTelemetryExporter::new(endpoint, service_name))
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:361:
 mod tests {
     use super::*;
     use crate::monitoring::{HealthCheckResult, HealthStatus};
[31m-    use std::time::Duration;
(B[m     use chrono::Utc;
[31m-    
(B[m[32m+    use std::time::Duration;
(B[m[32m+
(B[m     fn create_test_report() -> StatusReport {
         let health = HealthReport {
             status: HealthStatus::Healthy,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:379:
             timestamp: Utc::now(),
             version: "1.0.0".to_string(),
         };
[31m-        
(B[m[32m+
(B[m         let mut performance = HashMap::new();
         performance.insert(
             "test_metric".to_string(),
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:395:
                 count: 100,
             },
         );
[31m-        
(B[m[32m+
(B[m         StatusReport {
             health,
             performance,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:402:
             metrics: "# Test metrics\n".to_string(),
         }
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_prometheus_exporter() {
         let exporter = PrometheusExporter;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:409:
         let report = create_test_report();
[31m-        
(B[m[32m+
(B[m         let output = exporter.export(&report).unwrap();
         assert!(output.contains("neo_health_status"));
         assert!(output.contains("neo_component_health"));
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:414:
         assert!(output.contains("neo_perf_test_metric"));
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_json_exporter() {
         let exporter = JsonExporter::new(false);
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:420:
         let report = create_test_report();
[31m-        
(B[m[32m+
(B[m         let output = exporter.export(&report).unwrap();
         assert!(output.contains("\"health\""));
         assert!(output.contains("\"performance\""));
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:425:
[31m-        
(B[m[32m+
(B[m         // Verify valid JSON
         let _: StatusReport = serde_json::from_str(&output).unwrap();
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:429:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_csv_exporter() {
         let exporter = CsvExporter;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:433:
         let report = create_test_report();
[31m-        
(B[m[32m+
(B[m         let output = exporter.export(&report).unwrap();
         assert!(output.contains("timestamp,component,status"));
         assert!(output.contains("test_metric"));
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:438:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_exporter_factory() {
         assert!(ExporterFactory::create("prometheus").is_some());
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/exporters.rs:445:
         assert!(ExporterFactory::create("unknown").is_none());
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:3:
 //! Provides comprehensive health checks for node components and dependencies.
 
 use crate::error_handling::Result;
[32m+use chrono::{DateTime, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::sync::Arc;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:9:
 use std::time::{Duration, Instant};
[31m-use chrono::{DateTime, Utc};
(B[m use tokio::sync::RwLock;
 
 /// Health status of a component
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:66:
 pub trait HealthCheck: Send + Sync {
     /// Perform health check
     async fn check_health(&self) -> HealthCheckResult;
[31m-    
(B[m[32m+
(B[m     /// Get component name
     fn component_name(&self) -> String;
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:99:
             cache_duration: Duration::from_secs(5),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Register a health check
     pub async fn register_check(&self, check: Arc<dyn HealthCheck>) {
         let mut checks = self.checks.write().await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:106:
         checks.push(check);
     }
[31m-    
(B[m[32m+
(B[m     /// Run all health checks and generate report
     pub async fn check_health(&self) -> Result<HealthReport> {
         // Check cache first
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:112:
         if let Some(cached) = self.get_cached_report().await {
             return Ok(cached);
         }
[31m-        
(B[m[32m+
(B[m         let checks = self.checks.read().await;
         let mut results = Vec::new();
[31m-        
(B[m[32m+
(B[m         // Run all checks in parallel
         let futures: Vec<_> = checks.iter().map(|check| check.check_health()).collect();
         let check_results = futures::future::join_all(futures).await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:122:
[31m-        
(B[m[32m+
(B[m         results.extend(check_results);
[31m-        
(B[m[32m+
(B[m         // Determine overall status
         let overall_status = self.calculate_overall_status(&results);
[31m-        
(B[m[32m+
(B[m         let report = HealthReport {
             status: overall_status,
             components: results,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:132:
             timestamp: Utc::now(),
             version: self.version.clone(),
         };
[31m-        
(B[m[32m+
(B[m         // Cache the report
         self.cache_report(report.clone()).await;
[31m-        
(B[m[32m+
(B[m         Ok(report)
     }
[31m-    
(B[m[32m+
(B[m     /// Get cached report if still valid
     async fn get_cached_report(&self) -> Option<HealthReport> {
         let cache = self.cache.read().await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:145:
         if let Some(ref report) = *cache {
[31m-            if Utc::now().signed_duration_since(report.timestamp) < chrono::Duration::from_std(self.cache_duration).unwrap() {
(B[m[32m+            if Utc::now().signed_duration_since(report.timestamp)
(B[m[32m+                < chrono::Duration::from_std(self.cache_duration).unwrap()
(B[m[32m+            {
(B[m                 return Some(report.clone());
             }
         }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:150:
         None
     }
[31m-    
(B[m[32m+
(B[m     /// Cache health report
     async fn cache_report(&self, report: HealthReport) {
         let mut cache = self.cache.write().await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:156:
         *cache = Some(report);
     }
[31m-    
(B[m[32m+
(B[m     /// Calculate overall status from component results
     fn calculate_overall_status(&self, results: &[HealthCheckResult]) -> HealthStatus {
         if results.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:162:
             return HealthStatus::Unknown;
         }
[31m-        
(B[m[32m+
(B[m         let has_unhealthy = results.iter().any(|r| r.status == HealthStatus::Unhealthy);
         let has_degraded = results.iter().any(|r| r.status == HealthStatus::Degraded);
[31m-        
(B[m[32m+
(B[m         if has_unhealthy {
             HealthStatus::Unhealthy
         } else if has_degraded {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:186:
     /// Creates a new instance.
     /// Creates a new instance.
     pub fn new(max_block_lag: u64) -> Self {
[31m-        Self { _max_block_lag: max_block_lag }
(B[m[32m+        Self {
(B[m[32m+            _max_block_lag: max_block_lag,
(B[m[32m+        }
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:195:
     async fn check_health(&self) -> HealthCheckResult {
         let start = Instant::now();
         let mut details = HashMap::new();
[31m-        
(B[m[32m+
(B[m         // Check block height
         let current_height = crate::metrics::BLOCK_HEIGHT.get() as u64;
[31m-        details.insert("block_height".to_string(), serde_json::json!(current_height));
(B[m[31m-        
(B[m[32m+        details.insert(
(B[m[32m+            "block_height".to_string(),
(B[m[32m+            serde_json::json!(current_height),
(B[m[32m+        );
(B[m[32m+
(B[m         // Check if we're syncing
         let status = if current_height == 0 {
             HealthStatus::Unhealthy
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:206:
         } else {
             HealthStatus::Healthy
         };
[31m-        
(B[m[32m+
(B[m         HealthCheckResult {
             component: self.component_name(),
             status,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:216:
             duration: start.elapsed(),
         }
     }
[31m-    
(B[m[32m+
(B[m     fn component_name(&self) -> String {
         "blockchain".to_string()
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:242:
     async fn check_health(&self) -> HealthCheckResult {
         let start = Instant::now();
         let mut details = HashMap::new();
[31m-        
(B[m[32m+
(B[m         // Check peer count
         let connected_peers = crate::metrics::PEER_COUNT
             .with_label_values(&["connected"])
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:249:
             .get() as usize;
[31m-        
(B[m[31m-        details.insert("connected_peers".to_string(), serde_json::json!(connected_peers));
(B[m[32m+
(B[m[32m+        details.insert(
(B[m[32m+            "connected_peers".to_string(),
(B[m[32m+            serde_json::json!(connected_peers),
(B[m[32m+        );
(B[m         details.insert("min_peers".to_string(), serde_json::json!(self.min_peers));
[31m-        
(B[m[32m+
(B[m         let status = if connected_peers == 0 {
             HealthStatus::Unhealthy
         } else if connected_peers < self.min_peers {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:258:
         } else {
             HealthStatus::Healthy
         };
[31m-        
(B[m[32m+
(B[m         HealthCheckResult {
             component: self.component_name(),
             status,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:265:
[31m-            message: Some(format!("Connected peers: {}/{}", connected_peers, self.min_peers)),
(B[m[32m+            message: Some(format!(
(B[m[32m+                "Connected peers: {}/{}",
(B[m[32m+                connected_peers, self.min_peers
(B[m[32m+            )),
(B[m             details,
             timestamp: Utc::now(),
             duration: start.elapsed(),
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:269:
         }
     }
[31m-    
(B[m[32m+
(B[m     fn component_name(&self) -> String {
         "network".to_string()
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:294:
     async fn check_health(&self) -> HealthCheckResult {
         let start = Instant::now();
         let mut details = HashMap::new();
[31m-        
(B[m[32m+
(B[m         // Check disk space
         let available_space = self.get_available_space();
[31m-        details.insert("available_space".to_string(), serde_json::json!(available_space));
(B[m[31m-        details.insert("min_free_space".to_string(), serde_json::json!(self.min_free_space));
(B[m[31m-        
(B[m[32m+        details.insert(
(B[m[32m+            "available_space".to_string(),
(B[m[32m+            serde_json::json!(available_space),
(B[m[32m+        );
(B[m[32m+        details.insert(
(B[m[32m+            "min_free_space".to_string(),
(B[m[32m+            serde_json::json!(self.min_free_space),
(B[m[32m+        );
(B[m[32m+
(B[m         let status = if available_space < self.min_free_space {
             HealthStatus::Unhealthy
         } else if available_space < self.min_free_space * 2 {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:307:
         } else {
             HealthStatus::Healthy
         };
[31m-        
(B[m[32m+
(B[m         HealthCheckResult {
             component: self.component_name(),
             status,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:317:
             duration: start.elapsed(),
         }
     }
[31m-    
(B[m[32m+
(B[m     fn component_name(&self) -> String {
         "storage".to_string()
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:327:
     fn get_available_space(&self) -> u64 {
         use std::fs;
         use std::path::Path;
[31m-        
(B[m[32m+
(B[m         let path = Path::new(".");
         if let Ok(_metadata) = fs::metadata(path) {
             // This is a simplified implementation
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:359:
     async fn check_health(&self) -> HealthCheckResult {
         let start = Instant::now();
         let mut details = HashMap::new();
[31m-        
(B[m[32m+
(B[m         // Check memory usage
         let memory_usage = crate::metrics::MEMORY_USAGE.get() as u64;
         details.insert("memory_usage".to_string(), serde_json::json!(memory_usage));
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:366:
         details.insert("max_memory".to_string(), serde_json::json!(self.max_memory));
[31m-        
(B[m[32m+
(B[m         let usage_percent = (memory_usage as f64 / self.max_memory as f64) * 100.0;
[31m-        details.insert("usage_percent".to_string(), serde_json::json!(usage_percent));
(B[m[31m-        
(B[m[32m+        details.insert(
(B[m[32m+            "usage_percent".to_string(),
(B[m[32m+            serde_json::json!(usage_percent),
(B[m[32m+        );
(B[m[32m+
(B[m         let status = if usage_percent > 90.0 {
             HealthStatus::Unhealthy
         } else if usage_percent > 75.0 {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:375:
         } else {
             HealthStatus::Healthy
         };
[31m-        
(B[m[32m+
(B[m         HealthCheckResult {
             component: self.component_name(),
             status,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:385:
             duration: start.elapsed(),
         }
     }
[31m-    
(B[m[32m+
(B[m     fn component_name(&self) -> String {
         "memory".to_string()
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:395:
 #[allow(dead_code)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_health_monitor() {
         let monitor = HealthMonitor::new("1.0.0".to_string());
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:402:
[31m-        
(B[m[32m+
(B[m         // Register checks
         let blockchain_check = Arc::new(BlockchainHealthCheck::new(10));
         let network_check = Arc::new(NetworkHealthCheck::new(3));
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:406:
[31m-        
(B[m[32m+
(B[m         monitor.register_check(blockchain_check).await;
         monitor.register_check(network_check).await;
[31m-        
(B[m[32m+
(B[m         // Run health check
         let report = monitor.check_health().await.unwrap();
[31m-        
(B[m[32m+
(B[m         assert_eq!(report.version, "1.0.0");
         assert_eq!(report.components.len(), 2);
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:416:
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_health_status_calculation() {
         let monitor = HealthMonitor::new("1.0.0".to_string());
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:420:
[31m-        
(B[m[32m+
(B[m         let results = vec![
             HealthCheckResult {
                 component: "test1".to_string(),
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:436:
                 duration: Duration::from_millis(10),
             },
         ];
[31m-        
(B[m[32m+
(B[m         let status = monitor.calculate_overall_status(&results);
         assert_eq!(status, HealthStatus::Degraded);
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/health.rs:443:
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:8:
 pub mod performance;
 
 pub use health::{
[31m-    HealthCheck, HealthCheckResult, HealthMonitor, HealthReport, HealthStatus,
(B[m[31m-    BlockchainHealthCheck, NetworkHealthCheck, StorageHealthCheck, MemoryHealthCheck,
(B[m[32m+    BlockchainHealthCheck, HealthCheck, HealthCheckResult, HealthMonitor, HealthReport,
(B[m[32m+    HealthStatus, MemoryHealthCheck, NetworkHealthCheck, StorageHealthCheck,
(B[m };
 
 pub use performance::{
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:16:
[31m-    PerformanceAlert, PerformanceMetric, PerformanceMonitor,
(B[m[31m-    PerformanceSample, PerformanceThreshold, Profiler, ThresholdType,
(B[m[31m-    MetricStatistics,
(B[m[32m+    MetricStatistics, PerformanceAlert, PerformanceMetric, PerformanceMonitor, PerformanceSample,
(B[m[32m+    PerformanceThreshold, Profiler, ThresholdType,
(B[m };
 
 pub use exporters::{
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:22:
[31m-    StatusReport, MetricsExporter, PrometheusExporter, JsonExporter,
(B[m[31m-    OpenTelemetryExporter, CsvExporter, ExporterFactory,
(B[m[32m+    CsvExporter, ExporterFactory, JsonExporter, MetricsExporter, OpenTelemetryExporter,
(B[m[32m+    PrometheusExporter, StatusReport,
(B[m };
 
 pub use alerting::{
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:27:
[31m-    Alert, AlertLevel, AlertManager, AlertRule, AlertStats, AlertThreshold,
(B[m[31m-    LogChannel, NotificationChannel, ThresholdOperator, WebhookChannel,
(B[m[32m+    Alert, AlertLevel, AlertManager, AlertRule, AlertStats, AlertThreshold, LogChannel,
(B[m[32m+    NotificationChannel, ThresholdOperator, WebhookChannel,
(B[m };
 
 use crate::error_handling::Result;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:35:
 pub async fn init_monitoring(version: String) -> Result<MonitoringSystem> {
     // Initialize metrics
     crate::metrics::init_metrics()?;
[31m-    
(B[m[32m+
(B[m     // Create health monitor
     let health_monitor = Arc::new(HealthMonitor::new(version));
[31m-    
(B[m[32m+
(B[m     // Register default health checks
     health_monitor
         .register_check(Arc::new(BlockchainHealthCheck::new(100)))
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:52:
     health_monitor
         .register_check(Arc::new(MemoryHealthCheck::new(4_000_000_000))) // 4GB
         .await;
[31m-    
(B[m[32m+
(B[m     // Create performance monitor
     let performance_monitor = Arc::new(PerformanceMonitor::new());
[31m-    
(B[m[32m+
(B[m     // Register default metrics
     performance_monitor
         .register_metric("block_processing".to_string(), 1000)
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:72:
     performance_monitor
         .register_metric("rpc_request".to_string(), 1000)
         .await;
[31m-    
(B[m[32m+
(B[m     // Set default thresholds
     performance_monitor
         .set_threshold(PerformanceThreshold {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:82:
             threshold_type: ThresholdType::Max,
         })
         .await;
[31m-    
(B[m[32m+
(B[m     performance_monitor
         .set_threshold(PerformanceThreshold {
             metric: "tx_validation".to_string(),
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:91:
             threshold_type: ThresholdType::Max,
         })
         .await;
[31m-    
(B[m[32m+
(B[m     Ok(MonitoringSystem {
         health_monitor,
         performance_monitor,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:110:
     /// Start background monitoring tasks
     pub fn start_background_tasks(&self) {
         let performance = self.performance_monitor.clone();
[31m-        
(B[m[32m+
(B[m         // Start system metrics collection
         tokio::spawn(async move {
             let mut interval = tokio::time::interval(std::time::Duration::from_secs(10));
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:117:
[31m-            
(B[m[32m+
(B[m             loop {
                 interval.tick().await;
[31m-                
(B[m[32m+
(B[m                 // Update system metrics
                 crate::metrics::update_system_metrics();
[31m-                
(B[m[32m+
(B[m                 // Record memory usage
                 let memory = crate::metrics::MEMORY_USAGE.get() as f64;
                 let _ = performance.record("memory_usage", memory).await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:127:
[31m-                
(B[m[32m+
(B[m                 // Record CPU usage
                 let cpu = crate::metrics::CPU_USAGE.get();
                 let _ = performance.record("cpu_usage", cpu).await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:131:
             }
         });
     }
[31m-    
(B[m[32m+
(B[m     /// Get comprehensive status report
     pub async fn get_status(&self) -> Result<StatusReport> {
         let health = self.health_monitor.check_health().await?;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:138:
         let performance = self.performance_monitor.get_all_stats().await;
         let metrics = crate::metrics::get_metrics();
[31m-        
(B[m[32m+
(B[m         Ok(StatusReport {
             health,
             performance,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:144:
             metrics,
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Export metrics in specified format
     pub async fn export(&self, format: &str) -> Result<String> {
         let report = self.get_status().await?;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:151:
[31m-        
(B[m[31m-        let exporter = ExporterFactory::create(format)
(B[m[31m-            .ok_or_else(|| crate::error_handling::NeoError::InvalidInput(
(B[m[31m-                format!("Unsupported export format: {}", format)
(B[m[31m-            ))?;
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let exporter = ExporterFactory::create(format).ok_or_else(|| {
(B[m[32m+            crate::error_handling::NeoError::InvalidInput(format!(
(B[m[32m+                "Unsupported export format: {}",
(B[m[32m+                format
(B[m[32m+            ))
(B[m[32m+        })?;
(B[m[32m+
(B[m         exporter.export(&report)
     }
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/mod.rs:160:
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:3:
 //! Provides detailed performance tracking and bottleneck detection.
 
 use crate::error_handling::Result;
[32m+use chrono::{DateTime, Utc};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::{HashMap, VecDeque};
 use std::sync::Arc;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:9:
 use std::time::{Duration, Instant};
[31m-use chrono::{DateTime, Utc};
(B[m use tokio::sync::RwLock;
 
 /// Performance sample for a specific metric
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:84:
             stats: MetricStatistics::default(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Add a sample to the metric
     pub fn add_sample(&mut self, value: f64, metadata: Option<HashMap<String, String>>) {
         let sample = PerformanceSample {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:92:
             value,
             metadata,
         };
[31m-        
(B[m[32m+
(B[m         // Add sample and maintain max size
         self.samples.push_back(sample);
         if self.samples.len() > self.max_samples {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:99:
             self.samples.pop_front();
         }
[31m-        
(B[m[32m+
(B[m         // Update statistics
         self.update_statistics();
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:105:
[31m-    
(B[m[32m+
(B[m     /// Update statistics based on current samples
     fn update_statistics(&mut self) {
         if self.samples.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:109:
             return;
         }
[31m-        
(B[m[32m+
(B[m         let values: Vec<f64> = self.samples.iter().map(|s| s.value).collect();
         let count = values.len();
[31m-        
(B[m[32m+
(B[m         self.stats.current = values.last().copied().unwrap_or(0.0);
         self.stats.min = values.iter().fold(f64::INFINITY, |a, &b| a.min(b));
         self.stats.max = values.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b));
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:118:
         self.stats.avg = values.iter().sum::<f64>() / count as f64;
         self.stats.count = count;
[31m-        
(B[m[32m+
(B[m         // Calculate standard deviation
         let variance = values
             .iter()
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:124:
             .map(|&v| (v - self.stats.avg).powi(2))
[31m-            .sum::<f64>() / count as f64;
(B[m[32m+            .sum::<f64>()
(B[m[32m+            / count as f64;
(B[m         self.stats.std_dev = variance.sqrt();
[31m-        
(B[m[32m+
(B[m         // Calculate percentiles
         let mut sorted = values.clone();
         sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:131:
[31m-        
(B[m[32m+
(B[m         self.stats.p50 = self.percentile(&sorted, 0.50);
         self.stats.p90 = self.percentile(&sorted, 0.90);
         self.stats.p99 = self.percentile(&sorted, 0.99);
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:135:
     }
[31m-    
(B[m[32m+
(B[m     /// Calculate percentile from sorted values
     fn percentile(&self, sorted: &[f64], p: f64) -> f64 {
         if sorted.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:140:
             return 0.0;
         }
[31m-        
(B[m[32m+
(B[m         let index = ((sorted.len() - 1) as f64 * p) as usize;
         sorted[index]
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:146:
[31m-    
(B[m[32m+
(B[m     /// Get current statistics
     pub fn get_stats(&self) -> &MetricStatistics {
         &self.stats
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:150:
     }
[31m-    
(B[m[32m+
(B[m     /// Get recent samples
     pub fn get_samples(&self, count: usize) -> Vec<PerformanceSample> {
[31m-        self.samples
(B[m[31m-            .iter()
(B[m[31m-            .rev()
(B[m[31m-            .take(count)
(B[m[31m-            .cloned()
(B[m[31m-            .collect()
(B[m[32m+        self.samples.iter().rev().take(count).cloned().collect()
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:228:
             alert_callbacks: Arc::new(RwLock::new(Vec::new())),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Register a new metric
     pub async fn register_metric(&self, name: String, max_samples: usize) {
         let mut metrics = self.metrics.write().await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:235:
         metrics.insert(name.clone(), PerformanceMetric::new(name, max_samples));
     }
[31m-    
(B[m[32m+
(B[m     /// Record a metric value
     pub async fn record(&self, metric: &str, value: f64) -> Result<()> {
         self.record_with_metadata(metric, value, None).await
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:241:
     }
[31m-    
(B[m[32m+
(B[m     /// Record a metric value with metadata
     pub async fn record_with_metadata(
         &self,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:248:
         metadata: Option<HashMap<String, String>>,
     ) -> Result<()> {
         let mut metrics = self.metrics.write().await;
[31m-        
(B[m[32m+
(B[m         if let Some(m) = metrics.get_mut(metric) {
             m.add_sample(value, metadata);
[31m-            
(B[m[32m+
(B[m             // Check thresholds
             let thresholds = self.thresholds.read().await;
             if let Some(threshold) = thresholds.get(metric) {
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:260:
                 }
             }
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Set threshold for a metric
     pub async fn set_threshold(&self, threshold: PerformanceThreshold) {
         let mut thresholds = self.thresholds.write().await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:270:
         thresholds.insert(threshold.metric.clone(), threshold);
     }
[31m-    
(B[m[32m+
(B[m     /// Register alert callback
     pub async fn register_alert_callback<F>(&self, callback: F)
     where
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:278:
         let mut callbacks = self.alert_callbacks.write().await;
         callbacks.push(Box::new(callback));
     }
[31m-    
(B[m[32m+
(B[m     /// Check if value violates threshold
     fn check_threshold(
         &self,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:306:
                 }
             }
         };
[31m-        
(B[m[32m+
(B[m         Some(PerformanceAlert {
             metric: metric.to_string(),
             level,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:319:
             timestamp: Utc::now(),
         })
     }
[31m-    
(B[m[32m+
(B[m     /// Trigger alert callbacks
     async fn trigger_alert(&self, alert: PerformanceAlert) {
         let callbacks = self.alert_callbacks.read().await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:327:
             callback(alert.clone());
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get statistics for a metric
     pub async fn get_stats(&self, metric: &str) -> Option<MetricStatistics> {
         let metrics = self.metrics.read().await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:334:
         metrics.get(metric).map(|m| m.get_stats().clone())
     }
[31m-    
(B[m[32m+
(B[m     /// Get all metrics statistics
     pub async fn get_all_stats(&self) -> HashMap<String, MetricStatistics> {
         let metrics = self.metrics.read().await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:342:
             .map(|(name, metric)| (name.clone(), metric.get_stats().clone()))
             .collect()
     }
[31m-    
(B[m[32m+
(B[m     /// Get recent samples for a metric
     pub async fn get_samples(&self, metric: &str, count: usize) -> Vec<PerformanceSample> {
         let metrics = self.metrics.read().await;
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:372:
             monitor: None,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Start profiling with monitor
     pub fn start_with_monitor(
         operation: impl Into<String>,
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:384:
             monitor: Some(monitor),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Stop profiling and get duration
     pub fn stop(self) -> Duration {
         self.start.elapsed()
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:391:
     }
[31m-    
(B[m[32m+
(B[m     /// Stop profiling and record to monitor
     pub async fn stop_and_record(self) {
         let duration = self.start.elapsed();
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:396:
[31m-        
(B[m[32m+
(B[m         if let Some(monitor) = self.monitor {
             let _ = monitor
                 .record(&self.operation, duration.as_secs_f64())
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:406:
 #[allow(dead_code)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_performance_metric() {
         let mut metric = PerformanceMetric::new("test".to_string(), 100);
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:413:
[31m-        
(B[m[32m+
(B[m         // Add samples
         for i in 0..10 {
             metric.add_sample(i as f64, None);
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:417:
         }
[31m-        
(B[m[32m+
(B[m         let stats = metric.get_stats();
         assert_eq!(stats.count, 10);
         assert_eq!(stats.min, 0.0);
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:422:
         assert_eq!(stats.max, 9.0);
         assert_eq!(stats.avg, 4.5);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_performance_monitor() {
         let monitor = PerformanceMonitor::new();
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:429:
[31m-        
(B[m[32m+
(B[m         // Register metric
[31m-        monitor.register_metric("test_metric".to_string(), 100).await;
(B[m[31m-        
(B[m[32m+        monitor
(B[m[32m+            .register_metric("test_metric".to_string(), 100)
(B[m[32m+            .await;
(B[m[32m+
(B[m         // Record values
         for i in 0..5 {
             monitor.record("test_metric", i as f64).await.unwrap();
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:436:
         }
[31m-        
(B[m[32m+
(B[m         // Get statistics
         let stats = monitor.get_stats("test_metric").await.unwrap();
         assert_eq!(stats.count, 5);
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:441:
         assert_eq!(stats.avg, 2.0);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_threshold_alerts() {
         let monitor = Arc::new(PerformanceMonitor::new());
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:447:
[31m-        
(B[m[32m+
(B[m         // Register metric
         monitor.register_metric("cpu".to_string(), 100).await;
[31m-        
(B[m[32m+
(B[m         // Set threshold
         let threshold = PerformanceThreshold {
             metric: "cpu".to_string(),
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:456:
             threshold_type: ThresholdType::Max,
         };
         monitor.set_threshold(threshold).await;
[31m-        
(B[m[32m+
(B[m         // Register alert callback
         let alert_triggered = Arc::new(RwLock::new(false));
         let alert_flag = alert_triggered.clone();
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:463:
[31m-        
(B[m[32m+
(B[m         monitor
             .register_alert_callback(move |_alert| {
                 let flag = alert_flag.clone();
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:470:
                 });
             })
             .await;
[31m-        
(B[m[32m+
(B[m         // Trigger alert
         monitor.record("cpu", 95.0).await.unwrap();
[31m-        
(B[m[32m+
(B[m         // Wait a bit for async callback
         tokio::time::sleep(Duration::from_millis(100)).await;
[31m-        
(B[m[32m+
(B[m         let triggered = alert_triggered.read().await;
         assert!(*triggered);
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/monitoring/performance.rs:483:
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:1:
 //! Safe Error Handling Module
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides safe alternatives to unwrap() and panic!() calls,
 //! improving the robustness and production-readiness of the Neo-RS codebase.
 
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:11:
 pub trait SafeUnwrap<T> {
     /// Safely unwrap a Result with context information
     fn safe_unwrap(self, context: &str) -> Result<T, SafeError>;
[31m-    
(B[m[32m+
(B[m     /// Unwrap with a default value on error
     fn unwrap_or_default_with_log(self, context: &str) -> T
     where
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:18:
         T: Default;
[31m-    
(B[m[32m+
(B[m     /// Convert error to SafeError with context
     fn with_context(self, context: impl Into<String>) -> Result<T, SafeError>;
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:25:
 pub trait SafeExpect<T> {
     /// Safely expect a value with context information
     fn safe_expect(self, context: &str) -> Result<T, SafeError>;
[31m-    
(B[m[32m+
(B[m     /// Convert None to an error with context
     fn ok_or_context(self, context: impl Into<String>) -> Result<T, SafeError>;
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:55:
             source: None,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Create SafeError from another error type
     #[track_caller]
     pub fn from_error<E: StdError>(error: E, context: impl Into<String>) -> Self {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:67:
             source: Some(format!("{:?}", error)),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Add additional context to an existing error
     pub fn add_context(mut self, additional: impl Into<String>) -> Self {
         self.context = format!("{} | {}", self.context, additional.into());
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:100:
     fn safe_unwrap(self, context: &str) -> Result<T, SafeError> {
         self.map_err(|e| SafeError::from_error(e, context))
     }
[31m-    
(B[m[32m+
(B[m     fn unwrap_or_default_with_log(self, context: &str) -> T
     where
         T: Default,
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:108:
         match self {
             Ok(val) => val,
             Err(e) => {
[31m-                log::error!("Using default value due to error: {} | Context: {}", e, context);
(B[m[32m+                log::error!(
(B[m[32m+                    "Using default value due to error: {} | Context: {}",
(B[m[32m+                    e,
(B[m[32m+                    context
(B[m[32m+                );
(B[m                 T::default()
             }
         }
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:115:
     }
[31m-    
(B[m[32m+
(B[m     #[track_caller]
     fn with_context(self, context: impl Into<String>) -> Result<T, SafeError> {
         self.map_err(|e| SafeError::from_error(e, context))
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:126:
     fn safe_expect(self, context: &str) -> Result<T, SafeError> {
         self.ok_or_else(|| SafeError::new("Expected value was None", context))
     }
[31m-    
(B[m[32m+
(B[m     #[track_caller]
     fn ok_or_context(self, context: impl Into<String>) -> Result<T, SafeError> {
         self.ok_or_else(|| SafeError::new("Value was None", context))
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:161:
             log::error!("Assertion failed: {}", $msg);
             return Err($crate::safe_error_handling::SafeError::new(
                 format!("Assertion failed: {}", $msg),
[31m-                "Runtime assertion failure"
(B[m[32m+                "Runtime assertion failure",
(B[m             ));
         }
     };
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:170:
 /// Helper function to convert multiple Results into a single Result
 pub fn collect_results<T, E>(results: Vec<Result<T, E>>) -> Result<Vec<T>, Vec<E>> {
     let (oks, errs): (Vec<_>, Vec<_>) = results.into_iter().partition(Result::is_ok);
[31m-    
(B[m[32m+
(B[m     let errs: Vec<E> = errs.into_iter().filter_map(Result::err).collect();
[31m-    
(B[m[32m+
(B[m     if errs.is_empty() {
         Ok(oks.into_iter().filter_map(Result::ok).collect())
     } else {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:188:
 impl ErrorChain {
     /// Create a new error chain
     pub fn new() -> Self {
[31m-        Self {
(B[m[31m-            errors: Vec::new(),
(B[m[31m-        }
(B[m[32m+        Self { errors: Vec::new() }
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Add an error to the chain
     pub fn add_error(&mut self, error: SafeError) {
         self.errors.push(error);
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:199:
     }
[31m-    
(B[m[32m+
(B[m     /// Check if there are any errors
     pub fn has_errors(&self) -> bool {
         !self.errors.is_empty()
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:204:
     }
[31m-    
(B[m[32m+
(B[m     /// Convert to Result
     pub fn to_result<T>(self) -> Result<T, SafeError> {
         if self.errors.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:209:
             panic!("ErrorChain::to_result called with no errors");
         }
[31m-        
(B[m[31m-        let combined_message = self.errors
(B[m[32m+
(B[m[32m+        let combined_message = self
(B[m[32m+            .errors
(B[m             .iter()
             .map(|e| e.message.clone())
             .collect::<Vec<_>>()
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:216:
             .join("; ");
[31m-            
(B[m[31m-        let combined_context = self.errors
(B[m[32m+
(B[m[32m+        let combined_context = self
(B[m[32m+            .errors
(B[m             .iter()
             .map(|e| e.context.clone())
             .collect::<Vec<_>>()
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:222:
             .join("; ");
[31m-            
(B[m[32m+
(B[m         Err(SafeError::new(combined_message, combined_context))
     }
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:234:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_unwrap_ok() {
         let result: Result<i32, std::io::Error> = Ok(42);
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:241:
         let value = result.safe_unwrap("test context").unwrap();
         assert_eq!(value, 42);
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_unwrap_err() {
         let result: Result<i32, std::io::Error> = Err(std::io::Error::new(
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:248:
             std::io::ErrorKind::NotFound,
[31m-            "file not found"
(B[m[32m+            "file not found",
(B[m         ));
         let err = result.safe_unwrap("loading configuration").unwrap_err();
         assert!(err.context.contains("loading configuration"));
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:253:
         assert!(err.message.contains("file not found"));
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_expect_some() {
         let option = Some(42);
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:259:
         let value = option.safe_expect("expected value").unwrap();
         assert_eq!(value, 42);
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_expect_none() {
         let option: Option<i32> = None;
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:266:
[31m-        let err = option.safe_expect("expected configuration value").unwrap_err();
(B[m[32m+        let err = option
(B[m[32m+            .safe_expect("expected configuration value")
(B[m[32m+            .unwrap_err();
(B[m         assert!(err.context.contains("expected configuration value"));
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_error_chain() {
         let mut chain = ErrorChain::new();
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:273:
         chain.add_error(SafeError::new("Error 1", "Context 1"));
         chain.add_error(SafeError::new("Error 2", "Context 2"));
[31m-        
(B[m[32m+
(B[m         assert!(chain.has_errors());
         let result: Result<(), SafeError> = chain.to_result();
         assert!(result.is_err());
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:279:
[31m-        
(B[m[32m+
(B[m         let err = result.unwrap_err();
         assert!(err.message.contains("Error 1"));
         assert!(err.message.contains("Error 2"));
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:283:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_unwrap_or_default_with_log() {
         let result: Result<Vec<i32>, std::io::Error> = Err(std::io::Error::new(
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:288:
             std::io::ErrorKind::NotFound,
[31m-            "not found"
(B[m[32m+            "not found",
(B[m         ));
         let value = result.unwrap_or_default_with_log("getting list");
         assert_eq!(value, Vec::<i32>::new());
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_error_handling.rs:293:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:1:
 //! Safe memory operations for core types
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides safe alternatives to unsafe memory operations
 //! like transmute and raw pointer manipulation.
 
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:10:
 
 impl SafeTransmute {
     /// Safely convert byte array reference with compile-time size checking
[31m-    /// 
(B[m[32m+    ///
(B[m     /// This is a safe alternative to unsafe transmute for fixed-size arrays.
     /// It uses compile-time guarantees instead of runtime checks.
     pub fn bytes_to_array<const N: usize>(bytes: &[u8; N]) -> &[u8; N] {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:17:
         // No unsafe needed - this is just a reference cast with compile-time size guarantee
         bytes
     }
[31m-    
(B[m[32m+
(B[m     /// Safely convert between types with identical representation
[31m-    /// 
(B[m[32m+    ///
(B[m     /// This uses the bytemuck crate for safe transmutation when available,
     /// or provides a safe copying alternative.
[31m-    pub fn safe_transmute_copy<T, U>(_src: &T) -> U 
(B[m[32m+    pub fn safe_transmute_copy<T, U>(_src: &T) -> U
(B[m     where
         T: Copy,
         U: Copy + Default,
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:29:
     {
         // Safe alternative: use bytemuck or zerocopy crate for safe transmutation
         // For now, we'll use a safe but potentially less efficient approach
[31m-        
(B[m[32m+
(B[m         // Create result with default value
         let dst = U::default();
[31m-        
(B[m[32m+
(B[m         // Use type-safe conversion if possible
         // This ensures compile-time safety for compatible types
         let src_size = std::mem::size_of::<T>();
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:39:
         let dst_size = std::mem::size_of::<U>();
[31m-        
(B[m[32m+
(B[m         if src_size == dst_size {
             // For types with same size, we can use safe byte-level copy
             // without needing unsafe code by leveraging the Copy trait
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:44:
[31m-            
(B[m[32m+
(B[m             // Alternative safe approach: use serde or bincode for serialization
             // This is completely safe but has runtime overhead
             // In production, consider using bytemuck crate for zero-cost safe transmutation
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:48:
[31m-            
(B[m[32m+
(B[m             // For now, return default value as a safe fallback
             // In production, implement proper type conversion traits
             dst
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:61:
 
 impl SafeBinaryOps {
     /// Safe memory copy with bounds checking
[31m-    /// 
(B[m[32m+    ///
(B[m     /// Alternative to unsafe ptr::copy_nonoverlapping
[31m-    pub fn safe_copy(
(B[m[31m-        src: &[u8],
(B[m[31m-        dst: &mut [u8],
(B[m[31m-        offset: usize,
(B[m[31m-        len: usize
(B[m[31m-    ) -> CoreResult<()> {
(B[m[32m+    pub fn safe_copy(src: &[u8], dst: &mut [u8], offset: usize, len: usize) -> CoreResult<()> {
(B[m         // Check source bounds
         if src.len() < len {
             return Err(CoreError::BufferOverflow {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:75:
                 requested: len,
[31m-                available: src.len()
(B[m[32m+                available: src.len(),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         // Check destination bounds
         if dst.len() < offset + len {
             return Err(CoreError::BufferOverflow {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:83:
                 requested: offset + len,
[31m-                available: dst.len()
(B[m[32m+                available: dst.len(),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         // Safe copy using slice operations
         dst[offset..offset + len].copy_from_slice(&src[..len]);
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:91:
     }
[31m-    
(B[m[32m+
(B[m     /// Safe optimized copy for small data
[31m-    /// 
(B[m[32m+    ///
(B[m     /// Uses safe slice operations with compiler optimizations
[31m-    pub fn safe_small_copy(
(B[m[31m-        src: &[u8],
(B[m[31m-        dst: &mut [u8],
(B[m[31m-        offset: usize
(B[m[31m-    ) -> CoreResult<()> {
(B[m[32m+    pub fn safe_small_copy(src: &[u8], dst: &mut [u8], offset: usize) -> CoreResult<()> {
(B[m         let len = src.len();
[31m-        
(B[m[32m+
(B[m         // Validate bounds
         if dst.len() < offset + len {
             return Err(CoreError::BufferOverflow {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:106:
                 requested: offset + len,
[31m-                available: dst.len()
(B[m[32m+                available: dst.len(),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         // For small copies (<=8 bytes), the compiler can optimize this
         // to be as fast as unsafe copy_nonoverlapping
         if len <= 8 {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:119:
             // For larger copies, use slice copy
             dst[offset..offset + len].copy_from_slice(src);
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:133:
         // This is already safe - no transmute needed
         hash_data
     }
[31m-    
(B[m[32m+
(B[m     /// Create a hash from bytes with validation
     pub fn bytes_to_hash<const N: usize>(bytes: &[u8]) -> CoreResult<[u8; N]> {
         if bytes.len() != N {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:140:
             return Err(CoreError::InvalidData {
[31m-                message: format!("Expected {} bytes, got {}", N, bytes.len())
(B[m[32m+                message: format!("Expected {} bytes, got {}", N, bytes.len()),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         let mut hash = [0u8; N];
         hash.copy_from_slice(bytes);
         Ok(hash)
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:157:
         // Direct reference - no unsafe needed
         data
     }
[31m-    
(B[m[32m+
(B[m     /// Convert to owned bytes
     pub fn to_bytes(data: &[u8; 32]) -> Vec<u8> {
         data.to_vec()
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:173:
         // Direct reference - no unsafe needed
         data
     }
[31m-    
(B[m[32m+
(B[m     /// Convert to owned bytes
     pub fn to_bytes(data: &[u8; 20]) -> Vec<u8> {
         data.to_vec()
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:183:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_binary_copy() {
         let src = vec![1, 2, 3, 4, 5];
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:190:
         let mut dst = vec![0; 10];
[31m-        
(B[m[32m+
(B[m         // Test successful copy
         let result = SafeBinaryOps::safe_copy(&src, &mut dst, 2, 3);
         assert!(result.is_ok());
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:195:
         assert_eq!(&dst[2..5], &[1, 2, 3]);
[31m-        
(B[m[32m+
(B[m         // Test bounds checking
         let result = SafeBinaryOps::safe_copy(&src, &mut dst, 8, 5);
         assert!(result.is_err());
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:200:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_small_copy() {
         let src = vec![1, 2, 3, 4];
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:205:
         let mut dst = vec![0; 10];
[31m-        
(B[m[32m+
(B[m         let result = SafeBinaryOps::safe_small_copy(&src, &mut dst, 3);
         assert!(result.is_ok());
         assert_eq!(&dst[3..7], &[1, 2, 3, 4]);
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:210:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_hash_operations() {
         let bytes = vec![1; 32];
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:215:
         let result = SafeHashOps::bytes_to_hash::<32>(&bytes);
         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         let hash = result.unwrap();
         let bytes_ref = SafeHashOps::hash_as_bytes(&hash);
         assert_eq!(bytes_ref, &hash);
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:221:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_uint256() {
         let data = [42u8; 32];
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:226:
         let bytes_ref = SafeUInt256::as_bytes(&data);
         assert_eq!(bytes_ref, &data);
[31m-        
(B[m[32m+
(B[m         let bytes_vec = SafeUInt256::to_bytes(&data);
         assert_eq!(bytes_vec.len(), 32);
         assert_eq!(bytes_vec[0], 42);
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:232:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_uint160() {
         let data = [42u8; 20];
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:237:
         let bytes_ref = SafeUInt160::as_bytes(&data);
         assert_eq!(bytes_ref, &data);
[31m-        
(B[m[32m+
(B[m         let bytes_vec = SafeUInt160::to_bytes(&data);
         assert_eq!(bytes_vec.len(), 20);
         assert_eq!(bytes_vec[0], 42);
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_memory.rs:243:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:1:
 //! Safe Operations Module
[31m-//! 
(B[m[32m+//!
(B[m //! Provides safe alternatives to common operations that might panic,
 //! replacing unwrap(), expect(), and panic! patterns with recoverable errors.
 
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:12:
 pub trait SafeIndex<T> {
     /// Get element at index, returning None if out of bounds
     fn safe_get(&self, index: usize) -> Option<&T>;
[31m-    
(B[m[32m+
(B[m     /// Get mutable element at index, returning None if out of bounds
     fn safe_get_mut(&mut self, index: usize) -> Option<&mut T>;
[31m-    
(B[m[32m+
(B[m     /// Get element or default if out of bounds
     fn get_or_default(&self, index: usize) -> T
     where
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:27:
         if index < self.len() {
             Some(&self[index])
         } else {
[31m-            tracing::warn!("Index {} out of bounds for vector of length {}", index, self.len());
(B[m[32m+            tracing::warn!(
(B[m[32m+                "Index {} out of bounds for vector of length {}",
(B[m[32m+                index,
(B[m[32m+                self.len()
(B[m[32m+            );
(B[m             None
         }
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:34:
[31m-    
(B[m[32m+
(B[m     fn safe_get_mut(&mut self, index: usize) -> Option<&mut T> {
         let len = self.len();
         if index < len {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:41:
             None
         }
     }
[31m-    
(B[m[32m+
(B[m     fn get_or_default(&self, index: usize) -> T
     where
         T: Default + Clone,
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:55:
 pub trait SafeMap<K, V> {
     /// Get value with proper error handling
     fn safe_get(&self, key: &K) -> Option<&V>;
[31m-    
(B[m[32m+
(B[m     /// Insert with overflow protection
     fn safe_insert(&mut self, key: K, value: V) -> Result<Option<V>>;
[31m-    
(B[m[32m+
(B[m     /// Remove with existence check
     fn safe_remove(&mut self, key: &K) -> Option<V>;
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:71:
         }
         result
     }
[31m-    
(B[m[32m+
(B[m     fn safe_insert(&mut self, key: K, value: V) -> Result<Option<V>> {
         // Check for capacity issues
         if self.len() >= self.capacity() && self.capacity() > usize::MAX / 2 {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:78:
[31m-            return Err(NeoError::Internal("HashMap capacity overflow risk".to_string()));
(B[m[32m+            return Err(NeoError::Internal(
(B[m[32m+                "HashMap capacity overflow risk".to_string(),
(B[m[32m+            ));
(B[m         }
         Ok(self.insert(key, value))
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:82:
[31m-    
(B[m[32m+
(B[m     fn safe_remove(&mut self, key: &K) -> Option<V> {
         let result = self.remove(key);
         if result.is_none() {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:94:
 pub trait SafeArithmetic: Sized {
     /// Safe addition with overflow check
     fn safe_add(self, rhs: Self) -> Result<Self>;
[31m-    
(B[m[32m+
(B[m     /// Safe subtraction with underflow check
     fn safe_sub(self, rhs: Self) -> Result<Self>;
[31m-    
(B[m[32m+
(B[m     /// Safe multiplication with overflow check
     fn safe_mul(self, rhs: Self) -> Result<Self>;
[31m-    
(B[m[32m+
(B[m     /// Safe division with zero check
     fn safe_div(self, rhs: Self) -> Result<Self>;
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:113:
                     self.checked_add(rhs)
                         .ok_or_else(|| NeoError::Internal(format!("Arithmetic overflow: {} + {}", self, rhs)))
                 }
[31m-                
(B[m[32m+
(B[m                 fn safe_sub(self, rhs: Self) -> Result<Self> {
                     self.checked_sub(rhs)
                         .ok_or_else(|| NeoError::Internal(format!("Arithmetic underflow: {} - {}", self, rhs)))
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:120:
                 }
[31m-                
(B[m[32m+
(B[m                 fn safe_mul(self, rhs: Self) -> Result<Self> {
                     self.checked_mul(rhs)
                         .ok_or_else(|| NeoError::Internal(format!("Arithmetic overflow: {} * {}", self, rhs)))
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:125:
                 }
[31m-                
(B[m[32m+
(B[m                 fn safe_div(self, rhs: Self) -> Result<Self> {
                     if rhs == 0 {
                         Err(NeoError::Internal("Division by zero".to_string()))
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:153:
             inner: Arc::new(Mutex::new(value)),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Lock the mutex, recovering from poisoned state if necessary
     pub fn safe_lock(&self) -> Result<std::sync::MutexGuard<'_, T>> {
         match self.inner.lock() {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:164:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Try to lock without blocking
     pub fn safe_try_lock(&self) -> Result<Option<std::sync::MutexGuard<'_, T>>> {
         match self.inner.try_lock() {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:200:
             inner: Arc::new(RwLock::new(value)),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Read lock with poison recovery
     pub fn safe_read(&self) -> Result<std::sync::RwLockReadGuard<'_, T>> {
         match self.inner.read() {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:211:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Write lock with poison recovery
     pub fn safe_write(&self) -> Result<std::sync::RwLockWriteGuard<'_, T>> {
         match self.inner.write() {
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:237:
 pub trait SafeParse {
     /// Output type for the operation.
     type Output;
[31m-    
(B[m[32m+
(B[m     /// Parse with proper error handling
     fn safe_parse(&self) -> Result<Self::Output>;
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:244:
 
 impl SafeParse for str {
     type Output = i64;
[31m-    
(B[m[32m+
(B[m     fn safe_parse(&self) -> Result<Self::Output> {
         self.parse()
             .map_err(|e| NeoError::InvalidInput(format!("Failed to parse '{}': {}", self, e)))
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:284:
     use std::fs;
     use std::io::Read;
     use std::path::Path;
[31m-    
(B[m[32m+
(B[m     /// Safe file reading with size limits
     pub fn safe_read_file<P: AsRef<Path>>(path: P, max_size: usize) -> Result<Vec<u8>> {
         let path = path.as_ref();
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:291:
[31m-        
(B[m[32m+
(B[m         // Check file exists
         if !path.exists() {
             return Err(NeoError::NotFound(format!("File not found: {:?}", path)));
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:295:
         }
[31m-        
(B[m[32m+
(B[m         // Check file size
         let metadata = fs::metadata(path)
             .map_err(|e| NeoError::Internal(format!("Failed to read metadata: {}", e)))?;
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:300:
[31m-        
(B[m[32m+
(B[m         if metadata.len() > max_size as u64 {
             return Err(NeoError::InvalidInput(format!(
                 "File too large: {} bytes (max: {} bytes)",
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:305:
                 max_size
             )));
         }
[31m-        
(B[m[32m+
(B[m         // Read file
         let mut file = fs::File::open(path)
             .map_err(|e| NeoError::Internal(format!("Failed to open file: {}", e)))?;
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:312:
[31m-        
(B[m[32m+
(B[m         let mut buffer = Vec::with_capacity(metadata.len() as usize);
         file.read_to_end(&mut buffer)
             .map_err(|e| NeoError::Internal(format!("Failed to read file: {}", e)))?;
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:316:
[31m-        
(B[m[32m+
(B[m         Ok(buffer)
     }
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:322:
 #[allow(dead_code)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_index() {
         let vec = vec![1, 2, 3];
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:330:
         assert_eq!(vec.safe_get(10), None);
         assert_eq!(vec.get_or_default(10), 0);
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_arithmetic() {
         assert!(255u8.safe_add(1).is_err());
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:338:
         assert!(0u32.safe_sub(1).is_err());
         assert!(10u32.safe_div(0).is_err());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_mutex() {
         let mutex = SafeMutex::new(42);
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:345:
         let guard = mutex.safe_lock().unwrap();
         assert_eq!(*guard, 42);
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_parse() {
         assert_eq!("42".safe_parse().unwrap(), 42i64);
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:352:
         assert!("not_a_number".safe_parse().is_err());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_convert() {
         use SafeConvert;
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:358:
[31m-        
(B[m[32m+
(B[m         let large: usize = 1_000_000_000_000;
         let result: Result<u32> = large.safe_into();
         assert!(result.is_err());
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:362:
[31m-        
(B[m[32m+
(B[m         let small: usize = 42;
         let result: Result<u32> = small.safe_into();
         assert_eq!(result.unwrap(), 42u32);
Diff in /home/ubuntu/neo-rs/crates/core/src/safe_operations.rs:366:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:3:
 //! This module provides comprehensive monitoring for all blockchain components
 //! including performance metrics, error tracking, and health monitoring.
 
[31m-use std::sync::{Arc, RwLock};
(B[m[32m+use serde::{Deserialize, Serialize};
(B[m[32m+use std::collections::HashMap;
(B[m use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
[32m+use std::sync::{Arc, RwLock};
(B[m use std::time::Duration;
[31m-use std::collections::HashMap;
(B[m[31m-use serde::{Serialize, Deserialize};
(B[m 
 /// System-wide metrics collector
 /// Represents a data structure.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:48:
             performance: PerformanceTracker::new(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get a snapshot of all metrics
     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:69:
             performance: self.performance.snapshot(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Reset all metrics
     /// Resets the internal state.
     /// Resets the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:112:
             mempool_size: AtomicUsize::new(0),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:119:
     pub fn record_transaction(&self, size: u64, verification_time: Duration, success: bool) {
         self.total_count.fetch_add(1, Ordering::Relaxed);
         self.total_size_bytes.fetch_add(size, Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         if success {
             self.verified_count.fetch_add(1, Ordering::Relaxed);
         } else {
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:126:
             self.failed_count.fetch_add(1, Ordering::Relaxed);
         }
[31m-        
(B[m[32m+
(B[m         // Update average verification time
         let new_time = verification_time.as_micros() as u64;
         let current_avg = self.average_verification_time_us.load(Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:132:
         let count = self.total_count.load(Ordering::Relaxed);
         let new_avg = ((current_avg * (count - 1)) + new_time) / count;
[31m-        self.average_verification_time_us.store(new_avg, Ordering::Relaxed);
(B[m[32m+        self.average_verification_time_us
(B[m[32m+            .store(new_avg, Ordering::Relaxed);
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Updates the internal state with new data.
     /// Updates the internal state.
     /// Updates the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:140:
     pub fn update_mempool_size(&self, size: usize) {
         self.mempool_size.store(size, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:154:
             mempool_size: self.mempool_size.load(Ordering::Relaxed),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Resets the internal state.
     /// Resets the internal state.
     /// Resets the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:163:
         self.verified_count.store(0, Ordering::Relaxed);
         self.failed_count.store(0, Ordering::Relaxed);
         self.total_size_bytes.store(0, Ordering::Relaxed);
[31m-        self.average_verification_time_us.store(0, Ordering::Relaxed);
(B[m[32m+        self.average_verification_time_us
(B[m[32m+            .store(0, Ordering::Relaxed);
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:193:
             last_block_time: RwLock::new(None),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:200:
     pub fn record_block(&self, height: u64, size: u64, tx_count: u64) {
         self.total_count.fetch_add(1, Ordering::Relaxed);
         self.current_height.store(height, Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         // Calculate block time
         let now = std::time::Instant::now();
         if let Ok(mut last_time) = self.last_block_time.write() {
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:207:
             if let Some(last) = *last_time {
                 let block_time_ms = now.duration_since(last).as_millis() as u64;
[31m-                
(B[m[32m+
(B[m                 // Update average block time
                 let count = self.total_count.load(Ordering::Relaxed);
                 let current_avg = self.average_block_time_ms.load(Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:215:
             }
             *last_time = Some(now);
         }
[31m-        
(B[m[32m+
(B[m         // Update averages
         let count = self.total_count.load(Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         let current_size_avg = self.average_block_size_bytes.load(Ordering::Relaxed);
         let new_size_avg = ((current_size_avg * (count - 1)) + size) / count;
[31m-        self.average_block_size_bytes.store(new_size_avg, Ordering::Relaxed);
(B[m[31m-        
(B[m[32m+        self.average_block_size_bytes
(B[m[32m+            .store(new_size_avg, Ordering::Relaxed);
(B[m[32m+
(B[m         let current_tx_avg = self.average_tx_per_block.load(Ordering::Relaxed);
         let new_tx_avg = ((current_tx_avg * (count - 1)) + tx_count) / count;
[31m-        self.average_tx_per_block.store(new_tx_avg, Ordering::Relaxed);
(B[m[32m+        self.average_tx_per_block
(B[m[32m+            .store(new_tx_avg, Ordering::Relaxed);
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:240:
             average_tx_per_block: self.average_tx_per_block.load(Ordering::Relaxed),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Resets the internal state.
     /// Resets the internal state.
     /// Resets the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:283:
             average_latency_ms: AtomicU64::new(0),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Updates the internal state with new data.
     /// Updates the internal state.
     /// Updates the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:290:
     pub fn update_peer_count(&self, count: usize) {
         self.peer_count.store(count, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:298:
         self.messages_sent.fetch_add(1, Ordering::Relaxed);
         self.bytes_sent.fetch_add(size, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:306:
         self.messages_received.fetch_add(1, Ordering::Relaxed);
         self.bytes_received.fetch_add(size, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:313:
     pub fn record_connection_failure(&self) {
         self.connection_failures.fetch_add(1, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Updates the internal state with new data.
     /// Updates the internal state.
     /// Updates the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:320:
     pub fn update_average_latency(&self, latency_ms: u64) {
[31m-        let count = self.messages_sent.load(Ordering::Relaxed) + 
(B[m[31m-                   self.messages_received.load(Ordering::Relaxed);
(B[m[32m+        let count = self.messages_sent.load(Ordering::Relaxed)
(B[m[32m+            + self.messages_received.load(Ordering::Relaxed);
(B[m         if count > 0 {
             let current_avg = self.average_latency_ms.load(Ordering::Relaxed);
             let new_avg = ((current_avg * (count - 1)) + latency_ms) / count;
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:326:
             self.average_latency_ms.store(new_avg, Ordering::Relaxed);
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:341:
             average_latency_ms: self.average_latency_ms.load(Ordering::Relaxed),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Resets the internal state.
     /// Resets the internal state.
     /// Resets the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:381:
             opcodes_executed: AtomicU64::new(0),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:389:
         self.executions.fetch_add(1, Ordering::Relaxed);
         self.total_gas_consumed.fetch_add(gas, Ordering::Relaxed);
         self.opcodes_executed.fetch_add(opcodes, Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         if success {
             self.successful_executions.fetch_add(1, Ordering::Relaxed);
         } else {
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:396:
             self.failed_executions.fetch_add(1, Ordering::Relaxed);
         }
[31m-        
(B[m[32m+
(B[m         // Update average execution time
         let count = self.executions.load(Ordering::Relaxed);
         let current_avg = self.average_execution_time_us.load(Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:402:
         let new_time = time.as_micros() as u64;
         let new_avg = ((current_avg * (count - 1)) + new_time) / count;
[31m-        self.average_execution_time_us.store(new_avg, Ordering::Relaxed);
(B[m[32m+        self.average_execution_time_us
(B[m[32m+            .store(new_avg, Ordering::Relaxed);
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:417:
             opcodes_executed: self.opcodes_executed.load(Ordering::Relaxed),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Resets the internal state.
     /// Resets the internal state.
     /// Resets the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:457:
             timeouts: AtomicU64::new(0),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:464:
     pub fn record_view_change(&self) {
         self.view_changes.fetch_add(1, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:471:
     pub fn record_block_proposal(&self, accepted: bool, consensus_time: Duration) {
         self.blocks_proposed.fetch_add(1, Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         if accepted {
             self.blocks_accepted.fetch_add(1, Ordering::Relaxed);
         } else {
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:477:
             self.blocks_rejected.fetch_add(1, Ordering::Relaxed);
         }
[31m-        
(B[m[32m+
(B[m         // Update average consensus time
         let count = self.blocks_proposed.load(Ordering::Relaxed);
         let current_avg = self.average_consensus_time_ms.load(Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:483:
         let new_time = consensus_time.as_millis() as u64;
         let new_avg = ((current_avg * (count - 1)) + new_time) / count;
[31m-        self.average_consensus_time_ms.store(new_avg, Ordering::Relaxed);
(B[m[32m+        self.average_consensus_time_ms
(B[m[32m+            .store(new_avg, Ordering::Relaxed);
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:491:
     pub fn record_timeout(&self) {
         self.timeouts.fetch_add(1, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:505:
             timeouts: self.timeouts.load(Ordering::Relaxed),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Resets the internal state.
     /// Resets the internal state.
     /// Resets the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:549:
             average_write_time_us: AtomicU64::new(0),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:556:
     pub fn record_read(&self, time: Duration, cache_hit: bool) {
         self.reads.fetch_add(1, Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         if cache_hit {
             self.cache_hits.fetch_add(1, Ordering::Relaxed);
         } else {
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:562:
             self.cache_misses.fetch_add(1, Ordering::Relaxed);
         }
[31m-        
(B[m[32m+
(B[m         // Update average read time
         let count = self.reads.load(Ordering::Relaxed);
         let current_avg = self.average_read_time_us.load(Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:569:
         let new_avg = ((current_avg * (count - 1)) + new_time) / count;
         self.average_read_time_us.store(new_avg, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:576:
     pub fn record_write(&self, time: Duration) {
         self.writes.fetch_add(1, Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         // Update average write time
         let count = self.writes.load(Ordering::Relaxed);
         let current_avg = self.average_write_time_us.load(Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:583:
         let new_avg = ((current_avg * (count - 1)) + new_time) / count;
         self.average_write_time_us.store(new_avg, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:590:
     pub fn record_delete(&self) {
         self.deletes.fetch_add(1, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Updates the internal state with new data.
     /// Updates the internal state.
     /// Updates the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:597:
     pub fn update_disk_usage(&self, bytes: u64) {
         self.disk_usage_bytes.store(bytes, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:613:
             average_write_time_us: self.average_write_time_us.load(Ordering::Relaxed),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Resets the internal state.
     /// Resets the internal state.
     /// Resets the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:650:
             warnings: AtomicU64::new(0),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:657:
     pub fn record_error(&self, category: String, is_critical: bool) {
         self.total_errors.fetch_add(1, Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         if is_critical {
             self.critical_errors.fetch_add(1, Ordering::Relaxed);
         } else {
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:663:
             self.warnings.fetch_add(1, Ordering::Relaxed);
         }
[31m-        
(B[m[32m+
(B[m         if let Ok(mut guard) = self.errors_by_category.write() {
             *guard.entry(category).or_insert(0) += 1;
         }
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:669:
     }
[31m-    
(B[m[32m+
(B[m     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:674:
     pub fn snapshot(&self) -> ErrorTrackerSnapshot {
         ErrorTrackerSnapshot {
[31m-            errors_by_category: self.errors_by_category.read().ok().map(|g| g.clone()).unwrap_or_default(),
(B[m[32m+            errors_by_category: self
(B[m[32m+                .errors_by_category
(B[m[32m+                .read()
(B[m[32m+                .ok()
(B[m[32m+                .map(|g| g.clone())
(B[m[32m+                .unwrap_or_default(),
(B[m             total_errors: self.total_errors.load(Ordering::Relaxed),
             critical_errors: self.critical_errors.load(Ordering::Relaxed),
             warnings: self.warnings.load(Ordering::Relaxed),
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:680:
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Resets the internal state.
     /// Resets the internal state.
     /// Resets the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:717:
             gc_pause_time_ms: AtomicU64::new(0),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Updates the internal state with new data.
     /// Updates the internal state.
     /// Updates the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:724:
     pub fn update_cpu_usage(&self, percent: u64) {
[31m-        self.cpu_usage_percent.store(percent.min(100), Ordering::Relaxed);
(B[m[32m+        self.cpu_usage_percent
(B[m[32m+            .store(percent.min(100), Ordering::Relaxed);
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Updates the internal state with new data.
     /// Updates the internal state.
     /// Updates the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:731:
     pub fn update_memory_usage(&self, bytes: u64) {
         self.memory_usage_bytes.store(bytes, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Updates the internal state with new data.
     /// Updates the internal state.
     /// Updates the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:738:
     pub fn update_thread_count(&self, count: usize) {
         self.thread_count.store(count, Ordering::Relaxed);
     }
[31m-    
(B[m[32m+
(B[m     /// Records an event for metrics tracking.
     /// Records an event or metric.
     /// Records an event or metric.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:746:
         self.gc_collections.fetch_add(1, Ordering::Relaxed);
         let pause_ms = pause_time.as_millis() as u64;
         let current = self.gc_pause_time_ms.load(Ordering::Relaxed);
[31m-        self.gc_pause_time_ms.store(current + pause_ms, Ordering::Relaxed);
(B[m[32m+        self.gc_pause_time_ms
(B[m[32m+            .store(current + pause_ms, Ordering::Relaxed);
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
     /// Returns a snapshot of the current state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:761:
             gc_pause_time_ms: self.gc_pause_time_ms.load(Ordering::Relaxed),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Resets the internal state.
     /// Resets the internal state.
     /// Resets the internal state.
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:897:
 }
 
 /// Convenience functions for monitoring
[31m-    /// Records an event for metrics tracking.
(B[m[31m-    /// Records an event or metric.
(B[m[31m-    /// Records an event or metric.
(B[m[32m+/// Records an event for metrics tracking.
(B[m[32m+/// Records an event or metric.
(B[m[32m+/// Records an event or metric.
(B[m pub fn record_transaction(size: u64, verification_time: Duration, success: bool) {
[31m-    SYSTEM_MONITOR.transactions.record_transaction(size, verification_time, success);
(B[m[32m+    SYSTEM_MONITOR
(B[m[32m+        .transactions
(B[m[32m+        .record_transaction(size, verification_time, success);
(B[m }
 
[31m-    /// Records an event for metrics tracking.
(B[m[31m-    /// Records an event or metric.
(B[m[31m-    /// Records an event or metric.
(B[m[32m+/// Records an event for metrics tracking.
(B[m[32m+/// Records an event or metric.
(B[m[32m+/// Records an event or metric.
(B[m pub fn record_block(height: u64, size: u64, tx_count: u64) {
     SYSTEM_MONITOR.blocks.record_block(height, size, tx_count);
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:913:
 
[31m-    /// Records an event for metrics tracking.
(B[m[31m-    /// Records an event or metric.
(B[m[31m-    /// Records an event or metric.
(B[m[32m+/// Records an event for metrics tracking.
(B[m[32m+/// Records an event or metric.
(B[m[32m+/// Records an event or metric.
(B[m pub fn record_vm_execution(gas: u64, time: Duration, opcodes: u64, success: bool) {
[31m-    SYSTEM_MONITOR.vm.record_execution(gas, time, opcodes, success);
(B[m[32m+    SYSTEM_MONITOR
(B[m[32m+        .vm
(B[m[32m+        .record_execution(gas, time, opcodes, success);
(B[m }
 
[31m-    /// Records an event for metrics tracking.
(B[m[31m-    /// Records an event or metric.
(B[m[31m-    /// Records an event or metric.
(B[m[32m+/// Records an event for metrics tracking.
(B[m[32m+/// Records an event or metric.
(B[m[32m+/// Records an event or metric.
(B[m pub fn record_error(category: impl Into<String>, is_critical: bool) {
[31m-    SYSTEM_MONITOR.errors.record_error(category.into(), is_critical);
(B[m[32m+    SYSTEM_MONITOR
(B[m[32m+        .errors
(B[m[32m+        .record_error(category.into(), is_critical);
(B[m }
 
[31m-    /// Gets a value from the internal state.
(B[m[31m-    /// Gets a value from the internal state.
(B[m[32m+/// Gets a value from the internal state.
(B[m[32m+/// Gets a value from the internal state.
(B[m pub fn get_metrics_snapshot() -> SystemMetricsSnapshot {
     SYSTEM_MONITOR.snapshot()
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/system_monitoring.rs:933:
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:50:
     pub fn new() -> Self {
         Self::default()
     }
[31m-    
(B[m[32m+
(B[m     /// Create a validator with custom limits
[31m-    pub fn with_limits(
(B[m[31m-        max_size: usize,
(B[m[31m-        max_attributes: usize,
(B[m[31m-        max_script_length: usize
(B[m[31m-    ) -> Self {
(B[m[32m+    pub fn with_limits(max_size: usize, max_attributes: usize, max_script_length: usize) -> Self {
(B[m         Self {
             max_size,
             max_attributes,
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:64:
             ..Default::default()
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Set strict validation mode
     pub fn set_strict_mode(&mut self, strict: bool) {
         self.strict_mode = strict;
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:71:
     }
[31m-    
(B[m[32m+
(B[m     /// Add a blocked address
     pub fn block_address(&mut self, address: UInt160) {
         self.blocked_addresses.insert(address);
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:76:
     }
[31m-    
(B[m[32m+
(B[m     /// Validate transaction size
     pub fn validate_size(&self, size: usize) -> CoreResult<()> {
         if size > self.max_size {
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:82:
                 reason: format!(
                     "Transaction size {} exceeds maximum {}",
                     size, self.max_size
[31m-                )
(B[m[32m+                ),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         if self.strict_mode && size == 0 {
             return Err(CoreError::ValidationFailed {
[31m-                reason: "Transaction size cannot be zero".to_string()
(B[m[32m+                reason: "Transaction size cannot be zero".to_string(),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Validate transaction attributes
     pub fn validate_attributes(&self, attributes_count: usize) -> CoreResult<()> {
         if attributes_count > self.max_attributes {
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:102:
                 reason: format!(
                     "Attribute count {} exceeds maximum {}",
                     attributes_count, self.max_attributes
[31m-                )
(B[m[32m+                ),
(B[m             });
         }
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:109:
     }
[31m-    
(B[m[32m+
(B[m     /// Validate script
     pub fn validate_script(&self, script: &[u8]) -> CoreResult<()> {
         if script.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:114:
             return Err(CoreError::ValidationFailed {
[31m-                reason: "Script cannot be empty".to_string()
(B[m[32m+                reason: "Script cannot be empty".to_string(),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         if script.len() > self.max_script_length {
             return Err(CoreError::ValidationFailed {
                 reason: format!(
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:122:
                     "Script length {} exceeds maximum {}",
[31m-                    script.len(), self.max_script_length
(B[m[31m-                )
(B[m[32m+                    script.len(),
(B[m[32m+                    self.max_script_length
(B[m[32m+                ),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         // Additional script validation could be added here
         // e.g., checking for valid opcodes, script structure, etc.
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Validate transaction signers
     pub fn validate_signers(&self, signers: &[UInt160]) -> CoreResult<()> {
         if signers.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:137:
             return Err(CoreError::ValidationFailed {
[31m-                reason: "Transaction must have at least one signer".to_string()
(B[m[32m+                reason: "Transaction must have at least one signer".to_string(),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         if signers.len() > MAX_SIGNERS {
             return Err(CoreError::ValidationFailed {
                 reason: format!(
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:145:
                     "Signer count {} exceeds maximum {}",
[31m-                    signers.len(), MAX_SIGNERS
(B[m[31m-                )
(B[m[32m+                    signers.len(),
(B[m[32m+                    MAX_SIGNERS
(B[m[32m+                ),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         // Check for blocked addresses
         for signer in signers {
             if self.blocked_addresses.contains(signer) {
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:154:
                 return Err(CoreError::ValidationFailed {
[31m-                    reason: format!("Signer {} is blocked", signer)
(B[m[32m+                    reason: format!("Signer {} is blocked", signer),
(B[m                 });
             }
         }
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:159:
[31m-        
(B[m[32m+
(B[m         // Check for duplicate signers
         let mut seen = HashSet::new();
         for signer in signers {
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:163:
             if !seen.insert(signer) {
                 return Err(CoreError::ValidationFailed {
[31m-                    reason: format!("Duplicate signer: {}", signer)
(B[m[32m+                    reason: format!("Duplicate signer: {}", signer),
(B[m                 });
             }
         }
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:169:
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Validate transaction fees
     pub fn validate_fees(&self, network_fee: i64, system_fee: i64) -> CoreResult<()> {
         if network_fee < 0 {
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:176:
             return Err(CoreError::ValidationFailed {
[31m-                reason: format!("Network fee cannot be negative: {}", network_fee)
(B[m[32m+                reason: format!("Network fee cannot be negative: {}", network_fee),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         if system_fee < 0 {
             return Err(CoreError::ValidationFailed {
[31m-                reason: format!("System fee cannot be negative: {}", system_fee)
(B[m[32m+                reason: format!("System fee cannot be negative: {}", system_fee),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         // Could add maximum fee validation to prevent accidents
         const MAX_FEE: i64 = 100_000_000_000; // 1000 GAS
         if self.strict_mode {
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:190:
             if network_fee > MAX_FEE {
                 return Err(CoreError::ValidationFailed {
[31m-                    reason: format!("Network fee {} exceeds maximum", network_fee)
(B[m[32m+                    reason: format!("Network fee {} exceeds maximum", network_fee),
(B[m                 });
             }
[31m-            
(B[m[32m+
(B[m             if system_fee > MAX_FEE {
                 return Err(CoreError::ValidationFailed {
[31m-                    reason: format!("System fee {} exceeds maximum", system_fee)
(B[m[32m+                    reason: format!("System fee {} exceeds maximum", system_fee),
(B[m                 });
             }
         }
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:202:
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Validate nonce for uniqueness
     pub fn validate_nonce(&self, nonce: u32) -> CoreResult<()> {
         // In strict mode, ensure nonce is not zero (likely uninitialized)
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:209:
         if self.strict_mode && nonce == 0 {
             return Err(CoreError::ValidationFailed {
[31m-                reason: "Nonce should not be zero".to_string()
(B[m[32m+                reason: "Nonce should not be zero".to_string(),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         // Additional nonce validation could check against recent transactions
         // to prevent replay attacks
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Validate transaction timestamp
[31m-    pub fn validate_timestamp(&self, valid_until_block: u32, current_height: u32) -> CoreResult<()> {
(B[m[32m+    pub fn validate_timestamp(
(B[m[32m+        &self,
(B[m[32m+        valid_until_block: u32,
(B[m[32m+        current_height: u32,
(B[m[32m+    ) -> CoreResult<()> {
(B[m         if valid_until_block <= current_height {
             return Err(CoreError::ValidationFailed {
                 reason: format!(
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:226:
                     "Transaction expired: valid_until {} <= current height {}",
                     valid_until_block, current_height
[31m-                )
(B[m[32m+                ),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         // Prevent transactions that are valid for too long
         const MAX_VALIDITY_BLOCKS: u32 = 5760; // ~24 hours at 15s blocks
         if self.strict_mode && valid_until_block > current_height + MAX_VALIDITY_BLOCKS {
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:236:
                 reason: format!(
                     "Transaction validity period too long: {} blocks",
                     valid_until_block - current_height
[31m-                )
(B[m[32m+                ),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:260:
             allow_empty: false,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Validate input data
     pub fn validate(&self, input: &[u8]) -> CoreResult<()> {
         if !self.allow_empty && input.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:267:
             return Err(CoreError::ValidationFailed {
[31m-                reason: "Input cannot be empty".to_string()
(B[m[32m+                reason: "Input cannot be empty".to_string(),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         if input.len() > self.max_input_size {
             return Err(CoreError::ValidationFailed {
                 reason: format!(
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:275:
                     "Input size {} exceeds maximum {}",
[31m-                    input.len(), self.max_input_size
(B[m[31m-                )
(B[m[32m+                    input.len(),
(B[m[32m+                    self.max_input_size
(B[m[32m+                ),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Validate string input
     pub fn validate_string(&self, input: &str) -> CoreResult<()> {
         self.validate(input.as_bytes())?;
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:287:
[31m-        
(B[m[32m+
(B[m         // Check for valid UTF-8 (already guaranteed by &str)
         // Could add additional checks for control characters, etc.
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Validate hash input
     pub fn validate_hash(&self, hash: &[u8]) -> CoreResult<()> {
         const HASH_SIZE: usize = 32;
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:297:
[31m-        
(B[m[32m+
(B[m         if hash.len() != HASH_SIZE {
             return Err(CoreError::ValidationFailed {
                 reason: format!(
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:301:
                     "Invalid hash size: expected {}, got {}",
[31m-                    HASH_SIZE, hash.len()
(B[m[31m-                )
(B[m[32m+                    HASH_SIZE,
(B[m[32m+                    hash.len()
(B[m[32m+                ),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         // Check that hash is not all zeros (likely uninitialized)
         if hash.iter().all(|&b| b == 0) {
             return Err(CoreError::ValidationFailed {
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:310:
[31m-                reason: "Hash cannot be all zeros".to_string()
(B[m[32m+                reason: "Hash cannot be all zeros".to_string(),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:318:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_transaction_size_validation() {
         let validator = TransactionValidator::new();
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:325:
[31m-        
(B[m[32m+
(B[m         // Valid size
         assert!(validator.validate_size(1000).is_ok());
[31m-        
(B[m[32m+
(B[m         // Too large
         assert!(validator.validate_size(MAX_TRANSACTION_SIZE + 1).is_err());
[31m-        
(B[m[32m+
(B[m         // Zero size in strict mode
         assert!(validator.validate_size(0).is_err());
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:335:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_signer_validation() {
         let mut validator = TransactionValidator::new();
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:339:
[31m-        
(B[m[32m+
(B[m         // Valid signers
         let signers = vec![UInt160::from([1u8; 20]), UInt160::from([2u8; 20])];
         assert!(validator.validate_signers(&signers).is_ok());
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:343:
[31m-        
(B[m[32m+
(B[m         // Empty signers
         assert!(validator.validate_signers(&[]).is_err());
[31m-        
(B[m[32m+
(B[m         // Duplicate signers
         let duplicate_signers = vec![UInt160::from([1u8; 20]), UInt160::from([1u8; 20])];
         assert!(validator.validate_signers(&duplicate_signers).is_err());
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:350:
[31m-        
(B[m[32m+
(B[m         // Blocked address
         let blocked = UInt160::from([3u8; 20]);
         validator.block_address(blocked);
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:354:
         let signers_with_blocked = vec![UInt160::from([1u8; 20]), blocked];
         assert!(validator.validate_signers(&signers_with_blocked).is_err());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_fee_validation() {
         let validator = TransactionValidator::new();
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:361:
[31m-        
(B[m[32m+
(B[m         // Valid fees
         assert!(validator.validate_fees(1000, 2000).is_ok());
[31m-        
(B[m[32m+
(B[m         // Negative fees
         assert!(validator.validate_fees(-1, 1000).is_err());
         assert!(validator.validate_fees(1000, -1).is_err());
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:368:
[31m-        
(B[m[32m+
(B[m         // Excessive fees in strict mode
         assert!(validator.validate_fees(200_000_000_000, 1000).is_err());
     }
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:372:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_input_validation() {
         let validator = InputValidator::new(1024);
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:376:
[31m-        
(B[m[32m+
(B[m         // Valid input
         assert!(validator.validate(b"valid input").is_ok());
[31m-        
(B[m[32m+
(B[m         // Empty input
         assert!(validator.validate(b"").is_err());
[31m-        
(B[m[32m+
(B[m         // Too large input
         let large_input = vec![0u8; 1025];
         assert!(validator.validate(&large_input).is_err());
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:386:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_hash_validation() {
         let validator = InputValidator::new(1024);
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:391:
[31m-        
(B[m[32m+
(B[m         // Valid hash
         let valid_hash = [1u8; 32];
         assert!(validator.validate_hash(&valid_hash).is_ok());
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:395:
[31m-        
(B[m[32m+
(B[m         // Invalid size
         let invalid_hash = [1u8; 31];
         assert!(validator.validate_hash(&invalid_hash).is_err());
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:399:
[31m-        
(B[m[32m+
(B[m         // All zeros
         let zero_hash = [0u8; 32];
         assert!(validator.validate_hash(&zero_hash).is_err());
Diff in /home/ubuntu/neo-rs/crates/core/src/transaction_validator.rs:403:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:1:
 //! Integration tests for the monitoring system
 
 use neo_core::monitoring::{
[31m-    init_monitoring, AlertLevel, ExporterFactory, HealthStatus, PerformanceThreshold,
(B[m[31m-    Profiler, ThresholdType,
(B[m[32m+    init_monitoring, AlertLevel, ExporterFactory, HealthStatus, PerformanceThreshold, Profiler,
(B[m[32m+    ThresholdType,
(B[m };
 use std::sync::Arc;
 use std::time::Duration;
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:13:
     let system = init_monitoring("1.0.0-test".to_string())
         .await
         .expect("Failed to initialize monitoring");
[31m-    
(B[m[32m+
(B[m     // Check that health monitor is working
     let health_report = system.health_monitor.check_health().await.unwrap();
     assert_eq!(health_report.version, "1.0.0-test");
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:20:
     assert!(!health_report.components.is_empty());
[31m-    
(B[m[32m+
(B[m     // Check that performance monitor is working
     let perf_stats = system.performance_monitor.get_all_stats().await;
     assert!(perf_stats.contains_key("block_processing"));
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:28:
 #[tokio::test]
 async fn test_health_checks() {
     let system = init_monitoring("1.0.0".to_string()).await.unwrap();
[31m-    
(B[m[32m+
(B[m     let health_report = system.health_monitor.check_health().await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Check overall status
     assert!(
         health_report.status == HealthStatus::Healthy
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:37:
             || health_report.status == HealthStatus::Degraded
             || health_report.status == HealthStatus::Unhealthy
     );
[31m-    
(B[m[32m+
(B[m     // Check component health
     for component in &health_report.components {
         assert!(!component.component.is_empty());
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:44:
         assert!(component.duration.as_millis() < 1000); // Health check should be fast
     }
[31m-    
(B[m[32m+
(B[m     // Check uptime
     assert!(health_report.uptime.as_secs() >= 0);
 }
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:51:
 #[tokio::test]
 async fn test_performance_monitoring() {
     let system = init_monitoring("1.0.0".to_string()).await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Record some performance metrics
     for i in 0..10 {
         system
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:60:
             .await
             .unwrap();
     }
[31m-    
(B[m[32m+
(B[m     // Get statistics
     let stats = system
         .performance_monitor
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:67:
         .get_stats("block_processing")
         .await
         .unwrap();
[31m-    
(B[m[32m+
(B[m     assert_eq!(stats.count, 10);
     assert!(stats.min >= 0.0);
     assert!(stats.max <= 0.9);
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:77:
 #[tokio::test]
 async fn test_performance_thresholds_and_alerts() {
     let system = init_monitoring("1.0.0".to_string()).await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Set up alert tracking
     let alert_triggered = Arc::new(tokio::sync::RwLock::new(false));
     let alert_flag = alert_triggered.clone();
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:84:
[31m-    
(B[m[32m+
(B[m     system
         .performance_monitor
         .register_alert_callback(move |alert| {
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:94:
             }
         })
         .await;
[31m-    
(B[m[32m+
(B[m     // Set a low threshold that will trigger
     system
         .performance_monitor
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:105:
             threshold_type: ThresholdType::Max,
         })
         .await;
[31m-    
(B[m[32m+
(B[m     // Register the metric
     system
         .performance_monitor
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:112:
         .register_metric("test_metric".to_string(), 100)
         .await;
[31m-    
(B[m[32m+
(B[m     // Record a value that exceeds the critical threshold
     system
         .performance_monitor
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:118:
         .record("test_metric", 1.5)
         .await
         .unwrap();
[31m-    
(B[m[32m+
(B[m     // Wait for async callback
     sleep(Duration::from_millis(100)).await;
[31m-    
(B[m[32m+
(B[m     let triggered = alert_triggered.read().await;
     assert!(*triggered, "Alert should have been triggered");
 }
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:129:
 #[tokio::test]
 async fn test_profiler() {
     let system = init_monitoring("1.0.0".to_string()).await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Register metric for profiling
     system
         .performance_monitor
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:136:
         .register_metric("test_operation".to_string(), 100)
         .await;
[31m-    
(B[m[32m+
(B[m     // Profile an operation
[31m-    let profiler = Profiler::start_with_monitor(
(B[m[31m-        "test_operation",
(B[m[31m-        system.performance_monitor.clone(),
(B[m[31m-    );
(B[m[31m-    
(B[m[32m+    let profiler =
(B[m[32m+        Profiler::start_with_monitor("test_operation", system.performance_monitor.clone());
(B[m[32m+
(B[m     // Simulate some work
     sleep(Duration::from_millis(10)).await;
[31m-    
(B[m[32m+
(B[m     // Stop and record
     profiler.stop_and_record().await;
[31m-    
(B[m[32m+
(B[m     // Check that the metric was recorded
     let stats = system
         .performance_monitor
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:154:
         .get_stats("test_operation")
         .await
         .unwrap();
[31m-    
(B[m[32m+
(B[m     assert_eq!(stats.count, 1);
     assert!(stats.current > 0.0);
 }
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:162:
 #[tokio::test]
 async fn test_metrics_exporters() {
     let system = init_monitoring("1.0.0".to_string()).await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Test Prometheus exporter
     let prometheus_output = system.export("prometheus").await.unwrap();
     assert!(prometheus_output.contains("neo_health_status"));
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:169:
     assert!(prometheus_output.contains("TYPE"));
     assert!(prometheus_output.contains("HELP"));
[31m-    
(B[m[32m+
(B[m     // Test JSON exporter
     let json_output = system.export("json").await.unwrap();
     assert!(json_output.contains("\"health\""));
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:175:
     assert!(json_output.contains("\"performance\""));
[31m-    
(B[m[32m+
(B[m     // Test JSON pretty exporter
     let json_pretty_output = system.export("json-pretty").await.unwrap();
     assert!(json_pretty_output.contains("{\n"));
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:180:
     assert!(json_pretty_output.contains("\"health\""));
[31m-    
(B[m[32m+
(B[m     // Test CSV exporter
     let csv_output = system.export("csv").await.unwrap();
     assert!(csv_output.contains("timestamp,component,status"));
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:187:
 #[tokio::test]
 async fn test_status_report() {
     let system = init_monitoring("1.0.0".to_string()).await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Record some metrics
     for i in 0..5 {
         system
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:196:
             .await
             .unwrap();
     }
[31m-    
(B[m[32m+
(B[m     // Get status report
     let status = system.get_status().await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Verify report contents
     assert_eq!(status.health.version, "1.0.0");
     assert!(!status.health.components.is_empty());
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:206:
     assert!(!status.performance.is_empty());
     assert!(!status.metrics.is_empty());
[31m-    
(B[m[32m+
(B[m     // Check performance stats
     if let Some(tx_stats) = status.performance.get("tx_validation") {
         assert_eq!(tx_stats.count, 5);
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:215:
 #[tokio::test]
 async fn test_cache_behavior() {
     let system = init_monitoring("1.0.0".to_string()).await.unwrap();
[31m-    
(B[m[32m+
(B[m     // First call should execute health checks
     let start = std::time::Instant::now();
     let _report1 = system.health_monitor.check_health().await.unwrap();
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:222:
     let first_duration = start.elapsed();
[31m-    
(B[m[32m+
(B[m     // Second call should use cache (much faster)
     let start = std::time::Instant::now();
     let _report2 = system.health_monitor.check_health().await.unwrap();
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:227:
     let second_duration = start.elapsed();
[31m-    
(B[m[32m+
(B[m     // Cache should make second call faster
     // Note: This might be flaky in CI, so we're being generous
     assert!(
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:237:
 #[tokio::test]
 async fn test_background_tasks() {
     let system = init_monitoring("1.0.0".to_string()).await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Start background tasks
     system.start_background_tasks();
[31m-    
(B[m[32m+
(B[m     // Wait for background tasks to run
     sleep(Duration::from_secs(1)).await;
[31m-    
(B[m[32m+
(B[m     // Check that system metrics have been updated
     let stats = system.performance_monitor.get_all_stats().await;
[31m-    
(B[m[32m+
(B[m     // Background tasks should have recorded memory and CPU usage
     // Note: These might not exist if the background task hasn't run yet
     // This is more of a smoke test
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:261:
     assert!(ExporterFactory::create("json-pretty").is_some());
     assert!(ExporterFactory::create("csv").is_some());
     assert!(ExporterFactory::create("unknown").is_none());
[31m-    
(B[m[32m+
(B[m     // Test OTLP exporter creation
[31m-    let otlp_exporter = ExporterFactory::create_otlp(
(B[m[31m-        "http://localhost:4317".to_string(),
(B[m[31m-        "neo-node".to_string(),
(B[m[31m-    );
(B[m[32m+    let otlp_exporter =
(B[m[32m+        ExporterFactory::create_otlp("http://localhost:4317".to_string(), "neo-node".to_string());
(B[m     assert_eq!(otlp_exporter.content_type(), "application/json");
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:273:
 #[tokio::test]
 async fn test_invalid_export_format() {
     let system = init_monitoring("1.0.0".to_string()).await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Try to export with invalid format
     let result = system.export("invalid_format").await;
     assert!(result.is_err());
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:280:
[31m-    
(B[m[32m+
(B[m     if let Err(e) = result {
         let error_msg = format!("{:?}", e);
         assert!(error_msg.contains("Unsupported export format"));
Diff in /home/ubuntu/neo-rs/crates/core/tests/monitoring_tests.rs:284:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:1:
 //! Performance regression tests - Ensuring Neo-RS maintains optimal performance
 //! Provides 50+ performance benchmarks and regression detection tests
 
[31m-use neo_core::{UInt160, UInt256, Transaction, Witness, WitnessScope};
(B[m[31m-use std::time::{Duration, Instant};
(B[m[32m+use neo_core::{Transaction, UInt160, UInt256, Witness, WitnessScope};
(B[m use std::collections::HashMap;
[32m+use std::time::{Duration, Instant};
(B[m 
 // ============================================================================
 // Core Data Structure Performance Tests (15 tests)
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:13:
 fn test_uint160_creation_performance() {
     let iterations = 10000;
     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     for i in 0..iterations {
         let bytes = [(i % 256) as u8; 20];
         let _uint160 = UInt160::from(bytes);
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:20:
     }
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_nanos() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Should create UInt160 in less than 100ns per operation
[31m-    assert!(per_operation < 100, 
(B[m[31m-           "UInt160 creation too slow: {} ns per operation", per_operation);
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 100,
(B[m[32m+        "UInt160 creation too slow: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m     println!("UInt160 creation: {} ns per operation", per_operation);
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:33:
 fn test_uint256_creation_performance() {
     let iterations = 10000;
     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     for i in 0..iterations {
         let bytes = [(i % 256) as u8; 32];
         let _uint256 = UInt256::from(bytes);
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:40:
     }
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_nanos() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Should create UInt256 in less than 150ns per operation
[31m-    assert!(per_operation < 150,
(B[m[31m-           "UInt256 creation too slow: {} ns per operation", per_operation);
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 150,
(B[m[32m+        "UInt256 creation too slow: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m     println!("UInt256 creation: {} ns per operation", per_operation);
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:55:
     let uint1 = UInt160::from([1u8; 20]);
     let uint2 = UInt160::from([2u8; 20]);
     let uint3 = UInt160::from([1u8; 20]); // Same as uint1
[31m-    
(B[m[32m+
(B[m     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     for _i in 0..iterations {
         let _eq1 = uint1 == uint2; // Different
         let _eq2 = uint1 == uint3; // Same
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:64:
     }
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_nanos() / (iterations * 2) as u128;
[31m-    
(B[m[32m+
(B[m     // Should compare UInt160 in less than 20ns per operation
[31m-    assert!(per_operation < 20,
(B[m[31m-           "UInt160 comparison too slow: {} ns per operation", per_operation);
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 20,
(B[m[32m+        "UInt160 comparison too slow: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m     println!("UInt160 comparison: {} ns per operation", per_operation);
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:79:
     let uint1 = UInt256::from([1u8; 32]);
     let uint2 = UInt256::from([2u8; 32]);
     let uint3 = UInt256::from([1u8; 32]); // Same as uint1
[31m-    
(B[m[32m+
(B[m     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     for _i in 0..iterations {
         let _eq1 = uint1 == uint2; // Different
         let _eq2 = uint1 == uint3; // Same
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:88:
     }
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_nanos() / (iterations * 2) as u128;
[31m-    
(B[m[32m+
(B[m     // Should compare UInt256 in less than 30ns per operation
[31m-    assert!(per_operation < 30,
(B[m[31m-           "UInt256 comparison too slow: {} ns per operation", per_operation);
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 30,
(B[m[32m+        "UInt256 comparison too slow: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m     println!("UInt256 comparison: {} ns per operation", per_operation);
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:101:
 fn test_uint160_serialization_performance() {
     let iterations = 5000;
     let uint160 = UInt160::from([42u8; 20]);
[31m-    
(B[m[32m+
(B[m     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     for _i in 0..iterations {
         let _bytes = uint160.to_bytes();
     }
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:110:
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_nanos() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Should serialize UInt160 in less than 50ns per operation
[31m-    assert!(per_operation < 50,
(B[m[31m-           "UInt160 serialization too slow: {} ns per operation", per_operation);
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 50,
(B[m[32m+        "UInt160 serialization too slow: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m     println!("UInt160 serialization: {} ns per operation", per_operation);
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:122:
 fn test_uint256_serialization_performance() {
     let iterations = 5000;
     let uint256 = UInt256::from([42u8; 32]);
[31m-    
(B[m[32m+
(B[m     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     for _i in 0..iterations {
         let _bytes = uint256.to_bytes();
     }
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:131:
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_nanos() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Should serialize UInt256 in less than 75ns per operation
[31m-    assert!(per_operation < 75,
(B[m[31m-           "UInt256 serialization too slow: {} ns per operation", per_operation);
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 75,
(B[m[32m+        "UInt256 serialization too slow: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m     println!("UInt256 serialization: {} ns per operation", per_operation);
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:142:
 #[test]
 fn test_transaction_creation_performance() {
     let iterations = 1000;
[31m-    
(B[m[32m+
(B[m     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     for i in 0..iterations {
         let mut tx = Transaction::default();
         tx.set_nonce(i as u32);
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:151:
         tx.system_fee = 1000000;
         tx.network_fee = 100000;
         tx.valid_until_block = 1000;
[31m-        
(B[m[32m+
(B[m         // Add a witness
         let witness = Witness {
             invocation_script: vec![0u8; 64],
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:159:
         };
         tx.witnesses = vec![witness];
     }
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_micros() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Should create Transaction in less than 10μs per operation
[31m-    assert!(per_operation < 10,
(B[m[31m-           "Transaction creation too slow: {} μs per operation", per_operation);
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 10,
(B[m[32m+        "Transaction creation too slow: {} μs per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m     println!("Transaction creation: {} μs per operation", per_operation);
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:174:
 fn test_transaction_hash_performance() {
     let iterations = 1000;
     let mut transactions = Vec::new();
[31m-    
(B[m[32m+
(B[m     // Create test transactions
     for i in 0..iterations {
         let mut tx = Transaction::default();
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:183:
         tx.network_fee = 100000;
         transactions.push(tx);
     }
[31m-    
(B[m[32m+
(B[m     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     for tx in &transactions {
         let _hash = tx.hash();
     }
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:192:
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_micros() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Should hash Transaction in less than 50μs per operation
[31m-    assert!(per_operation < 50,
(B[m[31m-           "Transaction hashing too slow: {} μs per operation", per_operation);
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 50,
(B[m[32m+        "Transaction hashing too slow: {} μs per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m     println!("Transaction hashing: {} μs per operation", per_operation);
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:203:
 #[test]
 fn test_witness_creation_performance() {
     let iterations = 5000;
[31m-    
(B[m[32m+
(B[m     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     for i in 0..iterations {
         let invocation_script = vec![(i % 256) as u8; 64];
         let verification_script = vec![((i + 1) % 256) as u8; 32];
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:212:
[31m-        
(B[m[32m+
(B[m         let _witness = Witness {
             invocation_script,
             verification_script,
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:216:
         };
     }
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_nanos() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Should create Witness in less than 500ns per operation
[31m-    assert!(per_operation < 500,
(B[m[31m-           "Witness creation too slow: {} ns per operation", per_operation);
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 500,
(B[m[32m+        "Witness creation too slow: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m     println!("Witness creation: {} ns per operation", per_operation);
 }
 
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:229:
 #[test]
 fn test_witness_scope_operations_performance() {
     let iterations = 10000;
[31m-    
(B[m[32m+
(B[m     let scopes = vec![
         WitnessScope::None,
         WitnessScope::CalledByEntry,
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:237:
         WitnessScope::CustomGroups,
         WitnessScope::Global,
     ];
[31m-    
(B[m[32m+
(B[m     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     for _i in 0..iterations {
         for scope in &scopes {
             let _clone = scope.clone();
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:246:
             let _is_global = matches!(scope, WitnessScope::Global);
         }
     }
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_nanos() / (iterations * scopes.len()) as u128;
[31m-    
(B[m[32m+
(B[m     // Should process WitnessScope in less than 10ns per operation
[31m-    assert!(per_operation < 10,
(B[m[31m-           "WitnessScope operations too slow: {} ns per operation", per_operation);
(B[m[31m-    
(B[m[31m-    println!("WitnessScope operations: {} ns per operation", per_operation);
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 10,
(B[m[32m+        "WitnessScope operations too slow: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    println!(
(B[m[32m+        "WitnessScope operations: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m }
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:265:
 fn test_hashmap_uint160_performance() {
     let iterations = 1000;
     let mut map: HashMap<UInt160, u64> = HashMap::new();
[31m-    
(B[m[32m+
(B[m     // Insert performance
     let start = Instant::now();
     for i in 0..iterations {
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:273:
         map.insert(key, i as u64);
     }
     let insert_duration = start.elapsed();
[31m-    
(B[m[32m+
(B[m     // Lookup performance
     let keys: Vec<UInt160> = map.keys().cloned().collect();
     let start = Instant::now();
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:281:
         let _value = map.get(key);
     }
     let lookup_duration = start.elapsed();
[31m-    
(B[m[32m+
(B[m     let insert_per_op = insert_duration.as_nanos() / iterations as u128;
     let lookup_per_op = lookup_duration.as_nanos() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Should insert in less than 200ns and lookup in less than 50ns
[31m-    assert!(insert_per_op < 200,
(B[m[31m-           "HashMap UInt160 insert too slow: {} ns", insert_per_op);
(B[m[31m-    assert!(lookup_per_op < 50,
(B[m[31m-           "HashMap UInt160 lookup too slow: {} ns", lookup_per_op);
(B[m[31m-    
(B[m[31m-    println!("HashMap UInt160 - Insert: {} ns, Lookup: {} ns", insert_per_op, lookup_per_op);
(B[m[32m+    assert!(
(B[m[32m+        insert_per_op < 200,
(B[m[32m+        "HashMap UInt160 insert too slow: {} ns",
(B[m[32m+        insert_per_op
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        lookup_per_op < 50,
(B[m[32m+        "HashMap UInt160 lookup too slow: {} ns",
(B[m[32m+        lookup_per_op
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    println!(
(B[m[32m+        "HashMap UInt160 - Insert: {} ns, Lookup: {} ns",
(B[m[32m+        insert_per_op, lookup_per_op
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:298:
 fn test_hashmap_uint256_performance() {
     let iterations = 1000;
     let mut map: HashMap<UInt256, u64> = HashMap::new();
[31m-    
(B[m[32m+
(B[m     // Insert performance
     let start = Instant::now();
     for i in 0..iterations {
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:306:
         map.insert(key, i as u64);
     }
     let insert_duration = start.elapsed();
[31m-    
(B[m[32m+
(B[m     // Lookup performance
     let keys: Vec<UInt256> = map.keys().cloned().collect();
     let start = Instant::now();
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:314:
         let _value = map.get(key);
     }
     let lookup_duration = start.elapsed();
[31m-    
(B[m[32m+
(B[m     let insert_per_op = insert_duration.as_nanos() / iterations as u128;
     let lookup_per_op = lookup_duration.as_nanos() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Should insert in less than 300ns and lookup in less than 75ns
[31m-    assert!(insert_per_op < 300,
(B[m[31m-           "HashMap UInt256 insert too slow: {} ns", insert_per_op);
(B[m[31m-    assert!(lookup_per_op < 75,
(B[m[31m-           "HashMap UInt256 lookup too slow: {} ns", lookup_per_op);
(B[m[31m-    
(B[m[31m-    println!("HashMap UInt256 - Insert: {} ns, Lookup: {} ns", insert_per_op, lookup_per_op);
(B[m[32m+    assert!(
(B[m[32m+        insert_per_op < 300,
(B[m[32m+        "HashMap UInt256 insert too slow: {} ns",
(B[m[32m+        insert_per_op
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        lookup_per_op < 75,
(B[m[32m+        "HashMap UInt256 lookup too slow: {} ns",
(B[m[32m+        lookup_per_op
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    println!(
(B[m[32m+        "HashMap UInt256 - Insert: {} ns, Lookup: {} ns",
(B[m[32m+        insert_per_op, lookup_per_op
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:331:
 fn test_vector_transaction_performance() {
     let iterations = 1000;
     let mut transactions = Vec::new();
[31m-    
(B[m[32m+
(B[m     // Create test transactions
     for i in 0..iterations {
         let mut tx = Transaction::default();
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:338:
         tx.set_nonce(i as u32);
         transactions.push(tx);
     }
[31m-    
(B[m[32m+
(B[m     // Vector iteration performance
     let start = Instant::now();
     for tx in &transactions {
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:345:
         let _nonce = tx.nonce();
     }
     let iteration_duration = start.elapsed();
[31m-    
(B[m[32m+
(B[m     // Vector search performance
     let start = Instant::now();
     for i in 0..100 {
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:353:
         let _found = transactions.iter().find(|tx| tx.nonce() == target_nonce);
     }
     let search_duration = start.elapsed();
[31m-    
(B[m[32m+
(B[m     let iter_per_op = iteration_duration.as_nanos() / iterations as u128;
     let search_per_op = search_duration.as_micros() / 100;
[31m-    
(B[m[32m+
(B[m     // Should iterate in less than 5ns per item and search in less than 10μs
[31m-    assert!(iter_per_op < 5,
(B[m[31m-           "Vector iteration too slow: {} ns per item", iter_per_op);
(B[m[31m-    assert!(search_per_op < 10,
(B[m[31m-           "Vector search too slow: {} μs per search", search_per_op);
(B[m[31m-    
(B[m[31m-    println!("Vector - Iteration: {} ns, Search: {} μs", iter_per_op, search_per_op);
(B[m[32m+    assert!(
(B[m[32m+        iter_per_op < 5,
(B[m[32m+        "Vector iteration too slow: {} ns per item",
(B[m[32m+        iter_per_op
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        search_per_op < 10,
(B[m[32m+        "Vector search too slow: {} μs per search",
(B[m[32m+        search_per_op
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    println!(
(B[m[32m+        "Vector - Iteration: {} ns, Search: {} μs",
(B[m[32m+        iter_per_op, search_per_op
(B[m[32m+    );
(B[m }
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:376:
     let uint160s: Vec<UInt160> = (0..count)
         .map(|i| UInt160::from([(i % 256) as u8; 20]))
         .collect();
[31m-    
(B[m[32m+
(B[m     // Each UInt160 should be exactly 20 bytes + minimal overhead
     let expected_min_size = count * 20; // 20 bytes per UInt160
     let expected_max_size = expected_min_size + (count * 8); // Allow 8 bytes overhead per item
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:383:
[31m-    
(B[m[32m+
(B[m     // Estimate memory usage (this is approximate)
     let actual_size = std::mem::size_of_val(&uint160s) + (count * std::mem::size_of::<UInt160>());
[31m-    
(B[m[31m-    assert!(actual_size >= expected_min_size,
(B[m[31m-           "UInt160 using less memory than expected: {} < {}", actual_size, expected_min_size);
(B[m[31m-    assert!(actual_size <= expected_max_size,
(B[m[31m-           "UInt160 using too much memory: {} > {}", actual_size, expected_max_size);
(B[m[31m-    
(B[m[31m-    println!("UInt160 memory usage: {} bytes for {} items ({} bytes per item)",
(B[m[31m-            actual_size, count, actual_size / count);
(B[m[32m+
(B[m[32m+    assert!(
(B[m[32m+        actual_size >= expected_min_size,
(B[m[32m+        "UInt160 using less memory than expected: {} < {}",
(B[m[32m+        actual_size,
(B[m[32m+        expected_min_size
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        actual_size <= expected_max_size,
(B[m[32m+        "UInt160 using too much memory: {} > {}",
(B[m[32m+        actual_size,
(B[m[32m+        expected_max_size
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    println!(
(B[m[32m+        "UInt160 memory usage: {} bytes for {} items ({} bytes per item)",
(B[m[32m+        actual_size,
(B[m[32m+        count,
(B[m[32m+        actual_size / count
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:399:
     let uint256s: Vec<UInt256> = (0..count)
         .map(|i| UInt256::from([(i % 256) as u8; 32]))
         .collect();
[31m-    
(B[m[32m+
(B[m     // Each UInt256 should be exactly 32 bytes + minimal overhead
     let expected_min_size = count * 32; // 32 bytes per UInt256
     let expected_max_size = expected_min_size + (count * 8); // Allow 8 bytes overhead per item
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:406:
[31m-    
(B[m[32m+
(B[m     // Estimate memory usage (this is approximate)
     let actual_size = std::mem::size_of_val(&uint256s) + (count * std::mem::size_of::<UInt256>());
[31m-    
(B[m[31m-    assert!(actual_size >= expected_min_size,
(B[m[31m-           "UInt256 using less memory than expected: {} < {}", actual_size, expected_min_size);
(B[m[31m-    assert!(actual_size <= expected_max_size,
(B[m[31m-           "UInt256 using too much memory: {} > {}", actual_size, expected_max_size);
(B[m[31m-    
(B[m[31m-    println!("UInt256 memory usage: {} bytes for {} items ({} bytes per item)",
(B[m[31m-            actual_size, count, actual_size / count);
(B[m[32m+
(B[m[32m+    assert!(
(B[m[32m+        actual_size >= expected_min_size,
(B[m[32m+        "UInt256 using less memory than expected: {} < {}",
(B[m[32m+        actual_size,
(B[m[32m+        expected_min_size
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        actual_size <= expected_max_size,
(B[m[32m+        "UInt256 using too much memory: {} > {}",
(B[m[32m+        actual_size,
(B[m[32m+        expected_max_size
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    println!(
(B[m[32m+        "UInt256 memory usage: {} bytes for {} items ({} bytes per item)",
(B[m[32m+        actual_size,
(B[m[32m+        count,
(B[m[32m+        actual_size / count
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:427:
             tx
         })
         .collect();
[31m-    
(B[m[32m+
(B[m     // Estimate memory usage
[31m-    let actual_size = std::mem::size_of_val(&transactions) + 
(B[m[31m-                     transactions.iter().map(|tx| {
(B[m[31m-                         std::mem::size_of_val(tx.script()) + tx.script().len() +
(B[m[31m-                         std::mem::size_of_val(tx.witnesses()) + 
(B[m[31m-                         tx.witnesses().iter().map(|w| w.invocation_script.len() + w.verification_script.len()).sum::<usize>()
(B[m[31m-                     }).sum::<usize>();
(B[m[31m-    
(B[m[32m+    let actual_size = std::mem::size_of_val(&transactions)
(B[m[32m+        + transactions
(B[m[32m+            .iter()
(B[m[32m+            .map(|tx| {
(B[m[32m+                std::mem::size_of_val(tx.script())
(B[m[32m+                    + tx.script().len()
(B[m[32m+                    + std::mem::size_of_val(tx.witnesses())
(B[m[32m+                    + tx.witnesses()
(B[m[32m+                        .iter()
(B[m[32m+                        .map(|w| w.invocation_script.len() + w.verification_script.len())
(B[m[32m+                        .sum::<usize>()
(B[m[32m+            })
(B[m[32m+            .sum::<usize>();
(B[m[32m+
(B[m     let per_tx_size = actual_size / count;
[31m-    
(B[m[32m+
(B[m     // Each transaction should use reasonable memory (less than 1KB with 100 byte script)
[31m-    assert!(per_tx_size < 1024,
(B[m[31m-           "Transaction using too much memory: {} bytes per transaction", per_tx_size);
(B[m[31m-    
(B[m[31m-    println!("Transaction memory usage: {} bytes per transaction", per_tx_size);
(B[m[32m+    assert!(
(B[m[32m+        per_tx_size < 1024,
(B[m[32m+        "Transaction using too much memory: {} bytes per transaction",
(B[m[32m+        per_tx_size
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    println!(
(B[m[32m+        "Transaction memory usage: {} bytes per transaction",
(B[m[32m+        per_tx_size
(B[m[32m+    );
(B[m }
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:451:
 
 #[test]
 fn test_concurrent_uint160_creation() {
[31m-    use std::thread;
(B[m[31m-    use std::sync::Arc;
(B[m     use std::sync::atomic::{AtomicUsize, Ordering};
[31m-    
(B[m[32m+    use std::sync::Arc;
(B[m[32m+    use std::thread;
(B[m[32m+
(B[m     let iterations = 1000;
     let thread_count = 4;
     let counter = Arc::new(AtomicUsize::new(0));
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:461:
[31m-    
(B[m[32m+
(B[m     let start = Instant::now();
[31m-    
(B[m[31m-    let handles: Vec<_> = (0..thread_count).map(|thread_id| {
(B[m[31m-        let counter = Arc::clone(&counter);
(B[m[31m-        thread::spawn(move || {
(B[m[31m-            for i in 0..iterations {
(B[m[31m-                let value = (thread_id * iterations + i) % 256;
(B[m[31m-                let _uint160 = UInt160::from([value as u8; 20]);
(B[m[31m-                counter.fetch_add(1, Ordering::Relaxed);
(B[m[31m-            }
(B[m[32m+
(B[m[32m+    let handles: Vec<_> = (0..thread_count)
(B[m[32m+        .map(|thread_id| {
(B[m[32m+            let counter = Arc::clone(&counter);
(B[m[32m+            thread::spawn(move || {
(B[m[32m+                for i in 0..iterations {
(B[m[32m+                    let value = (thread_id * iterations + i) % 256;
(B[m[32m+                    let _uint160 = UInt160::from([value as u8; 20]);
(B[m[32m+                    counter.fetch_add(1, Ordering::Relaxed);
(B[m[32m+                }
(B[m[32m+            })
(B[m         })
[31m-    }).collect();
(B[m[31m-    
(B[m[32m+        .collect();
(B[m[32m+
(B[m     for handle in handles {
         handle.join().unwrap();
     }
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:478:
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let total_operations = counter.load(Ordering::Relaxed);
     let per_operation = duration.as_nanos() / total_operations as u128;
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:482:
[31m-    
(B[m[32m+
(B[m     assert_eq!(total_operations, thread_count * iterations);
[31m-    
(B[m[32m+
(B[m     // Concurrent operations should not be significantly slower than single-threaded
[31m-    assert!(per_operation < 200,
(B[m[31m-           "Concurrent UInt160 creation too slow: {} ns per operation", per_operation);
(B[m[31m-    
(B[m[31m-    println!("Concurrent UInt160 creation: {} ns per operation across {} threads", 
(B[m[31m-            per_operation, thread_count);
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 200,
(B[m[32m+        "Concurrent UInt160 creation too slow: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    println!(
(B[m[32m+        "Concurrent UInt160 creation: {} ns per operation across {} threads",
(B[m[32m+        per_operation, thread_count
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:494:
 fn test_concurrent_hashmap_operations() {
[31m-    use std::thread;
(B[m     use std::sync::{Arc, Mutex};
[31m-    
(B[m[32m+    use std::thread;
(B[m[32m+
(B[m     let iterations_per_thread = 100;
     let thread_count = 4;
     let map = Arc::new(Mutex::new(HashMap::<UInt160, u64>::new()));
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:501:
[31m-    
(B[m[32m+
(B[m     let start = Instant::now();
[31m-    
(B[m[31m-    let handles: Vec<_> = (0..thread_count).map(|thread_id| {
(B[m[31m-        let map = Arc::clone(&map);
(B[m[31m-        thread::spawn(move || {
(B[m[31m-            for i in 0..iterations_per_thread {
(B[m[31m-                let key = UInt160::from([((thread_id * 100 + i) % 256) as u8; 20]);
(B[m[31m-                let value = (thread_id * iterations_per_thread + i) as u64;
(B[m[31m-                
(B[m[31m-                // Insert
(B[m[31m-                {
(B[m[31m-                    let mut map = map.lock().unwrap();
(B[m[31m-                    map.insert(key, value);
(B[m[32m+
(B[m[32m+    let handles: Vec<_> = (0..thread_count)
(B[m[32m+        .map(|thread_id| {
(B[m[32m+            let map = Arc::clone(&map);
(B[m[32m+            thread::spawn(move || {
(B[m[32m+                for i in 0..iterations_per_thread {
(B[m[32m+                    let key = UInt160::from([((thread_id * 100 + i) % 256) as u8; 20]);
(B[m[32m+                    let value = (thread_id * iterations_per_thread + i) as u64;
(B[m[32m+
(B[m[32m+                    // Insert
(B[m[32m+                    {
(B[m[32m+                        let mut map = map.lock().unwrap();
(B[m[32m+                        map.insert(key, value);
(B[m[32m+                    }
(B[m[32m+
(B[m[32m+                    // Lookup
(B[m[32m+                    {
(B[m[32m+                        let map = map.lock().unwrap();
(B[m[32m+                        let _result = map.get(&key);
(B[m[32m+                    }
(B[m                 }
[31m-                
(B[m[31m-                // Lookup
(B[m[31m-                {
(B[m[31m-                    let map = map.lock().unwrap();
(B[m[31m-                    let _result = map.get(&key);
(B[m[31m-                }
(B[m[31m-            }
(B[m[32m+            })
(B[m         })
[31m-    }).collect();
(B[m[31m-    
(B[m[32m+        .collect();
(B[m[32m+
(B[m     for handle in handles {
         handle.join().unwrap();
     }
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:529:
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let total_operations = thread_count * iterations_per_thread * 2; // Insert + lookup
     let per_operation = duration.as_micros() / total_operations as u128;
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:533:
[31m-    
(B[m[32m+
(B[m     // Concurrent HashMap operations should complete in reasonable time
[31m-    assert!(per_operation < 100,
(B[m[31m-           "Concurrent HashMap operations too slow: {} μs per operation", per_operation);
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 100,
(B[m[32m+        "Concurrent HashMap operations too slow: {} μs per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m     let final_size = map.lock().unwrap().len();
     assert_eq!(final_size, thread_count * iterations_per_thread);
[31m-    
(B[m[31m-    println!("Concurrent HashMap operations: {} μs per operation across {} threads", 
(B[m[31m-            per_operation, thread_count);
(B[m[32m+
(B[m[32m+    println!(
(B[m[32m+        "Concurrent HashMap operations: {} μs per operation across {} threads",
(B[m[32m+        per_operation, thread_count
(B[m[32m+    );
(B[m }
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:549:
 #[test]
 fn test_performance_regression_baseline() {
     // This test establishes performance baselines for regression detection
[31m-    
(B[m[32m+
(B[m     // Test 1: UInt160 operations baseline
     let iterations = 10000;
     let start = Instant::now();
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:556:
[31m-    
(B[m[32m+
(B[m     for i in 0..iterations {
         let uint160 = UInt160::from([(i % 256) as u8; 20]);
         let _bytes = uint160.to_bytes();
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:560:
         let _string = uint160.to_string();
     }
[31m-    
(B[m[32m+
(B[m     let uint160_baseline = start.elapsed().as_nanos() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Test 2: Transaction operations baseline
     let iterations = 1000;
     let start = Instant::now();
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:568:
[31m-    
(B[m[32m+
(B[m     for i in 0..iterations {
         let mut tx = Transaction::default();
         tx.set_nonce(i as u32);
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:572:
         let _hash = tx.hash();
     }
[31m-    
(B[m[32m+
(B[m     let transaction_baseline = start.elapsed().as_nanos() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Test 3: HashMap operations baseline
     let iterations = 5000;
     let mut map = HashMap::new();
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:580:
     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     for i in 0..iterations {
         let key = UInt160::from([(i % 256) as u8; 20]);
         map.insert(key, i as u64);
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:585:
         let _value = map.get(&key);
     }
[31m-    
(B[m[32m+
(B[m     let hashmap_baseline = start.elapsed().as_nanos() / (iterations * 2) as u128;
[31m-    
(B[m[32m+
(B[m     // Store baselines (in a real implementation, these would be stored persistently)
     println!("Performance baselines:");
     println!("  UInt160 operations: {} ns", uint160_baseline);
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:593:
     println!("  Transaction operations: {} ns", transaction_baseline);
     println!("  HashMap operations: {} ns", hashmap_baseline);
[31m-    
(B[m[32m+
(B[m     // Assert reasonable baseline performance (these would be adjusted based on actual measurements)
[31m-    assert!(uint160_baseline < 500, "UInt160 baseline too slow: {} ns", uint160_baseline);
(B[m[31m-    assert!(transaction_baseline < 100000, "Transaction baseline too slow: {} ns", transaction_baseline);
(B[m[31m-    assert!(hashmap_baseline < 200, "HashMap baseline too slow: {} ns", hashmap_baseline);
(B[m[32m+    assert!(
(B[m[32m+        uint160_baseline < 500,
(B[m[32m+        "UInt160 baseline too slow: {} ns",
(B[m[32m+        uint160_baseline
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        transaction_baseline < 100000,
(B[m[32m+        "Transaction baseline too slow: {} ns",
(B[m[32m+        transaction_baseline
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        hashmap_baseline < 200,
(B[m[32m+        "HashMap baseline too slow: {} ns",
(B[m[32m+        hashmap_baseline
(B[m[32m+    );
(B[m }
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:608:
     // Test performance with large numbers of UInt160 operations
     let iterations = 100000;
     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     let mut results = Vec::with_capacity(iterations);
[31m-    
(B[m[32m+
(B[m     for i in 0..iterations {
         let uint160 = UInt160::from([((i / 256) % 256) as u8; 20]);
         results.push(uint160);
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:617:
     }
[31m-    
(B[m[32m+
(B[m     // Sort the results (additional stress test)
     results.sort();
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_nanos() / iterations as u128;
[31m-    
(B[m[32m+
(B[m     // Should handle large scale operations efficiently
[31m-    assert!(per_operation < 1000,
(B[m[31m-           "Large scale UInt160 operations too slow: {} ns per operation", per_operation);
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 1000,
(B[m[32m+        "Large scale UInt160 operations too slow: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m     assert_eq!(results.len(), iterations);
[31m-    
(B[m[31m-    println!("Large scale UInt160 operations: {} ns per operation", per_operation);
(B[m[32m+
(B[m[32m+    println!(
(B[m[32m+        "Large scale UInt160 operations: {} ns per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:634:
 fn test_memory_pressure_handling() {
     // Test performance under memory pressure
     let large_count = 50000;
[31m-    
(B[m[32m+
(B[m     // Create a large number of objects to create memory pressure
     let start = Instant::now();
[31m-    
(B[m[32m+
(B[m     let mut uint160s = Vec::with_capacity(large_count);
     let mut uint256s = Vec::with_capacity(large_count);
     let mut transactions = Vec::with_capacity(large_count);
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:644:
[31m-    
(B[m[32m+
(B[m     for i in 0..large_count {
         uint160s.push(UInt160::from([(i % 256) as u8; 20]));
         uint256s.push(UInt256::from([(i % 256) as u8; 32]));
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:648:
[31m-        
(B[m[32m+
(B[m         let mut tx = Transaction::default();
         tx.set_nonce(i as u32);
         transactions.push(tx);
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:652:
     }
[31m-    
(B[m[32m+
(B[m     // Perform operations under memory pressure
     let mut hash_operations = 0;
     for tx in &transactions {
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:657:
         let _hash = tx.hash();
         hash_operations += 1;
     }
[31m-    
(B[m[32m+
(B[m     let duration = start.elapsed();
     let per_operation = duration.as_micros() / hash_operations as u128;
[31m-    
(B[m[32m+
(B[m     // Should maintain reasonable performance even under memory pressure
[31m-    assert!(per_operation < 100,
(B[m[31m-           "Memory pressure performance too slow: {} μs per operation", per_operation);
(B[m[31m-    
(B[m[31m-    println!("Memory pressure handling: {} μs per operation with {} objects", 
(B[m[31m-            per_operation, large_count * 3);
(B[m[32m+    assert!(
(B[m[32m+        per_operation < 100,
(B[m[32m+        "Memory pressure performance too slow: {} μs per operation",
(B[m[32m+        per_operation
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    println!(
(B[m[32m+        "Memory pressure handling: {} μs per operation with {} objects",
(B[m[32m+        per_operation,
(B[m[32m+        large_count * 3
(B[m[32m+    );
(B[m }
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:676:
 #[cfg(test)]
 mod benchmark_summary {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_comprehensive_performance_summary() {
         println!("\n=== Neo-RS Performance Benchmark Summary ===");
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:683:
[31m-        
(B[m[32m+
(B[m         // Run quick versions of key benchmarks
         let iterations = 1000;
[31m-        
(B[m[32m+
(B[m         // 1. Core operations
         let start = Instant::now();
         for i in 0..iterations {
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:690:
             let _uint160 = UInt160::from([(i % 256) as u8; 20]);
         }
         let uint160_time = start.elapsed().as_nanos() / iterations as u128;
[31m-        
(B[m[32m+
(B[m         let start = Instant::now();
         for i in 0..iterations {
             let _uint256 = UInt256::from([(i % 256) as u8; 32]);
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:697:
         }
         let uint256_time = start.elapsed().as_nanos() / iterations as u128;
[31m-        
(B[m[32m+
(B[m         let start = Instant::now();
         for i in 0..iterations {
             let mut tx = Transaction::default();
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:704:
             let _hash = tx.hash();
         }
         let transaction_time = start.elapsed().as_nanos() / iterations as u128;
[31m-        
(B[m[32m+
(B[m         // 2. Collection operations
         let mut map = HashMap::new();
         let start = Instant::now();
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:713:
             map.insert(key, i as u64);
         }
         let hashmap_time = start.elapsed().as_nanos() / iterations as u128;
[31m-        
(B[m[32m+
(B[m         // Print summary
         println!("Core Operations Performance:");
         println!("  UInt160 creation: {} ns/op", uint160_time);
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:720:
         println!("  UInt256 creation: {} ns/op", uint256_time);
         println!("  Transaction hash: {} ns/op", transaction_time);
         println!("  HashMap insert: {} ns/op", hashmap_time);
[31m-        
(B[m[32m+
(B[m         // Performance targets (these represent good performance on modern hardware)
         let targets = [
             ("UInt160 creation", uint160_time, 100),
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:728:
             ("Transaction hash", transaction_time, 50000),
             ("HashMap insert", hashmap_time, 200),
         ];
[31m-        
(B[m[32m+
(B[m         println!("\nPerformance Assessment:");
         for (name, actual, target) in targets {
             let status = if actual <= target { "PASS" } else { "SLOW" };
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:735:
[31m-            println!("  {}: {} ns/op (target: {} ns/op) - {}", 
(B[m[31m-                    name, actual, target, status);
(B[m[32m+            println!(
(B[m[32m+                "  {}: {} ns/op (target: {} ns/op) - {}",
(B[m[32m+                name, actual, target, status
(B[m[32m+            );
(B[m         }
[31m-        
(B[m[32m+
(B[m         println!("\nPerformance regression tests completed successfully!");
     }
 }
Diff in /home/ubuntu/neo-rs/crates/core/tests/performance_regression_tests.rs:742:
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:1:
 //! Enhanced cryptography tests - Addressing identified gaps in test coverage
 //! Adds 32 comprehensive tests to improve C# Neo compatibility coverage
 
[31m-use neo_cryptography::{hash160, hash256, ripemd160, sha256};
(B[m[31m-use neo_cryptography::ecdsa::ECDsa;
(B[m use neo_cryptography::base58;
[32m+use neo_cryptography::ecdsa::ECDsa;
(B[m use neo_cryptography::murmur::murmur32;
[32m+use neo_cryptography::{hash160, hash256, ripemd160, sha256};
(B[m 
 // ============================================================================
 // Enhanced Hash Function Tests (8 tests)
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:13:
 #[test]
 fn test_hash_empty_input_consistency() {
     let empty_data = b"";
[31m-    
(B[m[32m+
(B[m     // Test hash functions with empty input
     let hash160_result = hash160(empty_data);
     let hash256_result = hash256(empty_data);
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:20:
     let ripemd160_result = ripemd160(empty_data);
     let sha256_result = sha256(empty_data);
[31m-    
(B[m[32m+
(B[m     assert_eq!(hash160_result.len(), 20, "Hash160 should produce 20 bytes");
     assert_eq!(hash256_result.len(), 32, "Hash256 should produce 32 bytes");
[31m-    assert_eq!(ripemd160_result.len(), 20, "RIPEMD160 should produce 20 bytes");
(B[m[32m+    assert_eq!(
(B[m[32m+        ripemd160_result.len(),
(B[m[32m+        20,
(B[m[32m+        "RIPEMD160 should produce 20 bytes"
(B[m[32m+    );
(B[m     assert_eq!(sha256_result.len(), 32, "SHA256 should produce 32 bytes");
[31m-    
(B[m[32m+
(B[m     // Results should be deterministic
[31m-    assert_eq!(hash160_result, hash160(empty_data), "Hash160 should be deterministic");
(B[m[31m-    assert_eq!(hash256_result, hash256(empty_data), "Hash256 should be deterministic");
(B[m[32m+    assert_eq!(
(B[m[32m+        hash160_result,
(B[m[32m+        hash160(empty_data),
(B[m[32m+        "Hash160 should be deterministic"
(B[m[32m+    );
(B[m[32m+    assert_eq!(
(B[m[32m+        hash256_result,
(B[m[32m+        hash256(empty_data),
(B[m[32m+        "Hash256 should be deterministic"
(B[m[32m+    );
(B[m }
 
[31m-#[test] 
(B[m[32m+#[test]
(B[m fn test_hash_single_byte_variations() {
     // Test hashing all single byte values
     let mut hash160_results = std::collections::HashSet::new();
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:37:
     let mut hash256_results = std::collections::HashSet::new();
[31m-    
(B[m[32m+
(B[m     for byte_value in 0u8..=255u8 {
         let single_byte = [byte_value];
[31m-        
(B[m[32m+
(B[m         let hash160_result = hash160(&single_byte);
         let hash256_result = hash256(&single_byte);
[31m-        
(B[m[32m+
(B[m         // All results should be unique
[31m-        assert!(hash160_results.insert(hash160_result), 
(B[m[31m-               "Hash160 collision for byte {}", byte_value);
(B[m[31m-        assert!(hash256_results.insert(hash256_result), 
(B[m[31m-               "Hash256 collision for byte {}", byte_value);
(B[m[32m+        assert!(
(B[m[32m+            hash160_results.insert(hash160_result),
(B[m[32m+            "Hash160 collision for byte {}",
(B[m[32m+            byte_value
(B[m[32m+        );
(B[m[32m+        assert!(
(B[m[32m+            hash256_results.insert(hash256_result),
(B[m[32m+            "Hash256 collision for byte {}",
(B[m[32m+            byte_value
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[32m+
(B[m     // We should have 256 unique results
[31m-    assert_eq!(hash160_results.len(), 256, "All Hash160 results should be unique");
(B[m[31m-    assert_eq!(hash256_results.len(), 256, "All Hash256 results should be unique");
(B[m[32m+    assert_eq!(
(B[m[32m+        hash160_results.len(),
(B[m[32m+        256,
(B[m[32m+        "All Hash160 results should be unique"
(B[m[32m+    );
(B[m[32m+    assert_eq!(
(B[m[32m+        hash256_results.len(),
(B[m[32m+        256,
(B[m[32m+        "All Hash256 results should be unique"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:58:
 fn test_hash_boundary_conditions() {
     let test_cases = vec![
[31m-        vec![0x00u8; 55],       // SHA-256 block boundary - 9
(B[m[31m-        vec![0x00u8; 64],       // Exactly one SHA-256 block  
(B[m[31m-        vec![0x00u8; 65],       // Just over one block
(B[m[31m-        vec![0xFFu8; 128],      // Two complete blocks
(B[m[31m-        vec![0x5Au8; 129],      // Just over two blocks
(B[m[32m+        vec![0x00u8; 55],  // SHA-256 block boundary - 9
(B[m[32m+        vec![0x00u8; 64],  // Exactly one SHA-256 block
(B[m[32m+        vec![0x00u8; 65],  // Just over one block
(B[m[32m+        vec![0xFFu8; 128], // Two complete blocks
(B[m[32m+        vec![0x5Au8; 129], // Just over two blocks
(B[m     ];
[31m-    
(B[m[32m+
(B[m     for (i, test_data) in test_cases.iter().enumerate() {
         let hash160_result = hash160(test_data);
         let hash256_result = hash256(test_data);
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:70:
[31m-        
(B[m[31m-        assert_eq!(hash160_result.len(), 20, "Boundary case {} Hash160 length", i);
(B[m[31m-        assert_eq!(hash256_result.len(), 32, "Boundary case {} Hash256 length", i);
(B[m[31m-        
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            hash160_result.len(),
(B[m[32m+            20,
(B[m[32m+            "Boundary case {} Hash160 length",
(B[m[32m+            i
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            hash256_result.len(),
(B[m[32m+            32,
(B[m[32m+            "Boundary case {} Hash256 length",
(B[m[32m+            i
(B[m[32m+        );
(B[m[32m+
(B[m         // Verify deterministic behavior
[31m-        assert_eq!(hash160_result, hash160(test_data), 
(B[m[31m-                  "Boundary case {} Hash160 deterministic", i);
(B[m[31m-        assert_eq!(hash256_result, hash256(test_data), 
(B[m[31m-                  "Boundary case {} Hash256 deterministic", i);
(B[m[32m+        assert_eq!(
(B[m[32m+            hash160_result,
(B[m[32m+            hash160(test_data),
(B[m[32m+            "Boundary case {} Hash160 deterministic",
(B[m[32m+            i
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            hash256_result,
(B[m[32m+            hash256(test_data),
(B[m[32m+            "Boundary case {} Hash256 deterministic",
(B[m[32m+            i
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:83:
 fn test_murmur_hash_variations() {
     let test_inputs = vec![
         b"".to_vec(),
[31m-        b"a".to_vec(), 
(B[m[32m+        b"a".to_vec(),
(B[m         b"abc".to_vec(),
         b"message digest".to_vec(),
[31m-        vec![0u8; 1000], // 1KB of zeros
(B[m[32m+        vec![0u8; 1000],                  // 1KB of zeros
(B[m         (0..=255u8).collect::<Vec<u8>>(), // All byte values
     ];
[31m-    
(B[m[32m+
(B[m     let test_seeds = [0u32, 1u32, 0x12345678u32, 0xDEADBEEFu32, 0xFFFFFFFFu32];
[31m-    
(B[m[32m+
(B[m     for (input_idx, input) in test_inputs.iter().enumerate() {
         for (seed_idx, &seed) in test_seeds.iter().enumerate() {
             let hash_result = murmur32(input, seed);
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:98:
[31m-            
(B[m[32m+
(B[m             // Verify deterministic behavior
             let hash_again = murmur32(input, seed);
[31m-            assert_eq!(hash_result, hash_again, 
(B[m[31m-                      "MurmurHash deterministic input:{} seed:{}", input_idx, seed_idx);
(B[m[32m+            assert_eq!(
(B[m[32m+                hash_result, hash_again,
(B[m[32m+                "MurmurHash deterministic input:{} seed:{}",
(B[m[32m+                input_idx, seed_idx
(B[m[32m+            );
(B[m         }
     }
 }
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:109:
     let base_input = b"Neo blockchain avalanche test";
     let base_hash160 = hash160(base_input);
     let base_hash256 = hash256(base_input);
[31m-    
(B[m[32m+
(B[m     // Test single bit flip effects
     for byte_pos in 0..base_input.len() {
         let mut modified_input = base_input.to_vec();
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:116:
         modified_input[byte_pos] ^= 0x01; // Flip one bit
[31m-        
(B[m[32m+
(B[m         let modified_hash160 = hash160(&modified_input);
         let modified_hash256 = hash256(&modified_input);
[31m-        
(B[m[32m+
(B[m         // Hashes should be completely different
[31m-        assert_ne!(base_hash160, modified_hash160, 
(B[m[31m-                  "Hash160 avalanche failed at byte {}", byte_pos);
(B[m[31m-        assert_ne!(base_hash256, modified_hash256, 
(B[m[31m-                  "Hash256 avalanche failed at byte {}", byte_pos);
(B[m[31m-        
(B[m[32m+        assert_ne!(
(B[m[32m+            base_hash160, modified_hash160,
(B[m[32m+            "Hash160 avalanche failed at byte {}",
(B[m[32m+            byte_pos
(B[m[32m+        );
(B[m[32m+        assert_ne!(
(B[m[32m+            base_hash256, modified_hash256,
(B[m[32m+            "Hash256 avalanche failed at byte {}",
(B[m[32m+            byte_pos
(B[m[32m+        );
(B[m[32m+
(B[m         // Count different bytes (should be significant)
         let diff_bytes_160 = count_different_bytes(&base_hash160, &modified_hash160);
         let diff_bytes_256 = count_different_bytes(&base_hash256, &modified_hash256);
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:130:
[31m-        
(B[m[31m-        assert!(diff_bytes_160 >= 8, "Hash160 should change at least 8 bytes");
(B[m[31m-        assert!(diff_bytes_256 >= 12, "Hash256 should change at least 12 bytes");
(B[m[32m+
(B[m[32m+        assert!(
(B[m[32m+            diff_bytes_160 >= 8,
(B[m[32m+            "Hash160 should change at least 8 bytes"
(B[m[32m+        );
(B[m[32m+        assert!(
(B[m[32m+            diff_bytes_256 >= 12,
(B[m[32m+            "Hash256 should change at least 12 bytes"
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:138:
     // Standard RIPEMD160 test vectors
     let test_vectors = vec![
         (&b""[..], "9c1185a5c5e9fc54612808977ee8f548b2258d31"),
[31m-        (&b"a"[..], "0bdc9d2d256b3ee9daae347be6f4dc835a467ffe"), 
(B[m[32m+        (&b"a"[..], "0bdc9d2d256b3ee9daae347be6f4dc835a467ffe"),
(B[m         (&b"abc"[..], "8eb208f7e05d987a9b044a8e98c6b087f15a0bfc"),
[31m-        (&b"message digest"[..], "5d0689ef49d2fae572b881b123a85ffa21595f36"),
(B[m[32m+        (
(B[m[32m+            &b"message digest"[..],
(B[m[32m+            "5d0689ef49d2fae572b881b123a85ffa21595f36",
(B[m[32m+        ),
(B[m     ];
[31m-    
(B[m[32m+
(B[m     for (input, expected_hex) in test_vectors {
         let result = ripemd160(input);
         let result_hex = hex::encode(result);
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:149:
[31m-        
(B[m[31m-        assert_eq!(result_hex, expected_hex, 
(B[m[31m-                  "RIPEMD160 test vector failed for: {:?}", 
(B[m[31m-                  String::from_utf8_lossy(input));
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            result_hex,
(B[m[32m+            expected_hex,
(B[m[32m+            "RIPEMD160 test vector failed for: {:?}",
(B[m[32m+            String::from_utf8_lossy(input)
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:158:
     const ITERATIONS: usize = 1000;
     let mut hash160_set = std::collections::HashSet::new();
     let mut hash256_set = std::collections::HashSet::new();
[31m-    
(B[m[32m+
(B[m     for i in 0..ITERATIONS {
         let input = format!("Neo hash test {}", i);
[31m-        
(B[m[32m+
(B[m         let hash160_result = hash160(input.as_bytes());
         let hash256_result = hash256(input.as_bytes());
[31m-        
(B[m[32m+
(B[m         // Should not have collisions
[31m-        assert!(hash160_set.insert(hash160_result), 
(B[m[31m-               "Hash160 collision at iteration {}", i);
(B[m[31m-        assert!(hash256_set.insert(hash256_result), 
(B[m[31m-               "Hash256 collision at iteration {}", i);
(B[m[32m+        assert!(
(B[m[32m+            hash160_set.insert(hash160_result),
(B[m[32m+            "Hash160 collision at iteration {}",
(B[m[32m+            i
(B[m[32m+        );
(B[m[32m+        assert!(
(B[m[32m+            hash256_set.insert(hash256_result),
(B[m[32m+            "Hash256 collision at iteration {}",
(B[m[32m+            i
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[31m-    assert_eq!(hash160_set.len(), ITERATIONS, "All Hash160 should be unique");
(B[m[31m-    assert_eq!(hash256_set.len(), ITERATIONS, "All Hash256 should be unique");
(B[m[32m+
(B[m[32m+    assert_eq!(
(B[m[32m+        hash160_set.len(),
(B[m[32m+        ITERATIONS,
(B[m[32m+        "All Hash160 should be unique"
(B[m[32m+    );
(B[m[32m+    assert_eq!(
(B[m[32m+        hash256_set.len(),
(B[m[32m+        ITERATIONS,
(B[m[32m+        "All Hash256 should be unique"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:180:
 fn test_large_input_processing() {
     let large_input = vec![0x42u8; 100_000]; // 100KB
[31m-    
(B[m[32m+
(B[m     let hash160_result = hash160(&large_input);
     let hash256_result = hash256(&large_input);
[31m-    
(B[m[31m-    assert_eq!(hash160_result.len(), 20, "Hash160 should handle large input");
(B[m[31m-    assert_eq!(hash256_result.len(), 32, "Hash256 should handle large input");
(B[m[31m-    
(B[m[32m+
(B[m[32m+    assert_eq!(
(B[m[32m+        hash160_result.len(),
(B[m[32m+        20,
(B[m[32m+        "Hash160 should handle large input"
(B[m[32m+    );
(B[m[32m+    assert_eq!(
(B[m[32m+        hash256_result.len(),
(B[m[32m+        32,
(B[m[32m+        "Hash256 should handle large input"
(B[m[32m+    );
(B[m[32m+
(B[m     // Should be deterministic
[31m-    assert_eq!(hash160_result, hash160(&large_input), "Large input Hash160 deterministic");
(B[m[31m-    assert_eq!(hash256_result, hash256(&large_input), "Large input Hash256 deterministic");
(B[m[32m+    assert_eq!(
(B[m[32m+        hash160_result,
(B[m[32m+        hash160(&large_input),
(B[m[32m+        "Large input Hash160 deterministic"
(B[m[32m+    );
(B[m[32m+    assert_eq!(
(B[m[32m+        hash256_result,
(B[m[32m+        hash256(&large_input),
(B[m[32m+        "Large input Hash256 deterministic"
(B[m[32m+    );
(B[m }
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:199:
 fn test_ecdsa_key_generation_uniqueness() {
     const KEY_COUNT: usize = 100;
     let mut private_keys = std::collections::HashSet::new();
[31m-    
(B[m[32m+
(B[m     for i in 0..KEY_COUNT {
         let private_key = ECDsa::generate_private_key();
[31m-        
(B[m[32m+
(B[m         // Verify key properties
[31m-        assert_eq!(private_key.len(), 32, "Private key {} should be 32 bytes", i);
(B[m[31m-        assert!(!private_key.iter().all(|&b| b == 0), "Private key {} should not be zero", i);
(B[m[31m-        
(B[m[32m+        assert_eq!(
(B[m[32m+            private_key.len(),
(B[m[32m+            32,
(B[m[32m+            "Private key {} should be 32 bytes",
(B[m[32m+            i
(B[m[32m+        );
(B[m[32m+        assert!(
(B[m[32m+            !private_key.iter().all(|&b| b == 0),
(B[m[32m+            "Private key {} should not be zero",
(B[m[32m+            i
(B[m[32m+        );
(B[m[32m+
(B[m         // Verify uniqueness
[31m-        assert!(private_keys.insert(private_key), "Private key {} should be unique", i);
(B[m[32m+        assert!(
(B[m[32m+            private_keys.insert(private_key),
(B[m[32m+            "Private key {} should be unique",
(B[m[32m+            i
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[31m-    assert_eq!(private_keys.len(), KEY_COUNT, "All private keys should be unique");
(B[m[32m+
(B[m[32m+    assert_eq!(
(B[m[32m+        private_keys.len(),
(B[m[32m+        KEY_COUNT,
(B[m[32m+        "All private keys should be unique"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:218:
 fn test_ecdsa_public_key_derivation_consistency() {
     for i in 0..10 {
         let private_key = ECDsa::generate_private_key();
[31m-        
(B[m[32m+
(B[m         // Test multiple derivations are consistent
         if let (Ok(pub1), Ok(pub2)) = (
             ECDsa::derive_public_key(&private_key),
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:225:
[31m-            ECDsa::derive_public_key(&private_key)
(B[m[32m+            ECDsa::derive_public_key(&private_key),
(B[m         ) {
[31m-            assert_eq!(pub1, pub2, "Public key derivation {} should be deterministic", i);
(B[m[32m+            assert_eq!(
(B[m[32m+                pub1, pub2,
(B[m[32m+                "Public key derivation {} should be deterministic",
(B[m[32m+                i
(B[m[32m+            );
(B[m             assert_eq!(pub1.len(), 65, "Uncompressed public key should be 65 bytes");
             assert_eq!(pub1[0], 0x04, "Uncompressed key should start with 0x04");
         }
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:231:
[31m-        
(B[m[32m+
(B[m         // Test compressed key derivation
         if let (Ok(comp1), Ok(comp2)) = (
             ECDsa::derive_compressed_public_key(&private_key),
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:235:
[31m-            ECDsa::derive_compressed_public_key(&private_key)
(B[m[32m+            ECDsa::derive_compressed_public_key(&private_key),
(B[m         ) {
[31m-            assert_eq!(comp1, comp2, "Compressed key derivation {} should be deterministic", i);
(B[m[32m+            assert_eq!(
(B[m[32m+                comp1, comp2,
(B[m[32m+                "Compressed key derivation {} should be deterministic",
(B[m[32m+                i
(B[m[32m+            );
(B[m             assert_eq!(comp1.len(), 33, "Compressed public key should be 33 bytes");
[31m-            assert!(comp1[0] == 0x02 || comp1[0] == 0x03, "Compressed key should start with 0x02 or 0x03");
(B[m[32m+            assert!(
(B[m[32m+                comp1[0] == 0x02 || comp1[0] == 0x03,
(B[m[32m+                "Compressed key should start with 0x02 or 0x03"
(B[m[32m+            );
(B[m         }
     }
 }
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:245:
 fn test_ecdsa_signature_deterministic() {
     let message = b"Neo deterministic signature test";
     let private_key = [0x01u8; 32]; // Fixed key for deterministic testing
[31m-    
(B[m[32m+
(B[m     let sig1 = ECDsa::sign(message, &private_key);
     let sig2 = ECDsa::sign(message, &private_key);
[31m-    
(B[m[32m+
(B[m     if let (Ok(signature1), Ok(signature2)) = (sig1, sig2) {
         // Signatures should be deterministic (RFC 6979)
         assert_eq!(signature1, signature2, "Signatures should be deterministic");
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:255:
         assert!(!signature1.is_empty(), "Signature should not be empty");
[31m-        assert!(signature1.len() >= 64, "Signature should be at least 64 bytes");
(B[m[32m+        assert!(
(B[m[32m+            signature1.len() >= 64,
(B[m[32m+            "Signature should be at least 64 bytes"
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:262:
     for i in 0..5 {
         let message = format!("Neo signature test message {}", i);
         let private_key = ECDsa::generate_private_key();
[31m-        
(B[m[32m+
(B[m         if let Ok(public_key) = ECDsa::derive_public_key(&private_key) {
             if let Ok(signature) = ECDsa::sign(message.as_bytes(), &private_key) {
                 if let Ok(is_valid) = ECDsa::verify(message.as_bytes(), &signature, &public_key) {
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:277:
 fn test_ecdsa_invalid_signature_rejection() {
     let message = b"Neo invalid signature test";
     let private_key = ECDsa::generate_private_key();
[31m-    
(B[m[32m+
(B[m     if let (Ok(public_key), Ok(mut signature)) = (
         ECDsa::derive_public_key(&private_key),
[31m-        ECDsa::sign(message, &private_key)
(B[m[32m+        ECDsa::sign(message, &private_key),
(B[m     ) {
         // Corrupt the signature
         if !signature.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:287:
             signature[0] ^= 0xFF;
         }
[31m-        
(B[m[32m+
(B[m         if let Ok(is_valid) = ECDsa::verify(message, &signature, &public_key) {
             assert!(!is_valid, "Corrupted signature should be invalid");
         }
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:296:
 #[test]
 fn test_ecdsa_wrong_message_rejection() {
     let message1 = b"Original message";
[31m-    let message2 = b"Different message"; 
(B[m[32m+    let message2 = b"Different message";
(B[m     let private_key = ECDsa::generate_private_key();
[31m-    
(B[m[32m+
(B[m     if let (Ok(public_key), Ok(signature)) = (
         ECDsa::derive_public_key(&private_key),
[31m-        ECDsa::sign(message1, &private_key)
(B[m[32m+        ECDsa::sign(message1, &private_key),
(B[m     ) {
         if let Ok(is_valid) = ECDsa::verify(message2, &signature, &public_key) {
[31m-            assert!(!is_valid, "Signature should not verify for different message");
(B[m[32m+            assert!(
(B[m[32m+                !is_valid,
(B[m[32m+                "Signature should not verify for different message"
(B[m[32m+            );
(B[m         }
     }
 }
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:313:
 fn test_ecdsa_empty_message_signature() {
     let empty_message = b"";
     let private_key = ECDsa::generate_private_key();
[31m-    
(B[m[32m+
(B[m     if let (Ok(public_key), Ok(signature)) = (
         ECDsa::derive_public_key(&private_key),
[31m-        ECDsa::sign(empty_message, &private_key)
(B[m[32m+        ECDsa::sign(empty_message, &private_key),
(B[m     ) {
         if let Ok(is_valid) = ECDsa::verify(empty_message, &signature, &public_key) {
             assert!(is_valid, "Empty message signature should be valid");
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:328:
 fn test_ecdsa_large_message_signature() {
     let large_message = vec![0x42u8; 10000]; // 10KB message
     let private_key = ECDsa::generate_private_key();
[31m-    
(B[m[32m+
(B[m     if let (Ok(public_key), Ok(signature)) = (
         ECDsa::derive_public_key(&private_key),
[31m-        ECDsa::sign(&large_message, &private_key)
(B[m[32m+        ECDsa::sign(&large_message, &private_key),
(B[m     ) {
         if let Ok(is_valid) = ECDsa::verify(&large_message, &signature, &public_key) {
             assert!(is_valid, "Large message signature should be valid");
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:342:
 #[test]
 fn test_ecdsa_key_format_validation() {
     let valid_private = ECDsa::generate_private_key();
[31m-    
(B[m[32m+
(B[m     // Test validation functions if they exist
     if let Ok(valid_public) = ECDsa::derive_public_key(&valid_private) {
         // Basic format checks
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:349:
[31m-        assert_eq!(valid_private.len(), 32, "Valid private key should be 32 bytes");
(B[m[31m-        assert_eq!(valid_public.len(), 65, "Valid public key should be 65 bytes");
(B[m[31m-        assert_eq!(valid_public[0], 0x04, "Uncompressed public key should start with 0x04");
(B[m[32m+        assert_eq!(
(B[m[32m+            valid_private.len(),
(B[m[32m+            32,
(B[m[32m+            "Valid private key should be 32 bytes"
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            valid_public.len(),
(B[m[32m+            65,
(B[m[32m+            "Valid public key should be 65 bytes"
(B[m[32m+        );
(B[m[32m+        assert_eq!(
(B[m[32m+            valid_public[0], 0x04,
(B[m[32m+            "Uncompressed public key should start with 0x04"
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Test compressed key format
     if let Ok(compressed_public) = ECDsa::derive_compressed_public_key(&valid_private) {
[31m-        assert_eq!(compressed_public.len(), 33, "Compressed public key should be 33 bytes");
(B[m[31m-        assert!(compressed_public[0] == 0x02 || compressed_public[0] == 0x03, 
(B[m[31m-               "Compressed key should have valid prefix");
(B[m[32m+        assert_eq!(
(B[m[32m+            compressed_public.len(),
(B[m[32m+            33,
(B[m[32m+            "Compressed public key should be 33 bytes"
(B[m[32m+        );
(B[m[32m+        assert!(
(B[m[32m+            compressed_public[0] == 0x02 || compressed_public[0] == 0x03,
(B[m[32m+            "Compressed key should have valid prefix"
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:362:
 // ============================================================================
[31m-// Enhanced Base58 and Format Tests (9 tests)  
(B[m[32m+// Enhanced Base58 and Format Tests (9 tests)
(B[m // ============================================================================
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:373:
         (0..=255u8).collect(),  // All byte values
         vec![0x42u8; 1000],     // Large data
     ];
[31m-    
(B[m[32m+
(B[m     for (i, test_data) in test_cases.iter().enumerate() {
         let encoded = base58::encode(test_data);
[31m-        
(B[m[32m+
(B[m         if let Ok(decoded) = base58::decode(&encoded) {
[31m-            assert_eq!(test_data, &decoded, "Base58 round-trip failed for test case {}", i);
(B[m[32m+            assert_eq!(
(B[m[32m+                test_data, &decoded,
(B[m[32m+                "Base58 round-trip failed for test case {}",
(B[m[32m+                i
(B[m[32m+            );
(B[m         }
[31m-        
(B[m[32m+
(B[m         // Encoded string should not be empty unless input was empty
         if !test_data.is_empty() {
[31m-            assert!(!encoded.is_empty(), "Encoded string should not be empty for test case {}", i);
(B[m[32m+            assert!(
(B[m[32m+                !encoded.is_empty(),
(B[m[32m+                "Encoded string should not be empty for test case {}",
(B[m[32m+                i
(B[m[32m+            );
(B[m         }
     }
 }
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:391:
 #[test]
 fn test_base58_invalid_character_handling() {
     let invalid_strings = vec![
[31m-        "0OIl",           // Invalid characters
(B[m[31m-        "Hello World!",   // Contains spaces and punctuation
(B[m[32m+        "0OIl",                                                             // Invalid characters
(B[m[32m+        "Hello World!", // Contains spaces and punctuation
(B[m         "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz0OIl", // Mixed valid/invalid
     ];
[31m-    
(B[m[32m+
(B[m     for invalid_string in invalid_strings {
         let result = base58::decode(invalid_string);
[31m-        assert!(result.is_err(), "Invalid Base58 string should be rejected: {}", invalid_string);
(B[m[32m+        assert!(
(B[m[32m+            result.is_err(),
(B[m[32m+            "Invalid Base58 string should be rejected: {}",
(B[m[32m+            invalid_string
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:405:
[31m-#[test] 
(B[m[32m+#[test]
(B[m fn test_base58_edge_cases() {
     // Test edge cases
     let empty_data = vec![];
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:409:
     let encoded_empty = base58::encode(&empty_data);
[31m-    
(B[m[32m+
(B[m     if let Ok(decoded_empty) = base58::decode(&encoded_empty) {
[31m-        assert_eq!(empty_data, decoded_empty, "Empty data round-trip should work");
(B[m[32m+        assert_eq!(
(B[m[32m+            empty_data, decoded_empty,
(B[m[32m+            "Empty data round-trip should work"
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Test single byte values
     for byte_value in 0u8..=255u8 {
         let single_byte = vec![byte_value];
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:418:
         let encoded = base58::encode(&single_byte);
[31m-        
(B[m[32m+
(B[m         if let Ok(decoded) = base58::decode(&encoded) {
[31m-            assert_eq!(single_byte, decoded, "Single byte {} round-trip failed", byte_value);
(B[m[32m+            assert_eq!(
(B[m[32m+                single_byte, decoded,
(B[m[32m+                "Single byte {} round-trip failed",
(B[m[32m+                byte_value
(B[m[32m+            );
(B[m         }
     }
 }
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/crypto_enhanced_tests.rs:431:
     assert_eq!(a.len(), b.len());
     a.iter().zip(b.iter()).filter(|(x, y)| x != y).count()
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:14:
     let message = b"Neo blockchain signature test";
     let private_key = ECDsa::generate_private_key();
     let public_key = ECDsa::derive_public_key(&private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     let signature = ECDsa::sign(message, &private_key).unwrap();
     let is_valid = ECDsa::verify(message, &signature, &public_key).unwrap();
[31m-    
(B[m[32m+
(B[m     assert!(is_valid, "Signature verification should succeed");
 }
 
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:24:
[31m-#[test] 
(B[m[32m+#[test]
(B[m fn test_ecdsa_invalid_signature_rejection() {
     // Test invalid signature rejection like C# UT_Crypto.TestInvalidSignature
     let message = b"Test message";
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:28:
     let private_key = ECDsa::generate_private_key();
     let public_key = ECDsa::derive_public_key(&private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     let mut signature = ECDsa::sign(message, &private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     // Corrupt the signature
     if signature.len() > 0 {
         signature[0] ^= 0xFF;
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:36:
     }
[31m-    
(B[m[32m+
(B[m     let is_valid = ECDsa::verify(message, &signature, &public_key).unwrap_or(false);
     assert!(!is_valid, "Corrupted signature should be rejected");
 }
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:46:
     let message2 = b"Different message";
     let private_key = ECDsa::generate_private_key();
     let public_key = ECDsa::derive_public_key(&private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     let signature = ECDsa::sign(message1, &private_key).unwrap();
     let is_valid = ECDsa::verify(message2, &signature, &public_key).unwrap_or(false);
[31m-    
(B[m[31m-    assert!(!is_valid, "Signature should not validate for different message");
(B[m[32m+
(B[m[32m+    assert!(
(B[m[32m+        !is_valid,
(B[m[32m+        "Signature should not validate for different message"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:58:
     // Test signature works with both compressed/uncompressed keys like C# UT_Crypto.TestKeyFormats
     let message = b"Key format compatibility test";
     let private_key = ECDsa::generate_private_key();
[31m-    
(B[m[32m+
(B[m     let compressed_key = ECDsa::derive_compressed_public_key(&private_key).unwrap();
     let uncompressed_key = ECDsa::derive_public_key(&private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     let signature = ECDsa::sign(message, &private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     // Both key formats should verify the same signature
     let compressed_valid = ECDsa::verify(message, &signature, &compressed_key).unwrap();
     let uncompressed_valid = ECDsa::verify(message, &signature, &uncompressed_key).unwrap();
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:70:
[31m-    
(B[m[31m-    assert!(compressed_valid, "Signature should verify with compressed key");
(B[m[31m-    assert!(uncompressed_valid, "Signature should verify with uncompressed key");
(B[m[32m+
(B[m[32m+    assert!(
(B[m[32m+        compressed_valid,
(B[m[32m+        "Signature should verify with compressed key"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        uncompressed_valid,
(B[m[32m+        "Signature should verify with uncompressed key"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:77:
     // Test deterministic signature generation like C# UT_Crypto.TestDeterministicSignatures
     let message = b"Deterministic signature test";
     let private_key = [0x01u8; 32]; // Fixed private key for deterministic testing
[31m-    
(B[m[32m+
(B[m     let signature1 = ECDsa::sign(message, &private_key).unwrap();
     let signature2 = ECDsa::sign(message, &private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     // With deterministic signing (RFC 6979), signatures should be identical
[31m-    assert_eq!(signature1, signature2, "Deterministic signatures should be identical");
(B[m[32m+    assert_eq!(
(B[m[32m+        signature1, signature2,
(B[m[32m+        "Deterministic signatures should be identical"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:91:
     let empty_message = b"";
     let private_key = ECDsa::generate_private_key();
     let public_key = ECDsa::derive_public_key(&private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     let signature = ECDsa::sign(empty_message, &private_key).unwrap();
     let is_valid = ECDsa::verify(empty_message, &signature, &public_key).unwrap();
[31m-    
(B[m[32m+
(B[m     assert!(is_valid, "Empty message signature should be valid");
 }
 
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:104:
     let large_message = vec![0x42u8; 10000]; // 10KB message
     let private_key = ECDsa::generate_private_key();
     let public_key = ECDsa::derive_public_key(&private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     let signature = ECDsa::sign(&large_message, &private_key).unwrap();
     let is_valid = ECDsa::verify(&large_message, &signature, &public_key).unwrap();
[31m-    
(B[m[32m+
(B[m     assert!(is_valid, "Large message signature should be valid");
 }
 
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:120:
     // Test key validation functions
     let valid_private = ECDsa::generate_private_key();
     let valid_public = ECDsa::derive_public_key(&valid_private).unwrap();
[31m-    
(B[m[31m-    assert!(ECDsa::validate_private_key(&valid_private), "Valid private key should pass validation");
(B[m[31m-    assert!(ECDsa::validate_public_key(&valid_public), "Valid public key should pass validation");
(B[m[31m-    
(B[m[32m+
(B[m[32m+    assert!(
(B[m[32m+        ECDsa::validate_private_key(&valid_private),
(B[m[32m+        "Valid private key should pass validation"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        ECDsa::validate_public_key(&valid_public),
(B[m[32m+        "Valid public key should pass validation"
(B[m[32m+    );
(B[m[32m+
(B[m     // Test invalid keys
     let invalid_private = [0u8; 32]; // All zeros should be invalid
[31m-    assert!(!ECDsa::validate_private_key(&invalid_private), "All-zero private key should be invalid");
(B[m[32m+    assert!(
(B[m[32m+        !ECDsa::validate_private_key(&invalid_private),
(B[m[32m+        "All-zero private key should be invalid"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:135:
     let message = b"Format compatibility test";
     let private_key = ECDsa::generate_private_key();
     let public_key = ECDsa::derive_public_key(&private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     // Test DER format
     let der_signature = ECDsa::sign(message, &private_key).unwrap();
     let der_valid = ECDsa::verify(message, &der_signature, &public_key).unwrap();
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:142:
     assert!(der_valid, "DER format signature should be valid");
[31m-    
(B[m[32m+
(B[m     // Test Neo format (64-byte r+s)
     let neo_signature = ECDsa::sign_neo_format(message, &private_key).unwrap();
     let neo_valid = ECDsa::verify_neo_format(message, &neo_signature, &public_key).unwrap();
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:153:
     let message = b"secp256r1 verification test";
     let private_key = ECDsa::generate_private_key();
     let public_key = ECDsa::derive_public_key(&private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     let signature = ECDsa::sign(message, &private_key).unwrap();
     let is_valid = ECDsa::verify_signature_secp256r1(message, &signature, &public_key).unwrap();
[31m-    
(B[m[32m+
(B[m     assert!(is_valid, "secp256r1 signature should verify correctly");
 }
 
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:165:
     // Test RFC 6979 deterministic signatures
     let message = b"RFC 6979 deterministic test";
     let private_key = [0x42u8; 32]; // Fixed private key
[31m-    
(B[m[32m+
(B[m     let signature1 = ECDsa::sign_deterministic(message, &private_key).unwrap();
     let signature2 = ECDsa::sign_deterministic(message, &private_key).unwrap();
[31m-    
(B[m[31m-    assert_eq!(signature1, signature2, "RFC 6979 signatures should be deterministic");
(B[m[32m+
(B[m[32m+    assert_eq!(
(B[m[32m+        signature1, signature2,
(B[m[32m+        "RFC 6979 signatures should be deterministic"
(B[m[32m+    );
(B[m }
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:182:
     let message = b"Batch verification test";
     let mut signatures = Vec::new();
     let mut public_keys = Vec::new();
[31m-    
(B[m[32m+
(B[m     // Generate multiple signatures
     for _ in 0..5 {
         let private_key = ECDsa::generate_private_key();
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:189:
         let public_key = ECDsa::derive_public_key(&private_key).unwrap();
         let signature = ECDsa::sign(message, &private_key).unwrap();
[31m-        
(B[m[32m+
(B[m         signatures.push(signature);
         public_keys.push(public_key);
     }
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:195:
[31m-    
(B[m[32m+
(B[m     // Verify all signatures
     for (signature, public_key) in signatures.iter().zip(public_keys.iter()) {
         let is_valid = ECDsa::verify(message, signature, public_key).unwrap();
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:206:
     let message = b"Malleability protection test";
     let private_key = ECDsa::generate_private_key();
     let public_key = ECDsa::derive_public_key(&private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     let signature = ECDsa::sign(message, &private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     // Verify original signature
     let is_valid = ECDsa::verify(message, &signature, &public_key).unwrap();
     assert!(is_valid, "Original signature should be valid");
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:215:
[31m-    
(B[m[32m+
(B[m     // Test that signature format prevents malleability
     // (Implementation detail: Neo should use low-S signatures)
[31m-    assert!(signature.len() >= 64, "Signature should have minimum length");
(B[m[32m+    assert!(
(B[m[32m+        signature.len() >= 64,
(B[m[32m+        "Signature should have minimum length"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:225:
     let message_hash = hash256(message); // Create proper hash for recovery
     let private_key = ECDsa::generate_private_key();
     let expected_public_key = ECDsa::derive_public_key(&private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     // Create Neo format signature for recovery
     let neo_signature = ECDsa::sign_neo_format(&message_hash, &private_key).unwrap();
[31m-    
(B[m[32m+
(B[m     // Test recovery with different recovery IDs
     for recovery_id in 0..=3 {
[31m-        if let Ok(recovered_key) = ECDsa::recover_public_key(&message_hash, &neo_signature, recovery_id) {
(B[m[32m+        if let Ok(recovered_key) =
(B[m[32m+            ECDsa::recover_public_key(&message_hash, &neo_signature, recovery_id)
(B[m[32m+        {
(B[m             // If recovery succeeds, verify it's a valid public key
[31m-            assert!(ECDsa::validate_public_key(&recovered_key), 
(B[m[31m-                   "Recovered public key should be valid for recovery_id {}", recovery_id);
(B[m[32m+            assert!(
(B[m[32m+                ECDsa::validate_public_key(&recovered_key),
(B[m[32m+                "Recovered public key should be valid for recovery_id {}",
(B[m[32m+                recovery_id
(B[m[32m+            );
(B[m         }
         // Note: Recovery may not always succeed for all IDs, which is normal
     }
Diff in /home/ubuntu/neo-rs/crates/cryptography/tests/signature_comprehensive_tests.rs:241:
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/ledger/src/block/block.rs:3:
 //! This module implements the Block structure exactly matching C# Neo's Block.cs.
 //! It provides full block validation, transaction management, and size calculations.
 
[31m-use super::{
(B[m[31m-    header::BlockHeader, MAX_BLOCK_SIZE, MAX_TRANSACTIONS_PER_BLOCK,
(B[m[31m-};
(B[m[32m+use super::{header::BlockHeader, MAX_BLOCK_SIZE, MAX_TRANSACTIONS_PER_BLOCK};
(B[m use crate::{Result, VerifyResult};
 use neo_config::{ADDRESS_SIZE, MAX_SCRIPT_SIZE, MAX_TRANSACTION_SIZE};
 use neo_core::{Transaction, UInt160, UInt256};
Diff in /home/ubuntu/neo-rs/crates/ledger/src/block/block.rs:12:
 use neo_cryptography::MerkleTree;
[31m-use p256::{EncodedPoint, ecdsa::{Signature, VerifyingKey, signature::Verifier}};
(B[m[32m+use p256::{
(B[m[32m+    ecdsa::{signature::Verifier, Signature, VerifyingKey},
(B[m[32m+    EncodedPoint,
(B[m[32m+};
(B[m use serde::{Deserialize, Serialize};
 use std::collections::HashSet;
 
Diff in /home/ubuntu/neo-rs/crates/ledger/src/blockchain/state.rs:13:
 // Temporarily disabled smart contract imports due to compilation issues
 // use neo_smart_contract::{
 //     ContractState, ContractManifest, NefFile, ContractGroup, ContractAbi, ContractPermission,
[31m-//     ContractParameterType, ContractMethodDescriptor, ContractEventDescriptor, 
(B[m[32m+//     ContractParameterType, ContractMethodDescriptor, ContractEventDescriptor,
(B[m //     ContractParameterDefinition, MethodToken, PermissionContract
 // };
 use std::collections::HashMap;
Diff in /home/ubuntu/neo-rs/crates/ledger/src/lib.rs:420:
 /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
 /// let config = LedgerConfig::default();
 /// let ledger = Arc::new(Ledger::new(config).await?);
[31m-/// 
(B[m[32m+///
(B[m /// // Share ledger across threads
 /// let ledger_clone = Arc::clone(&ledger);
 /// tokio::spawn(async move {
Diff in /home/ubuntu/neo-rs/crates/ledger/src/mempool.rs:319:
     pub fn new(config: MempoolConfig) -> Self {
         // Pre-allocate collections based on expected capacity
         let initial_capacity = (config.max_transactions / 4).max(1000);
[31m-        
(B[m[32m+
(B[m         Self {
             config,
             transactions: Arc::new(RwLock::new(HashMap::with_capacity(initial_capacity))),
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:1:
 //! State transition tests - Converted from C# Neo ledger state management tests
 //! Addresses the 34 missing state transition tests identified in analysis
 
[31m-use neo_ledger::{Blockchain, Block, BlockHeader as Header, MemoryPool as MemPool, NetworkType};
(B[m use neo_core::{Transaction, UInt256};
[32m+use neo_ledger::{Block, BlockHeader as Header, Blockchain, MemoryPool as MemPool, NetworkType};
(B[m use std::sync::Arc;
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:12:
 #[tokio::test]
 async fn test_genesis_block_state_initialization() {
     // Test genesis block state initialization like C# UT_Blockchain.TestGenesisState
[31m-    let blockchain = Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-genesis")).await.unwrap();
(B[m[31m-    
(B[m[32m+    let blockchain =
(B[m[32m+        Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-genesis"))
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m[32m+
(B[m     // Verify genesis block state
     let height = blockchain.get_height().await;
     assert_eq!(height, 0, "Genesis block should have height 0");
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:20:
[31m-    
(B[m[32m+
(B[m     // Verify genesis block exists
     let genesis_block = blockchain.get_block(0).await.unwrap();
     assert!(genesis_block.is_some(), "Genesis block should exist");
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:24:
[31m-    
(B[m[32m+
(B[m     if let Some(genesis) = genesis_block {
         assert_eq!(genesis.header.index, 0, "Genesis block index should be 0");
         // Genesis block should have valid structure
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:28:
[31m-        assert!(genesis.transactions.len() >= 0, "Genesis block should have transactions");
(B[m[32m+        assert!(
(B[m[32m+            genesis.transactions.len() >= 0,
(B[m[32m+            "Genesis block should have transactions"
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:32:
 #[tokio::test]
 async fn test_block_state_transition() {
     // Test block state transitions like C# UT_Blockchain.TestBlockTransition
[31m-    let blockchain = Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-transition")).await.unwrap();
(B[m[32m+    let blockchain =
(B[m[32m+        Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-transition"))
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m     let initial_height = blockchain.get_height().await;
     let initial_hash = blockchain.get_best_block_hash().await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Create a test block with valid transactions
     let test_block = create_test_block(initial_height + 1, &blockchain).await;
[31m-    
(B[m[32m+
(B[m     // Apply block and verify state transition
     let result = blockchain.add_block_with_fork_detection(&test_block).await;
[31m-    
(B[m[32m+
(B[m     // For testing purposes, we verify the attempt was made
     // In real implementation, this would require proper validation
     if result.is_ok() {
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:48:
         // Verify height increased
         let new_height = blockchain.get_height().await;
         assert!(new_height >= initial_height, "Height should not decrease");
[31m-        
(B[m[32m+
(B[m         // Verify hash changed if block was added
         let new_hash = blockchain.get_best_block_hash().await.unwrap();
         // Hash might be same if block was rejected, which is fine for test
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:55:
     }
[31m-    
(B[m[32m+
(B[m     // Test completed successfully - block transition attempt was made
     assert!(true, "Block transition test completed");
 }
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:61:
 #[tokio::test]
 async fn test_invalid_block_rejection() {
     // Test invalid block rejection like C# UT_Blockchain.TestInvalidBlockRejection
[31m-    let blockchain = Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-invalid")).await.unwrap();
(B[m[32m+    let blockchain =
(B[m[32m+        Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-invalid"))
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m     let initial_height = blockchain.get_height().await;
     let initial_hash = blockchain.get_best_block_hash().await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Create invalid block (wrong height - skip a height)
     let invalid_block = create_test_block(initial_height + 2, &blockchain).await; // Skip height
[31m-    
(B[m[32m+
(B[m     // Attempt to add invalid block
[31m-    let result = blockchain.add_block_with_fork_detection(&invalid_block).await;
(B[m[31m-    
(B[m[32m+    let result = blockchain
(B[m[32m+        .add_block_with_fork_detection(&invalid_block)
(B[m[32m+        .await;
(B[m[32m+
(B[m     // Invalid block should be rejected (though error handling might vary)
     // The key test is that blockchain state remains consistent
     let final_height = blockchain.get_height().await;
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:77:
     let final_hash = blockchain.get_best_block_hash().await.unwrap();
[31m-    
(B[m[32m+
(B[m     // State should be unchanged or only validly changed
[31m-    assert_eq!(final_height, initial_height, 
(B[m[31m-              "Height should not change for skipped height block");
(B[m[31m-    assert_eq!(final_hash, initial_hash, 
(B[m[31m-              "Best block hash should not change for invalid block");
(B[m[32m+    assert_eq!(
(B[m[32m+        final_height, initial_height,
(B[m[32m+        "Height should not change for skipped height block"
(B[m[32m+    );
(B[m[32m+    assert_eq!(
(B[m[32m+        final_hash, initial_hash,
(B[m[32m+        "Best block hash should not change for invalid block"
(B[m[32m+    );
(B[m }
 
 #[tokio::test]
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:87:
 async fn test_transaction_state_effects() {
     // Test transaction effects on state like C# UT_Blockchain.TestTransactionEffects
[31m-    let blockchain = Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-tx-effects")).await.unwrap();
(B[m[32m+    let blockchain =
(B[m[32m+        Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-tx-effects"))
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m     let sender_script_hash = UInt256::from([1u8; 32]);
     let recipient_script_hash = UInt256::from([2u8; 32]);
[31m-    
(B[m[32m+
(B[m     // Get initial state
     let initial_height = blockchain.get_height().await;
[31m-    
(B[m[32m+
(B[m     // Create transaction that transfers value
[31m-    let transfer_tx = create_transfer_transaction(&sender_script_hash, &recipient_script_hash, 1000);
(B[m[31m-    let block_with_tx = create_block_with_transaction(initial_height + 1, &blockchain, transfer_tx).await;
(B[m[31m-    
(B[m[32m+    let transfer_tx =
(B[m[32m+        create_transfer_transaction(&sender_script_hash, &recipient_script_hash, 1000);
(B[m[32m+    let block_with_tx =
(B[m[32m+        create_block_with_transaction(initial_height + 1, &blockchain, transfer_tx).await;
(B[m[32m+
(B[m     // Apply block with transaction
[31m-    let result = blockchain.add_block_with_fork_detection(&block_with_tx).await;
(B[m[31m-    
(B[m[32m+    let result = blockchain
(B[m[32m+        .add_block_with_fork_detection(&block_with_tx)
(B[m[32m+        .await;
(B[m[32m+
(B[m     // For testing purposes, we verify the blockchain handled the transaction attempt
     // In a real implementation with full state management, we would verify balance changes
     let final_height = blockchain.get_height().await;
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:106:
[31m-    
(B[m[32m+
(B[m     // Test that the blockchain processed the block attempt
     // The actual state effects would depend on full transaction processing implementation
[31m-    assert!(final_height >= initial_height, "Blockchain should maintain consistent height");
(B[m[32m+    assert!(
(B[m[32m+        final_height >= initial_height,
(B[m[32m+        "Blockchain should maintain consistent height"
(B[m[32m+    );
(B[m     assert!(true, "Transaction state effects test completed");
 }
 
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:113:
 #[tokio::test]
 async fn test_mempool_state_synchronization() {
     // Test mempool state synchronization like C# UT_MemPool.TestStateSynchronization
[31m-    let blockchain = Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-mempool")).await.unwrap();
(B[m[32m+    let blockchain =
(B[m[32m+        Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-mempool"))
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m     let mut mempool = MemPool::new();
[31m-    
(B[m[32m+
(B[m     // Add transaction to mempool
     let test_tx = create_test_transaction();
     let tx_hash = test_tx.hash();
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:122:
[31m-    
(B[m[32m+
(B[m     // Try to add transaction to mempool (may require specific validation)
     let initial_size = mempool.get_transaction_count();
[31m-    
(B[m[32m+
(B[m     // For testing purposes, we create a basic mempool interaction
     // In real implementation, this would validate and add the transaction
[31m-    
(B[m[32m+
(B[m     // Create block that includes the transaction
     let initial_height = blockchain.get_height().await;
[31m-    let block_with_tx = create_block_with_transaction(
(B[m[31m-        initial_height + 1, 
(B[m[31m-        &blockchain, 
(B[m[31m-        test_tx
(B[m[31m-    ).await;
(B[m[31m-    
(B[m[32m+    let block_with_tx =
(B[m[32m+        create_block_with_transaction(initial_height + 1, &blockchain, test_tx).await;
(B[m[32m+
(B[m     // Add block to blockchain
[31m-    let result = blockchain.add_block_with_fork_detection(&block_with_tx).await;
(B[m[31m-    
(B[m[32m+    let result = blockchain
(B[m[32m+        .add_block_with_fork_detection(&block_with_tx)
(B[m[32m+        .await;
(B[m[32m+
(B[m     // Verify mempool can be updated with blockchain state
     let final_height = blockchain.get_height().await;
[31m-    
(B[m[32m+
(B[m     // Test that mempool state synchronization attempt was made
[31m-    assert!(final_height >= initial_height, "Blockchain height should be consistent");
(B[m[31m-    assert!(mempool.get_transaction_count() >= 0, "Mempool should maintain valid state");
(B[m[32m+    assert!(
(B[m[32m+        final_height >= initial_height,
(B[m[32m+        "Blockchain height should be consistent"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        mempool.get_transaction_count() >= 0,
(B[m[32m+        "Mempool should maintain valid state"
(B[m[32m+    );
(B[m }
 
 #[tokio::test]
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:149:
 async fn test_state_rollback() {
     // Test state rollback functionality like C# UT_Blockchain.TestStateRollback
[31m-    let blockchain = Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-rollback")).await.unwrap();
(B[m[32m+    let blockchain =
(B[m[32m+        Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-rollback"))
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m     let checkpoint_height = blockchain.get_height().await;
     let checkpoint_hash = blockchain.get_best_block_hash().await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Add several blocks
     for i in 1..=3 {
         let test_block = create_test_block(checkpoint_height + i, &blockchain).await;
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:158:
         let _result = blockchain.add_block_with_fork_detection(&test_block).await;
         // Note: Blocks may or may not be added depending on validation
     }
[31m-    
(B[m[32m+
(B[m     // Verify current state
     let current_height = blockchain.get_height().await;
     let current_hash = blockchain.get_best_block_hash().await.unwrap();
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:165:
[31m-    
(B[m[32m+
(B[m     // For testing purposes, we verify the blockchain maintains consistency
     // In a full implementation, rollback would restore previous state
[31m-    assert!(current_height >= checkpoint_height, 
(B[m[31m-           "Height should not go below checkpoint");
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        current_height >= checkpoint_height,
(B[m[32m+        "Height should not go below checkpoint"
(B[m[32m+    );
(B[m[32m+
(B[m     // Test that blockchain state management works
     // Actual rollback implementation would restore checkpoint_height and checkpoint_hash
[31m-    assert!(true, "State rollback test demonstrates blockchain consistency");
(B[m[32m+    assert!(
(B[m[32m+        true,
(B[m[32m+        "State rollback test demonstrates blockchain consistency"
(B[m[32m+    );
(B[m }
 
 #[tokio::test]
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:177:
 async fn test_concurrent_state_access() {
     // Test concurrent state access like C# UT_Blockchain.TestConcurrentAccess
     use tokio::task;
[31m-    
(B[m[31m-    let blockchain = Arc::new(Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-concurrent")).await.unwrap());
(B[m[32m+
(B[m[32m+    let blockchain = Arc::new(
(B[m[32m+        Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-concurrent"))
(B[m[32m+            .await
(B[m[32m+            .unwrap(),
(B[m[32m+    );
(B[m     let mut handles = vec![];
[31m-    
(B[m[32m+
(B[m     // Spawn multiple async tasks accessing state concurrently
     for i in 0..5 {
         let blockchain_clone = Arc::clone(&blockchain);
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:190:
                 let _height = blockchain_clone.get_height().await;
                 let _best_hash = blockchain_clone.get_best_block_hash().await;
                 let _genesis_block = blockchain_clone.get_block(0).await;
[31m-                
(B[m[32m+
(B[m                 // Simulate some async work
                 tokio::time::sleep(std::time::Duration::from_millis(1)).await;
[31m-                
(B[m[32m+
(B[m                 // Verify consistency
                 let current_height = blockchain_clone.get_height().await;
[31m-                assert!(current_height >= 0, 
(B[m[31m-                       "Height should be non-negative in task {} iteration {}", i, j);
(B[m[32m+                assert!(
(B[m[32m+                    current_height >= 0,
(B[m[32m+                    "Height should be non-negative in task {} iteration {}",
(B[m[32m+                    i,
(B[m[32m+                    j
(B[m[32m+                );
(B[m             }
         });
         handles.push(handle);
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:204:
     }
[31m-    
(B[m[32m+
(B[m     // Wait for all tasks to complete
     for handle in handles {
         handle.await.expect("Task should complete successfully");
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:214:
     // Test state persistence and recovery like C# UT_Blockchain.TestPersistenceRecovery
     let checkpoint_height;
     let checkpoint_hash;
[31m-    
(B[m[32m+
(B[m     // Create blockchain and add blocks
     {
[31m-        let blockchain = Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-persistence-1")).await.unwrap();
(B[m[31m-        
(B[m[32m+        let blockchain =
(B[m[32m+            Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-persistence-1"))
(B[m[32m+                .await
(B[m[32m+                .unwrap();
(B[m[32m+
(B[m         // Add test blocks
         for i in 1..=5 {
             let current_height = blockchain.get_height().await;
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:225:
             let test_block = create_test_block(current_height + 1, &blockchain).await;
             let _result = blockchain.add_block_with_fork_detection(&test_block).await;
         }
[31m-        
(B[m[32m+
(B[m         checkpoint_height = blockchain.get_height().await;
         checkpoint_hash = blockchain.get_best_block_hash().await.unwrap();
     } // blockchain dropped here
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:232:
[31m-    
(B[m[32m+
(B[m     // Create new blockchain instance (simulating recovery)
     {
[31m-        let recovered_blockchain = Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-persistence-2")).await.unwrap();
(B[m[31m-        
(B[m[32m+        let recovered_blockchain =
(B[m[32m+            Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-persistence-2"))
(B[m[32m+                .await
(B[m[32m+                .unwrap();
(B[m[32m+
(B[m         // Verify blockchain can be created successfully
         let recovered_height = recovered_blockchain.get_height().await;
         let recovered_hash = recovered_blockchain.get_best_block_hash().await.unwrap();
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:240:
[31m-        
(B[m[32m+
(B[m         // For testing purposes, verify blockchain consistency
         // In full implementation, this would verify actual persistence/recovery
[31m-        assert!(recovered_height >= 0, "Recovered blockchain should have valid height");
(B[m[31m-        assert!(!recovered_hash.to_string().is_empty(), "Recovered blockchain should have valid hash");
(B[m[31m-        
(B[m[32m+        assert!(
(B[m[32m+            recovered_height >= 0,
(B[m[32m+            "Recovered blockchain should have valid height"
(B[m[32m+        );
(B[m[32m+        assert!(
(B[m[32m+            !recovered_hash.to_string().is_empty(),
(B[m[32m+            "Recovered blockchain should have valid hash"
(B[m[32m+        );
(B[m[32m+
(B[m         // Verify genesis block exists in recovered blockchain
         let genesis = recovered_blockchain.get_block(0).await.unwrap();
[31m-        assert!(genesis.is_some(), "Genesis block should exist after recovery");
(B[m[32m+        assert!(
(B[m[32m+            genesis.is_some(),
(B[m[32m+            "Genesis block should exist after recovery"
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:252:
 #[tokio::test]
 async fn test_state_merkle_proof_validation() {
     // Test state merkle proof validation like C# UT_Blockchain.TestMerkleProofValidation
[31m-    let blockchain = Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-merkle")).await.unwrap();
(B[m[32m+    let blockchain = Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-merkle"))
(B[m[32m+        .await
(B[m[32m+        .unwrap();
(B[m     let test_key = UInt256::from([3u8; 32]);
[31m-    
(B[m[32m+
(B[m     // For testing purposes, we verify blockchain state access
     let current_height = blockchain.get_height().await;
     let best_hash = blockchain.get_best_block_hash().await.unwrap();
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:261:
[31m-    
(B[m[32m+
(B[m     // In a full implementation, this would test merkle proof generation and verification
     // For now, we test that blockchain state is accessible and consistent
     assert!(current_height >= 0, "Blockchain should have valid height");
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:265:
[31m-    assert!(!best_hash.to_string().is_empty(), "Blockchain should have valid best hash");
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        !best_hash.to_string().is_empty(),
(B[m[32m+        "Blockchain should have valid best hash"
(B[m[32m+    );
(B[m[32m+
(B[m     // Test merkle root calculation for empty transaction set
     let empty_transactions = vec![];
     let merkle_root = calculate_merkle_root(&empty_transactions);
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:270:
[31m-    assert_eq!(merkle_root, UInt256::zero(), "Empty transaction set should have zero merkle root");
(B[m[31m-    
(B[m[32m+    assert_eq!(
(B[m[32m+        merkle_root,
(B[m[32m+        UInt256::zero(),
(B[m[32m+        "Empty transaction set should have zero merkle root"
(B[m[32m+    );
(B[m[32m+
(B[m     // Test merkle root calculation for transaction set
     let test_tx = create_test_transaction();
     let tx_set = vec![test_tx];
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:275:
     let tx_merkle_root = calculate_merkle_root(&tx_set);
[31m-    assert_ne!(tx_merkle_root, UInt256::zero(), "Non-empty transaction set should have non-zero merkle root");
(B[m[32m+    assert_ne!(
(B[m[32m+        tx_merkle_root,
(B[m[32m+        UInt256::zero(),
(B[m[32m+        "Non-empty transaction set should have non-zero merkle root"
(B[m[32m+    );
(B[m }
 
 #[tokio::test]
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:280:
 async fn test_state_snapshot_consistency() {
     // Test state snapshot consistency like C# UT_Blockchain.TestSnapshotConsistency
[31m-    let blockchain = Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-snapshot")).await.unwrap();
(B[m[32m+    let blockchain =
(B[m[32m+        Blockchain::new_with_storage_suffix(NetworkType::TestNet, Some("test-snapshot"))
(B[m[32m+            .await
(B[m[32m+            .unwrap();
(B[m     let initial_height = blockchain.get_height().await;
     let initial_hash = blockchain.get_best_block_hash().await.unwrap();
[31m-    
(B[m[32m+
(B[m     // Take initial "snapshot" (best hash represents state)
     let snapshot1_hash = initial_hash;
[31m-    
(B[m[32m+
(B[m     // Add block and take another "snapshot"
     let test_block = create_test_block(initial_height + 1, &blockchain).await;
     let _add_result = blockchain.add_block_with_fork_detection(&test_block).await;
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:292:
[31m-    
(B[m[32m+
(B[m     let final_height = blockchain.get_height().await;
     let snapshot2_hash = blockchain.get_best_block_hash().await.unwrap();
[31m-    
(B[m[32m+
(B[m     // For testing purposes, verify state management consistency
     assert!(final_height >= initial_height, "Height should not decrease");
[31m-    
(B[m[32m+
(B[m     // Verify blockchain maintains consistent state representation
[31m-    assert!(!snapshot1_hash.to_string().is_empty(), "Initial state should have valid representation");
(B[m[31m-    assert!(!snapshot2_hash.to_string().is_empty(), "Final state should have valid representation");
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        !snapshot1_hash.to_string().is_empty(),
(B[m[32m+        "Initial state should have valid representation"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        !snapshot2_hash.to_string().is_empty(),
(B[m[32m+        "Final state should have valid representation"
(B[m[32m+    );
(B[m[32m+
(B[m     // Test demonstrates blockchain state snapshot functionality
     assert!(true, "State snapshot consistency test completed");
 }
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:311:
 async fn create_test_block(height: u32, blockchain: &Blockchain) -> Block {
     let mut header = Header::default();
     header.index = height;
[31m-    header.previous_hash = if height > 0 { 
(B[m[32m+    header.previous_hash = if height > 0 {
(B[m         // Get previous block hash if available
         if let Ok(Some(prev_block)) = blockchain.get_block(height - 1).await {
             prev_block.hash()
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:318:
         } else {
             UInt256::zero()
         }
[31m-    } else { 
(B[m[31m-        UInt256::zero() 
(B[m[32m+    } else {
(B[m[32m+        UInt256::zero()
(B[m     };
     header.timestamp = std::time::SystemTime::now()
         .duration_since(std::time::UNIX_EPOCH)
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:326:
         .unwrap()
         .as_secs();
[31m-    
(B[m[32m+
(B[m     Block {
         header,
         transactions: vec![], // Empty block for basic testing
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:345:
     tx
 }
 
[31m-async fn create_block_with_transaction(height: u32, blockchain: &Blockchain, transaction: Transaction) -> Block {
(B[m[32m+async fn create_block_with_transaction(
(B[m[32m+    height: u32,
(B[m[32m+    blockchain: &Blockchain,
(B[m[32m+    transaction: Transaction,
(B[m[32m+) -> Block {
(B[m     let mut block = create_test_block(height, blockchain).await;
     block.transactions = vec![transaction];
[31m-    
(B[m[32m+
(B[m     // Recalculate merkle root with transactions
     block.header.merkle_root = calculate_merkle_root(&block.transactions);
[31m-    
(B[m[32m+
(B[m     block
 }
 
Diff in /home/ubuntu/neo-rs/crates/ledger/tests/state_transitions_tests.rs:364:
         UInt256::from([transactions.len() as u8; 32])
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/mpt_trie/tests/proof_tests.rs:82:
             ProofVerifier::verify_inclusion(&root_hash, &key, &value, &proof).unwrap();
 
         // verify_inclusion returns bool, not Option
[31m-        assert!(verification_result, "Proof verification should succeed for existing key");
(B[m[32m+        assert!(
(B[m[32m+            verification_result,
(B[m[32m+            "Proof verification should succeed for existing key"
(B[m[32m+        );
(B[m     }
 
     /// Test proof verification for invalid proofs (matches C# invalid proof handling exactly)
Diff in /home/ubuntu/neo-rs/crates/mpt_trie/tests/proof_tests.rs:186:
             assert!(!proof.is_empty());
 
             // Verify each proof
[31m-            let is_valid = ProofVerifier::verify_inclusion(&root_hash, key, expected_value, &proof).unwrap();
(B[m[31m-            assert!(is_valid, "Proof verification should succeed for key: {:?}", key);
(B[m[32m+            let is_valid =
(B[m[32m+                ProofVerifier::verify_inclusion(&root_hash, key, expected_value, &proof).unwrap();
(B[m[32m+            assert!(
(B[m[32m+                is_valid,
(B[m[32m+                "Proof verification should succeed for key: {:?}",
(B[m[32m+                key
(B[m[32m+            );
(B[m         }
 
         let non_existing = b"complex_prefix_xyz";
Diff in /home/ubuntu/neo-rs/crates/mpt_trie/tests/proof_tests.rs:221:
             ProofVerifier::verify_inclusion(&root_hash, &key, &value, &deserialized_proof).unwrap();
 
         // verify_inclusion returns bool
[31m-        assert!(verification_result, "Deserialized proof should verify successfully");
(B[m[32m+        assert!(
(B[m[32m+            verification_result,
(B[m[32m+            "Deserialized proof should verify successfully"
(B[m[32m+        );
(B[m     }
 
     /// Test proof node types and structure (matches C# ProofNode structure exactly)
Diff in /home/ubuntu/neo-rs/crates/mpt_trie/tests/proof_tests.rs:82:
             ProofVerifier::verify_inclusion(&root_hash, &key, &value, &proof).unwrap();
 
         // verify_inclusion returns bool, not Option
[31m-        assert!(verification_result, "Proof verification should succeed for existing key");
(B[m[32m+        assert!(
(B[m[32m+            verification_result,
(B[m[32m+            "Proof verification should succeed for existing key"
(B[m[32m+        );
(B[m     }
 
     /// Test proof verification for invalid proofs (matches C# invalid proof handling exactly)
Diff in /home/ubuntu/neo-rs/crates/mpt_trie/tests/proof_tests.rs:186:
             assert!(!proof.is_empty());
 
             // Verify each proof
[31m-            let is_valid = ProofVerifier::verify_inclusion(&root_hash, key, expected_value, &proof).unwrap();
(B[m[31m-            assert!(is_valid, "Proof verification should succeed for key: {:?}", key);
(B[m[32m+            let is_valid =
(B[m[32m+                ProofVerifier::verify_inclusion(&root_hash, key, expected_value, &proof).unwrap();
(B[m[32m+            assert!(
(B[m[32m+                is_valid,
(B[m[32m+                "Proof verification should succeed for key: {:?}",
(B[m[32m+                key
(B[m[32m+            );
(B[m         }
 
         let non_existing = b"complex_prefix_xyz";
Diff in /home/ubuntu/neo-rs/crates/mpt_trie/tests/proof_tests.rs:221:
             ProofVerifier::verify_inclusion(&root_hash, &key, &value, &deserialized_proof).unwrap();
 
         // verify_inclusion returns bool
[31m-        assert!(verification_result, "Deserialized proof should verify successfully");
(B[m[32m+        assert!(
(B[m[32m+            verification_result,
(B[m[32m+            "Deserialized proof should verify successfully"
(B[m[32m+        );
(B[m     }
 
     /// Test proof node types and structure (matches C# ProofNode structure exactly)
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:1:
 //! DOS Protection and Rate Limiting Module
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides protection against denial-of-service attacks
 //! by implementing rate limiting, connection throttling, and resource management.
 
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:8:
 use std::sync::Arc;
 use std::time::{Duration, Instant};
 use tokio::sync::RwLock;
[31m-use tracing::{debug, warn, error};
(B[m[32m+use tracing::{debug, error, warn};
(B[m 
 /// DOS protection configuration
 #[derive(Debug, Clone)]
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:38:
             max_messages_per_second: 100,
             ban_duration: Duration::from_secs(3600), // 1 hour
             max_pending_connections: 50,
[31m-            connection_rate_limit: 60, // 60 connections per minute
(B[m[32m+            connection_rate_limit: 60,          // 60 connections per minute
(B[m             max_message_size: 10 * 1024 * 1024, // 10MB
             auto_ban_enabled: true,
             whitelisted_ips: Vec::new(),
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:92:
             config: config.clone(),
             peer_stats: Arc::new(RwLock::new(HashMap::new())),
             global_connection_count: Arc::new(RwLock::new(0)),
[31m-            connection_rate_limiter: Arc::new(RwLock::new(
(B[m[31m-                RateLimiter::new(config.connection_rate_limit, Duration::from_secs(60))
(B[m[31m-            )),
(B[m[32m+            connection_rate_limiter: Arc::new(RwLock::new(RateLimiter::new(
(B[m[32m+                config.connection_rate_limit,
(B[m[32m+                Duration::from_secs(60),
(B[m[32m+            ))),
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     /// Check if an IP is whitelisted
     fn is_whitelisted(&self, ip: &IpAddr) -> bool {
         self.config.whitelisted_ips.contains(ip)
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:104:
     }
[31m-    
(B[m[32m+
(B[m     /// Check if a connection from an IP should be allowed
     pub async fn should_allow_connection(&self, ip: IpAddr) -> bool {
         // Always allow whitelisted IPs
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:109:
         if self.is_whitelisted(&ip) {
             return true;
         }
[31m-        
(B[m[32m+
(B[m         // Check global connection limit
         let global_count = *self.global_connection_count.read().await;
         if global_count >= self.config.max_pending_connections {
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:116:
             warn!("Global connection limit reached: {}", global_count);
             return false;
         }
[31m-        
(B[m[32m+
(B[m         // Check connection rate limit
         if !self.connection_rate_limiter.write().await.try_acquire() {
             warn!("Connection rate limit exceeded for global connections");
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:123:
             return false;
         }
[31m-        
(B[m[32m+
(B[m         // Check per-IP limits
         let mut stats = self.peer_stats.write().await;
         let peer_stat = stats.entry(ip).or_default();
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:129:
[31m-        
(B[m[32m+
(B[m         // Check if peer is banned
         if let Some(ban_until) = peer_stat.ban_until {
             if Instant::now() < ban_until {
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:138:
                 peer_stat.violations = 0;
             }
         }
[31m-        
(B[m[32m+
(B[m         // Check per-IP connection limit
         if peer_stat.connection_count >= self.config.max_connections_per_ip {
[31m-            warn!("Connection limit exceeded for IP {}: {}", ip, peer_stat.connection_count);
(B[m[32m+            warn!(
(B[m[32m+                "Connection limit exceeded for IP {}: {}",
(B[m[32m+                ip, peer_stat.connection_count
(B[m[32m+            );
(B[m             peer_stat.violations += 1;
[31m-            
(B[m[32m+
(B[m             // Auto-ban if too many violations
             if self.config.auto_ban_enabled && peer_stat.violations >= 5 {
                 peer_stat.ban_until = Some(Instant::now() + self.config.ban_duration);
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:150:
                 error!("IP {} has been banned for excessive violations", ip);
             }
[31m-            
(B[m[32m+
(B[m             return false;
         }
[31m-        
(B[m[32m+
(B[m         true
     }
[31m-    
(B[m[32m+
(B[m     /// Register a new connection
     pub async fn register_connection(&self, ip: IpAddr) {
         if !self.is_whitelisted(&ip) {
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:162:
             let mut stats = self.peer_stats.write().await;
             let peer_stat = stats.entry(ip).or_default();
             peer_stat.connection_count += 1;
[31m-            
(B[m[32m+
(B[m             let mut global_count = self.global_connection_count.write().await;
             *global_count += 1;
[31m-            
(B[m[31m-            debug!("Connection registered for IP {}: count = {}", ip, peer_stat.connection_count);
(B[m[32m+
(B[m[32m+            debug!(
(B[m[32m+                "Connection registered for IP {}: count = {}",
(B[m[32m+                ip, peer_stat.connection_count
(B[m[32m+            );
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     /// Unregister a connection
     pub async fn unregister_connection(&self, ip: IpAddr) {
         if !self.is_whitelisted(&ip) {
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:177:
             if let Some(peer_stat) = stats.get_mut(&ip) {
                 if peer_stat.connection_count > 0 {
                     peer_stat.connection_count -= 1;
[31m-                    
(B[m[32m+
(B[m                     let mut global_count = self.global_connection_count.write().await;
                     if *global_count > 0 {
                         *global_count -= 1;
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:184:
                     }
[31m-                    
(B[m[31m-                    debug!("Connection unregistered for IP {}: count = {}", ip, peer_stat.connection_count);
(B[m[31m-                    
(B[m[32m+
(B[m[32m+                    debug!(
(B[m[32m+                        "Connection unregistered for IP {}: count = {}",
(B[m[32m+                        ip, peer_stat.connection_count
(B[m[32m+                    );
(B[m[32m+
(B[m                     // Clean up entry if no connections and not banned
                     if peer_stat.connection_count == 0 && peer_stat.ban_until.is_none() {
                         stats.remove(&ip);
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:193:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Check if a message from a peer should be allowed
     pub async fn should_allow_message(&self, ip: IpAddr, message_size: usize) -> bool {
         // Always allow whitelisted IPs
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:200:
         if self.is_whitelisted(&ip) {
             return true;
         }
[31m-        
(B[m[32m+
(B[m         // Check message size
         if message_size > self.config.max_message_size {
[31m-            warn!("Message from {} exceeds size limit: {} bytes", ip, message_size);
(B[m[32m+            warn!(
(B[m[32m+                "Message from {} exceeds size limit: {} bytes",
(B[m[32m+                ip, message_size
(B[m[32m+            );
(B[m             self.record_violation(ip).await;
             return false;
         }
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:210:
[31m-        
(B[m[32m+
(B[m         let mut stats = self.peer_stats.write().await;
         let peer_stat = stats.entry(ip).or_default();
[31m-        
(B[m[32m+
(B[m         // Check if peer is banned
         if let Some(ban_until) = peer_stat.ban_until {
             if Instant::now() < ban_until {
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:220:
                 peer_stat.violations = 0;
             }
         }
[31m-        
(B[m[32m+
(B[m         // Reset window if needed
         let now = Instant::now();
         if now.duration_since(peer_stat.window_start) >= Duration::from_secs(1) {
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:227:
             peer_stat.message_count = 0;
             peer_stat.window_start = now;
         }
[31m-        
(B[m[32m+
(B[m         // Check message rate
         if peer_stat.message_count >= self.config.max_messages_per_second {
[31m-            warn!("Message rate limit exceeded for IP {}: {} msg/s", 
(B[m[31m-                ip, peer_stat.message_count);
(B[m[32m+            warn!(
(B[m[32m+                "Message rate limit exceeded for IP {}: {} msg/s",
(B[m[32m+                ip, peer_stat.message_count
(B[m[32m+            );
(B[m             peer_stat.violations += 1;
[31m-            
(B[m[32m+
(B[m             // Auto-ban if too many violations
             if self.config.auto_ban_enabled && peer_stat.violations >= 10 {
                 peer_stat.ban_until = Some(now + self.config.ban_duration);
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:240:
                 error!("IP {} has been banned for excessive message rate", ip);
             }
[31m-            
(B[m[32m+
(B[m             return false;
         }
[31m-        
(B[m[32m+
(B[m         peer_stat.message_count += 1;
         peer_stat.last_message_time = now;
[31m-        
(B[m[32m+
(B[m         true
     }
[31m-    
(B[m[32m+
(B[m     /// Record a violation for an IP
     async fn record_violation(&self, ip: IpAddr) {
         if !self.is_whitelisted(&ip) {
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:255:
             let mut stats = self.peer_stats.write().await;
             let peer_stat = stats.entry(ip).or_default();
             peer_stat.violations += 1;
[31m-            
(B[m[32m+
(B[m             if self.config.auto_ban_enabled && peer_stat.violations >= 3 {
                 peer_stat.ban_until = Some(Instant::now() + self.config.ban_duration);
                 error!("IP {} has been banned for violations", ip);
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:262:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Manually ban an IP address
     pub async fn ban_ip(&self, ip: IpAddr, duration: Duration) {
         if !self.is_whitelisted(&ip) {
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:272:
             error!("IP {} has been manually banned", ip);
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Unban an IP address
     pub async fn unban_ip(&self, ip: IpAddr) {
         let mut stats = self.peer_stats.write().await;
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:282:
             debug!("IP {} has been unbanned", ip);
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get current statistics
     pub async fn get_stats(&self) -> DosProtectionStats {
         let stats = self.peer_stats.read().await;
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:289:
         let global_connections = *self.global_connection_count.read().await;
[31m-        
(B[m[31m-        let banned_count = stats.values()
(B[m[31m-            .filter(|s| s.ban_until.is_some())
(B[m[31m-            .count();
(B[m[31m-        
(B[m[31m-        let active_peers = stats.values()
(B[m[31m-            .filter(|s| s.connection_count > 0)
(B[m[31m-            .count();
(B[m[31m-        
(B[m[32m+
(B[m[32m+        let banned_count = stats.values().filter(|s| s.ban_until.is_some()).count();
(B[m[32m+
(B[m[32m+        let active_peers = stats.values().filter(|s| s.connection_count > 0).count();
(B[m[32m+
(B[m         DosProtectionStats {
             total_peers: stats.len(),
             banned_peers: banned_count,
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:303:
             global_connections,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Clean up expired bans and inactive entries
     pub async fn cleanup(&self) {
         let mut stats = self.peer_stats.write().await;
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:310:
         let now = Instant::now();
[31m-        
(B[m[32m+
(B[m         stats.retain(|_ip, peer_stat| {
             // Keep if has connections or is currently banned
[31m-            peer_stat.connection_count > 0 || 
(B[m[31m-            (peer_stat.ban_until.is_some() && peer_stat.ban_until.unwrap() > now)
(B[m[32m+            peer_stat.connection_count > 0
(B[m[32m+                || (peer_stat.ban_until.is_some() && peer_stat.ban_until.unwrap() > now)
(B[m         });
[31m-        
(B[m[32m+
(B[m         debug!("DOS protection cleanup: {} entries remaining", stats.len());
     }
 }
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:336:
             last_refill: Instant::now(),
         }
     }
[31m-    
(B[m[32m+
(B[m     fn try_acquire(&mut self) -> bool {
         self.refill();
[31m-        
(B[m[32m+
(B[m         if self.tokens > 0 {
             self.tokens -= 1;
             true
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:347:
             false
         }
     }
[31m-    
(B[m[32m+
(B[m     fn refill(&mut self) {
         let now = Instant::now();
         let elapsed = now.duration_since(self.last_refill);
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:354:
[31m-        
(B[m[32m+
(B[m         if elapsed >= self.window {
             self.tokens = self.capacity;
             self.last_refill = now;
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:375:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_connection_limits() {
         let config = DosProtectionConfig {
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:382:
             max_connections_per_ip: 2,
             ..Default::default()
         };
[31m-        
(B[m[32m+
(B[m         let manager = DosProtectionManager::new(config);
         let ip: IpAddr = "192.168.1.1".parse().unwrap();
[31m-        
(B[m[32m+
(B[m         // First two connections should be allowed
         assert!(manager.should_allow_connection(ip).await);
         manager.register_connection(ip).await;
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:392:
[31m-        
(B[m[32m+
(B[m         assert!(manager.should_allow_connection(ip).await);
         manager.register_connection(ip).await;
[31m-        
(B[m[32m+
(B[m         // Third connection should be rejected
         assert!(!manager.should_allow_connection(ip).await);
[31m-        
(B[m[32m+
(B[m         // After unregistering, should allow again
         manager.unregister_connection(ip).await;
         assert!(manager.should_allow_connection(ip).await);
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:402:
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_message_rate_limiting() {
         let config = DosProtectionConfig {
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:407:
             max_messages_per_second: 5,
             ..Default::default()
         };
[31m-        
(B[m[32m+
(B[m         let manager = DosProtectionManager::new(config);
         let ip: IpAddr = "192.168.1.1".parse().unwrap();
[31m-        
(B[m[32m+
(B[m         // First 5 messages should be allowed
         for _ in 0..5 {
             assert!(manager.should_allow_message(ip, 100).await);
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:417:
         }
[31m-        
(B[m[32m+
(B[m         // 6th message should be rejected
         assert!(!manager.should_allow_message(ip, 100).await);
[31m-        
(B[m[32m+
(B[m         // After 1 second, should allow again
         tokio::time::sleep(Duration::from_secs(1)).await;
         assert!(manager.should_allow_message(ip, 100).await);
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:425:
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_whitelisting() {
         let whitelisted_ip: IpAddr = "192.168.1.1".parse().unwrap();
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:433:
             whitelisted_ips: vec![whitelisted_ip],
             ..Default::default()
         };
[31m-        
(B[m[32m+
(B[m         let manager = DosProtectionManager::new(config);
[31m-        
(B[m[32m+
(B[m         // Whitelisted IP should always be allowed
         for _ in 0..10 {
             assert!(manager.should_allow_connection(whitelisted_ip).await);
Diff in /home/ubuntu/neo-rs/crates/network/src/dos_protection.rs:443:
         }
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/network/src/error_handling.rs:875:
             .await;
 
         assert!(result.is_ok());
[31m-        assert_eq!(result.expect("Result should be Ok"), "success after retries");
(B[m[32m+        assert_eq!(
(B[m[32m+            result.expect("Result should be Ok"),
(B[m[32m+            "success after retries"
(B[m[32m+        );
(B[m         assert_eq!(attempt_count.load(std::sync::atomic::Ordering::SeqCst), 3);
     }
 
Diff in /home/ubuntu/neo-rs/crates/network/src/lib.rs:133:
 
 /// Composite message handler for protocol processing
 pub mod composite_handler;
[32m+/// DOS protection and rate limiting
(B[m[32m+pub mod dos_protection;
(B[m /// Network error types and result handling
 pub mod error;
 /// Advanced error handling and recovery strategies
Diff in /home/ubuntu/neo-rs/crates/network/src/lib.rs:151:
 pub mod peers;
 /// Transaction and inventory relay cache
 pub mod relay_cache;
[32m+/// Network resilience patterns
(B[m[32m+pub mod resilience;
(B[m /// JSON-RPC server implementation
 pub mod rpc;
[32m+/// Safe P2P networking utilities
(B[m[32m+pub mod safe_p2p;
(B[m /// Network server coordination
 pub mod server;
 /// Graceful shutdown implementation
Diff in /home/ubuntu/neo-rs/crates/network/src/lib.rs:163:
 pub mod sync;
 /// Transaction relay and propagation
 pub mod transaction_relay;
[31m-/// Safe P2P networking utilities
(B[m[31m-pub mod safe_p2p;
(B[m[31m-/// DOS protection and rate limiting
(B[m[31m-pub mod dos_protection;
(B[m[31m-/// Network resilience patterns
(B[m[31m-pub mod resilience;
(B[m 
 // Constants
 const UNKNOWN_PEER_ADDR: &str = "0.0.0.0:0";
Diff in /home/ubuntu/neo-rs/crates/network/src/lib.rs:247:
 /// # Thread Safety
 ///
 /// This function is thread-safe and can be called from any thread.
[31m-    /// Sets a value in the internal state.
(B[m[32m+/// Sets a value in the internal state.
(B[m pub fn set_global_sync_manager(sync_manager: std::sync::Arc<sync::SyncManager>) {
     if let Ok(mut guard) = GLOBAL_SYNC_MANAGER.lock() {
         *guard = Some(sync_manager);
Diff in /home/ubuntu/neo-rs/crates/network/src/messages/extensible_payload.rs:171:
             _hash: None,
         };
 
[31m-        payload.validate().map_err(|e| neo_io::IoError::invalid_format("ExtensiblePayload", &format!("{}", e)))?;
(B[m[32m+        payload
(B[m[32m+            .validate()
(B[m[32m+            .map_err(|e| neo_io::IoError::invalid_format("ExtensiblePayload", &format!("{}", e)))?;
(B[m         Ok(payload)
     }
 
Diff in /home/ubuntu/neo-rs/crates/network/src/p2p_node.rs:1232:
         // Use ephemeral port 0 to avoid binding failures in tests
         config.port = 0;
         let (cmd_tx, cmd_rx) = mpsc::channel(100);
[31m-        let node = P2pNode::new(config, cmd_rx)
(B[m[31m-            .expect("Failed to create P2P node for test");
(B[m[32m+        let node = P2pNode::new(config, cmd_rx).expect("Failed to create P2P node for test");
(B[m         (node, cmd_tx)
     }
 
Diff in /home/ubuntu/neo-rs/crates/network/src/p2p_node.rs:1267:
         ];
 
         for capability in capabilities {
[31m-            let serialized = serde_json::to_string(&capability)
(B[m[31m-                .expect("Failed to serialize capability");
(B[m[32m+            let serialized =
(B[m[32m+                serde_json::to_string(&capability).expect("Failed to serialize capability");
(B[m             let deserialized: NodeCapability =
                 serde_json::from_str(&serialized).expect("Failed to parse from string");
             assert_eq!(capability, deserialized);
Diff in /home/ubuntu/neo-rs/crates/network/src/p2p_node.rs:1305:
         let address: SocketAddr = "127.0.0.1:20333".parse().expect("valid address");
         let peer_info = create_test_peer_info(address, true);
 
[31m-        let serialized = serde_json::to_string(&peer_info)
(B[m[31m-            .expect("Failed to serialize peer info");
(B[m[32m+        let serialized = serde_json::to_string(&peer_info).expect("Failed to serialize peer info");
(B[m         let deserialized: PeerInfo =
             serde_json::from_str(&serialized).expect("Failed to parse from string");
 
Diff in /home/ubuntu/neo-rs/crates/network/src/p2p_node.rs:1869:
         // Test that dropping a node doesn't panic
         let config = NetworkConfig::testnet();
         let (_cmd_tx, cmd_rx) = mpsc::channel(100);
[31m-        let node = P2pNode::new(config, cmd_rx)
(B[m[31m-            .expect("Failed to create P2P node for test");
(B[m[32m+        let node = P2pNode::new(config, cmd_rx).expect("Failed to create P2P node for test");
(B[m 
         // Drop the node explicitly
         drop(node);
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:4:
 //! including circuit breakers, retry logic, and fallback mechanisms.
 
 use crate::{NetworkError, NetworkResult as Result};
[31m-use std::sync::Arc;
(B[m use std::sync::atomic::{AtomicU32, AtomicU64, Ordering};
[32m+use std::sync::Arc;
(B[m use std::time::{Duration, Instant};
 use tokio::sync::RwLock;
 
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:73:
             config,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Check if request should be allowed
     pub async fn should_allow_request(&self) -> Result<()> {
         let mut state = self.state.write().await;
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:80:
[31m-        
(B[m[32m+
(B[m         match *state {
             CircuitState::Open => {
                 // Check if timeout has passed
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:99:
                 // Normal operation
             }
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Record a successful operation
     pub async fn record_success(&self) {
         let mut state = self.state.write().await;
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:109:
[31m-        
(B[m[32m+
(B[m         match *state {
             CircuitState::HalfOpen => {
                 let count = self.success_count.fetch_add(1, Ordering::Relaxed) + 1;
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:123:
             _ => {}
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Record a failed operation
     pub async fn record_failure(&self) {
         let mut state = self.state.write().await;
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:130:
[31m-        
(B[m[32m+
(B[m         match *state {
             CircuitState::Closed => {
                 let count = self.failure_count.fetch_add(1, Ordering::Relaxed) + 1;
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:145:
             _ => {}
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get current state
     pub async fn get_state(&self) -> CircuitState {
         *self.state.read().await
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:185:
             successful_attempts: AtomicU64::new(0),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Execute operation with retry
     pub async fn execute<F, Fut, T>(&self, mut f: F) -> Result<T>
     where
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:194:
     {
         let mut attempt = 0;
         let mut delay = self.base_delay;
[31m-        
(B[m[32m+
(B[m         loop {
             self.total_attempts.fetch_add(1, Ordering::Relaxed);
[31m-            
(B[m[32m+
(B[m             match f().await {
                 Ok(result) => {
                     self.successful_attempts.fetch_add(1, Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:214:
                 }
                 Err(_) => {
                     attempt += 1;
[31m-                    
(B[m[32m+
(B[m                     // Apply exponential backoff with jitter
                     let jitter = self.calculate_jitter(delay);
                     tokio::time::sleep(delay + jitter).await;
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:221:
[31m-                    
(B[m[32m+
(B[m                     // Increase delay for next attempt
                     delay = (delay * 2).min(self.max_delay);
                 }
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:225:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Check if error is retryable
     fn should_retry(&self, error: &NetworkError) -> bool {
         match error {
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:232:
[31m-            NetworkError::ConnectionTimeout { .. } |
(B[m[31m-            NetworkError::ConnectionRefused { .. } |
(B[m[31m-            NetworkError::TemporaryFailure { .. } => true,
(B[m[32m+            NetworkError::ConnectionTimeout { .. }
(B[m[32m+            | NetworkError::ConnectionRefused { .. }
(B[m[32m+            | NetworkError::TemporaryFailure { .. } => true,
(B[m             _ => false,
         }
     }
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:238:
[31m-    
(B[m[32m+
(B[m     /// Calculate jitter for delay
     fn calculate_jitter(&self, delay: Duration) -> Duration {
         use rand::Rng;
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:243:
         let random_jitter = rand::thread_rng().gen_range(0..=jitter_ms);
         Duration::from_millis(random_jitter)
     }
[31m-    
(B[m[32m+
(B[m     /// Update success rate
     async fn update_success_rate(&self) {
         let total = self.total_attempts.load(Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:250:
         let successful = self.successful_attempts.load(Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         if total > 0 {
             let rate = successful as f64 / total as f64;
             *self.success_rate.write().await = rate;
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:255:
[31m-            
(B[m[32m+
(B[m             // Adjust retry strategy based on success rate
             if rate < 0.5 && total > 10 {
                 // Poor success rate - might want to adjust strategy
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:260:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get current success rate
     pub async fn get_success_rate(&self) -> f64 {
         *self.success_rate.read().await
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:291:
             queue_size: AtomicU32::new(0),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Acquire a permit to execute
     pub fn try_acquire(&self) -> Result<BulkheadPermit> {
         let current = self.current_concurrent.load(Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:298:
[31m-        
(B[m[32m+
(B[m         if current as usize >= self.max_concurrent {
             // Try to queue
             let queue = self.queue_size.load(Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:306:
                     limit: self.max_queue_size as u64,
                 });
             }
[31m-            
(B[m[32m+
(B[m             self.queue_size.fetch_add(1, Ordering::Relaxed);
             return Err(NetworkError::Queued {
                 reason: "Request queued in bulkhead".to_string(),
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:313:
             });
         }
[31m-        
(B[m[32m+
(B[m         self.current_concurrent.fetch_add(1, Ordering::Relaxed);
         Ok(BulkheadPermit { bulkhead: self })
     }
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:319:
[31m-    
(B[m[32m+
(B[m     /// Release a permit
     fn release(&self) {
         self.current_concurrent.fetch_sub(1, Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:323:
[31m-        
(B[m[32m+
(B[m         // Process queued item if any
         let queue = self.queue_size.load(Ordering::Relaxed);
         if queue > 0 {
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:366:
             is_healthy: Arc::new(RwLock::new(true)),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Check if service is healthy
     pub async fn is_healthy(&self) -> bool {
         // Check if we need to perform a health check
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:377:
                 Some(time) => time.elapsed() >= self.check_interval,
             }
         };
[31m-        
(B[m[32m+
(B[m         if should_check {
             self.perform_health_check().await;
         }
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:384:
[31m-        
(B[m[32m+
(B[m         *self.is_healthy.read().await
     }
[31m-    
(B[m[32m+
(B[m     /// Perform health check
     async fn perform_health_check(&self) {
         *self.last_check.write().await = Some(Instant::now());
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:391:
[31m-        
(B[m[32m+
(B[m         // Simulate health check (in real implementation, would ping service)
         let check_future = tokio::time::sleep(Duration::from_millis(10));
[31m-        
(B[m[32m+
(B[m         match tokio::time::timeout(self.check_timeout, check_future).await {
             Ok(_) => {
                 *self.is_healthy.write().await = true;
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:402:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Mark service as unhealthy
     pub async fn mark_unhealthy(&self) {
         *self.is_healthy.write().await = false;
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:412:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_circuit_breaker() {
         let config = CircuitBreakerConfig {
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:421:
             timeout: Duration::from_millis(100),
             reset_timeout: Duration::from_millis(200),
         };
[31m-        
(B[m[32m+
(B[m         let breaker = CircuitBreaker::new(config);
[31m-        
(B[m[32m+
(B[m         // Initially closed
         assert_eq!(breaker.get_state().await, CircuitState::Closed);
         assert!(breaker.should_allow_request().await.is_ok());
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:430:
[31m-        
(B[m[32m+
(B[m         // Record failures to open circuit
         breaker.record_failure().await;
         breaker.record_failure().await;
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:434:
         assert_eq!(breaker.get_state().await, CircuitState::Open);
[31m-        
(B[m[32m+
(B[m         // Circuit is open
         assert!(breaker.should_allow_request().await.is_err());
[31m-        
(B[m[32m+
(B[m         // Wait for timeout
         tokio::time::sleep(Duration::from_millis(150)).await;
         assert!(breaker.should_allow_request().await.is_ok());
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:442:
         assert_eq!(breaker.get_state().await, CircuitState::HalfOpen);
     }
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_adaptive_retry() {
[31m-        let retry = AdaptiveRetry::new(
(B[m[31m-            Duration::from_millis(10),
(B[m[31m-            Duration::from_millis(100),
(B[m[31m-            3
(B[m[31m-        );
(B[m[31m-        
(B[m[32m+        let retry = AdaptiveRetry::new(Duration::from_millis(10), Duration::from_millis(100), 3);
(B[m[32m+
(B[m         let attempt = std::sync::Arc::new(std::sync::atomic::AtomicUsize::new(0));
         let attempt_clone = attempt.clone();
[31m-        
(B[m[31m-        let result = retry.execute(move || {
(B[m[31m-            let attempt_val = attempt_clone.fetch_add(1, std::sync::atomic::Ordering::Relaxed) + 1;
(B[m[31m-            async move {
(B[m[31m-                if attempt_val < 3 {
(B[m[31m-                    Err(NetworkError::ConnectionTimeout {
(B[m[31m-                        address: "127.0.0.1:8333".parse().unwrap(),
(B[m[31m-                        timeout_ms: 1000,
(B[m[31m-                    })
(B[m[31m-                } else {
(B[m[31m-                    Ok(42)
(B[m[32m+
(B[m[32m+        let result = retry
(B[m[32m+            .execute(move || {
(B[m[32m+                let attempt_val =
(B[m[32m+                    attempt_clone.fetch_add(1, std::sync::atomic::Ordering::Relaxed) + 1;
(B[m[32m+                async move {
(B[m[32m+                    if attempt_val < 3 {
(B[m[32m+                        Err(NetworkError::ConnectionTimeout {
(B[m[32m+                            address: "127.0.0.1:8333".parse().unwrap(),
(B[m[32m+                            timeout_ms: 1000,
(B[m[32m+                        })
(B[m[32m+                    } else {
(B[m[32m+                        Ok(42)
(B[m[32m+                    }
(B[m                 }
[31m-            }
(B[m[31m-        }).await;
(B[m[31m-        
(B[m[32m+            })
(B[m[32m+            .await;
(B[m[32m+
(B[m         assert!(result.is_ok());
         assert_eq!(result.unwrap(), 42);
         assert_eq!(attempt.load(std::sync::atomic::Ordering::Relaxed), 3);
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:473:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_bulkhead() {
         let bulkhead = Bulkhead::new(2, 1);
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:478:
[31m-        
(B[m[32m+
(B[m         // First two should succeed
         let permit1 = bulkhead.try_acquire();
         assert!(permit1.is_ok());
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:482:
[31m-        
(B[m[32m+
(B[m         let permit2 = bulkhead.try_acquire();
         assert!(permit2.is_ok());
[31m-        
(B[m[32m+
(B[m         // Third should be queued
         let permit3 = bulkhead.try_acquire();
         assert!(permit3.is_err());
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:489:
[31m-        
(B[m[32m+
(B[m         // Drop a permit to free capacity
         drop(permit1);
[31m-        
(B[m[32m+
(B[m         // Now should succeed
         let permit4 = bulkhead.try_acquire();
         assert!(permit4.is_ok());
Diff in /home/ubuntu/neo-rs/crates/network/src/resilience.rs:496:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:1:
 //! Safe P2P Network Module
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides safe wrappers and improvements for P2P networking,
 //! replacing unsafe unwrap() calls with proper error handling.
 
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:6:
 use crate::{NetworkConfig, NetworkError, NetworkResult as Result, P2pNode};
[31m-use neo_core::safe_error_handling::{SafeUnwrap, SafeExpect, SafeError};
(B[m[32m+use neo_core::safe_error_handling::{SafeError, SafeExpect, SafeUnwrap};
(B[m use std::sync::Arc;
 use tokio::sync::mpsc;
 
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:26:
             max_retries: 3,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Set whether to validate configuration
     pub fn with_validation(mut self, validate: bool) -> Self {
         self.validate_config = validate;
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:33:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set maximum connection retries
     pub fn with_max_retries(mut self, retries: u32) -> Self {
         self.max_retries = retries;
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:39:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Validate the network configuration
     fn validate_config(&self) -> Result<()> {
         // Validate port range
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:48:
                 reason: format!("Invalid port: {}", self.config.port),
             });
         }
[31m-        
(B[m[32m+
(B[m         // Validate peer counts
         if self.config.max_peers == 0 {
             return Err(NetworkError::Configuration {
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:56:
                 reason: "must be greater than 0".to_string(),
             });
         }
[31m-        
(B[m[32m+
(B[m         // Check that at least some connections are allowed
         if self.config.max_outbound_connections == 0 && self.config.max_inbound_connections == 0 {
             return Err(NetworkError::Configuration {
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:64:
                 reason: "must allow at least one inbound or outbound connection".to_string(),
             });
         }
[31m-        
(B[m[32m+
(B[m         // Validate timeouts
         if self.config.handshake_timeout == 0 {
             return Err(NetworkError::Configuration {
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:72:
                 reason: "must be greater than 0".to_string(),
             });
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Build the P2P node with safe error handling
     pub async fn build(
         self,
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:82:
[31m-        mut command_receiver: mpsc::Receiver<crate::NetworkCommand>
(B[m[32m+        mut command_receiver: mpsc::Receiver<crate::NetworkCommand>,
(B[m     ) -> Result<Arc<P2pNode>> {
         // Validate configuration if requested
         if self.validate_config {
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:86:
             self.validate_config()?;
         }
[31m-        
(B[m[32m+
(B[m         // Create node - no retry logic for now since command_receiver can't be moved multiple times
         match P2pNode::new(self.config.clone(), command_receiver) {
             Ok(node) => {
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:108:
     /// Safely serialize a message to JSON
     pub fn to_json<T: serde::Serialize>(value: &T, context: &str) -> Result<String> {
         serde_json::to_string(value)
[31m-            .map_err(|e| NetworkError::message_serialization(
(B[m[31m-                context,
(B[m[31m-                &format!("{}", e)
(B[m[31m-            ))
(B[m[32m+            .map_err(|e| NetworkError::message_serialization(context, &format!("{}", e)))
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Safely deserialize a message from JSON
[31m-    pub fn from_json<T: serde::de::DeserializeOwned>(
(B[m[31m-        data: &str, 
(B[m[31m-        context: &str
(B[m[31m-    ) -> Result<T> {
(B[m[31m-        serde_json::from_str(data)
(B[m[31m-            .map_err(|e| NetworkError::message_deserialization(
(B[m[31m-                data.len(),
(B[m[31m-                format!("{}: {}", context, e)
(B[m[31m-            ))
(B[m[32m+    pub fn from_json<T: serde::de::DeserializeOwned>(data: &str, context: &str) -> Result<T> {
(B[m[32m+        serde_json::from_str(data).map_err(|e| {
(B[m[32m+            NetworkError::message_deserialization(data.len(), format!("{}: {}", context, e))
(B[m[32m+        })
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Safely serialize to bytes
     pub fn to_bytes<T: serde::Serialize>(value: &T, context: &str) -> Result<Vec<u8>> {
         bincode::serialize(value)
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:132:
[31m-            .map_err(|e| NetworkError::message_serialization(
(B[m[31m-                context,
(B[m[31m-                &format!("{}", e)
(B[m[31m-            ))
(B[m[32m+            .map_err(|e| NetworkError::message_serialization(context, &format!("{}", e)))
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Safely deserialize from bytes
[31m-    pub fn from_bytes<T: serde::de::DeserializeOwned>(
(B[m[31m-        data: &[u8], 
(B[m[31m-        context: &str
(B[m[31m-    ) -> Result<T> {
(B[m[31m-        bincode::deserialize(data)
(B[m[31m-            .map_err(|e| NetworkError::message_deserialization(
(B[m[31m-                data.len(),
(B[m[31m-                format!("{}: {}", context, e)
(B[m[31m-            ))
(B[m[32m+    pub fn from_bytes<T: serde::de::DeserializeOwned>(data: &[u8], context: &str) -> Result<T> {
(B[m[32m+        bincode::deserialize(data).map_err(|e| {
(B[m[32m+            NetworkError::message_deserialization(data.len(), format!("{}: {}", context, e))
(B[m[32m+        })
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:164:
             allow_unknown_commands: false,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Set maximum message size
     pub fn with_max_size(mut self, size: usize) -> Self {
         self.max_message_size = size;
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:171:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Set whether to allow unknown commands
     pub fn allow_unknown(mut self, allow: bool) -> Self {
         self.allow_unknown_commands = allow;
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:177:
         self
     }
[31m-    
(B[m[32m+
(B[m     /// Validate message size
     /// Validates the input or state.
     pub fn validate_size(&self, size: usize, context: &str) -> Result<()> {
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:188:
         }
         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Validate message command
     /// Validates the input or state.
     pub fn validate_command(&self, command: &str) -> Result<()> {
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:195:
         // List of known valid commands
         const VALID_COMMANDS: &[&str] = &[
[31m-            "version", "verack", "getaddr", "addr", "ping", "pong",
(B[m[31m-            "getblocks", "getdata", "getblockbyindex", "inv", "block",
(B[m[31m-            "consensus", "tx", "merkleblock", "notfound", "reject",
(B[m[31m-            "alert", "headers", "getheaders", "mempool"
(B[m[32m+            "version",
(B[m[32m+            "verack",
(B[m[32m+            "getaddr",
(B[m[32m+            "addr",
(B[m[32m+            "ping",
(B[m[32m+            "pong",
(B[m[32m+            "getblocks",
(B[m[32m+            "getdata",
(B[m[32m+            "getblockbyindex",
(B[m[32m+            "inv",
(B[m[32m+            "block",
(B[m[32m+            "consensus",
(B[m[32m+            "tx",
(B[m[32m+            "merkleblock",
(B[m[32m+            "notfound",
(B[m[32m+            "reject",
(B[m[32m+            "alert",
(B[m[32m+            "headers",
(B[m[32m+            "getheaders",
(B[m[32m+            "mempool",
(B[m         ];
[31m-        
(B[m[32m+
(B[m         if !VALID_COMMANDS.contains(&command) && !self.allow_unknown_commands {
             // Use a generic socket address for now, as we don't have the peer address here
             return Err(NetworkError::InvalidMessage {
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:208:
                 reason: format!("Unknown command: {}", command),
             });
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:231:
             retry_delay: tokio::time::Duration::from_secs(5),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Safely connect to a peer with retry logic
     pub async fn connect_with_retry(
         &self,
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:238:
         address: std::net::SocketAddr,
     ) -> Result<tokio::net::TcpStream> {
         let mut last_error = None;
[31m-        
(B[m[32m+
(B[m         for attempt in 1..=self.max_connection_attempts {
             tracing::debug!(
                 "Attempting connection to {} (attempt {}/{})",
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:245:
[31m-                address, attempt, self.max_connection_attempts
(B[m[32m+                address,
(B[m[32m+                attempt,
(B[m[32m+                self.max_connection_attempts
(B[m             );
[31m-            
(B[m[32m+
(B[m             match tokio::time::timeout(
                 self.connection_timeout,
[31m-                tokio::net::TcpStream::connect(address)
(B[m[31m-            ).await {
(B[m[32m+                tokio::net::TcpStream::connect(address),
(B[m[32m+            )
(B[m[32m+            .await
(B[m[32m+            {
(B[m                 Ok(Ok(stream)) => {
                     tracing::info!("Successfully connected to {}", address);
                     return Ok(stream);
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:268:
                     });
                 }
             }
[31m-            
(B[m[32m+
(B[m             // Wait before retry (except on last attempt)
             if attempt < self.max_connection_attempts {
                 tokio::time::sleep(self.retry_delay).await;
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:275:
             }
         }
[31m-        
(B[m[31m-        Err(last_error.unwrap_or_else(|| {
(B[m[31m-            NetworkError::ConnectionFailed {
(B[m[32m+
(B[m[32m+        Err(
(B[m[32m+            last_error.unwrap_or_else(|| NetworkError::ConnectionFailed {
(B[m                 address,
[31m-                reason: format!("Failed to connect after {} attempts", self.max_connection_attempts),
(B[m[31m-            }
(B[m[31m-        }))
(B[m[32m+                reason: format!(
(B[m[32m+                    "Failed to connect after {} attempts",
(B[m[32m+                    self.max_connection_attempts
(B[m[32m+                ),
(B[m[32m+            }),
(B[m[32m+        )
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:287:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[tokio::test]
     async fn test_safe_p2p_builder_validation() {
         let mut config = NetworkConfig::testnet();
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:294:
         config.max_peers = 0; // Invalid
[31m-        
(B[m[32m+
(B[m         let builder = SafeP2pNodeBuilder::new(config);
         let result = builder.validate_config();
         assert!(result.is_err());
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:299:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_serialization() {
         #[derive(serde::Serialize, serde::Deserialize, PartialEq, Debug)]
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:305:
             id: u32,
             data: String,
         }
[31m-        
(B[m[32m+
(B[m         let msg = TestMessage {
             id: 42,
             data: "test".to_string(),
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:312:
         };
[31m-        
(B[m[32m+
(B[m         // Test JSON serialization
         let json = SafeMessageSerializer::to_json(&msg, "test message")
             .expect("Serialization should succeed");
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:317:
         let deserialized: TestMessage = SafeMessageSerializer::from_json(&json, "test message")
             .expect("Deserialization should succeed");
         assert_eq!(msg, deserialized);
[31m-        
(B[m[32m+
(B[m         // Test binary serialization
         let bytes = SafeMessageSerializer::to_bytes(&msg, "test message")
             .expect("Serialization should succeed");
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:325:
             .expect("Deserialization should succeed");
         assert_eq!(msg, deserialized);
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_message_validator() {
[31m-        let validator = MessageValidator::new()
(B[m[31m-            .with_max_size(1024);
(B[m[31m-        
(B[m[32m+        let validator = MessageValidator::new().with_max_size(1024);
(B[m[32m+
(B[m         // Test size validation
         assert!(validator.validate_size(512, "test").is_ok());
         assert!(validator.validate_size(2048, "test").is_err());
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:337:
[31m-        
(B[m[32m+
(B[m         // Test command validation
         assert!(validator.validate_command("ping").is_ok());
         assert!(validator.validate_command("unknown").is_err());
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:341:
[31m-        
(B[m[32m+
(B[m         // Test with unknown commands allowed
         let validator = MessageValidator::new().allow_unknown(true);
         assert!(validator.validate_command("unknown").is_ok());
Diff in /home/ubuntu/neo-rs/crates/network/src/safe_p2p.rs:345:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/network/src/shutdown_impl.rs:326:
     #[tokio::test]
     async fn test_peer_manager_shutdown() {
         let config = NetworkConfig::testnet();
[31m-        let peer_manager = PeerManager::new(config)
(B[m[31m-            .expect("Failed to create peer manager for test");
(B[m[32m+        let peer_manager =
(B[m[32m+            PeerManager::new(config).expect("Failed to create peer manager for test");
(B[m 
         // Test shutdown
         let result = peer_manager.shutdown().await;
Diff in /home/ubuntu/neo-rs/crates/network/src/shutdown_impl.rs:392:
         let config = NetworkConfig::testnet();
         let (_, command_receiver) = tokio::sync::mpsc::channel(100);
         let p2p_node = std::sync::Arc::new(
[31m-            P2pNode::new(config, command_receiver)
(B[m[31m-                .expect("Failed to create P2P node for test")
(B[m[32m+            P2pNode::new(config, command_receiver).expect("Failed to create P2P node for test"),
(B[m         );
         let sync_manager = SyncManager::new(blockchain, p2p_node);
 
Diff in /home/ubuntu/neo-rs/crates/network/src/shutdown_impl.rs:419:
         let config = NetworkConfig::testnet();
         let (_, command_receiver) = tokio::sync::mpsc::channel(100);
         let p2p_node = std::sync::Arc::new(
[31m-            P2pNode::new(config, command_receiver)
(B[m[31m-                .expect("Failed to create P2P node for test")
(B[m[32m+            P2pNode::new(config, command_receiver).expect("Failed to create P2P node for test"),
(B[m         );
         let sync_manager = SyncManager::new(blockchain, p2p_node);
 
Diff in /home/ubuntu/neo-rs/crates/network/src/sync.rs:84:
 pub const MAINNET_SNAPSHOTS: &[SnapshotMetadata] = &[];
 
 /// Get the best available snapshot for a target height
[31m-    /// Gets a value from the internal state.
(B[m[32m+/// Gets a value from the internal state.
(B[m pub fn get_best_snapshot(target_height: u32) -> Option<&'static SnapshotMetadata> {
     MAINNET_SNAPSHOTS
         .iter()
Diff in /home/ubuntu/neo-rs/crates/network/src/sync.rs:93:
 }
 
 /// Get the best checkpoint to start syncing from based on target height
[31m-    /// Gets a value from the internal state.
(B[m[32m+/// Gets a value from the internal state.
(B[m pub fn get_best_checkpoint(target_height: u32) -> (u32, &'static str) {
     let mut best = MAINNET_CHECKPOINTS[0];
 
Diff in /home/ubuntu/neo-rs/crates/network/src/sync.rs:144:
 /// Represents an enumeration of values.
 pub enum SyncEvent {
     /// Sync started
[31m-    SyncStarted { 
(B[m[32m+    SyncStarted {
(B[m         /// Target blockchain height
[31m-        target_height: u32 
(B[m[32m+        target_height: u32,
(B[m     },
     /// Headers sync progress
[31m-    HeadersProgress { 
(B[m[32m+    HeadersProgress {
(B[m         /// Current progress
[31m-        current: u32, 
(B[m[32m+        current: u32,
(B[m         /// Target value
[31m-        target: u32 
(B[m[32m+        target: u32,
(B[m     },
     /// Blocks sync progress
[31m-    BlocksProgress { 
(B[m[32m+    BlocksProgress {
(B[m         /// Current progress
[31m-        current: u32, 
(B[m[32m+        current: u32,
(B[m         /// Target value
[31m-        target: u32 
(B[m[32m+        target: u32,
(B[m     },
     /// Sync completed
[31m-    SyncCompleted { 
(B[m[32m+    SyncCompleted {
(B[m         /// Final blockchain height
[31m-        final_height: u32 
(B[m[32m+        final_height: u32,
(B[m     },
     /// Sync failed
[31m-    SyncFailed { 
(B[m[32m+    SyncFailed {
(B[m         /// Error message
[31m-        error: String 
(B[m[32m+        error: String,
(B[m     },
     /// New best height discovered
[31m-    NewBestHeight { 
(B[m[32m+    NewBestHeight {
(B[m         /// Block height
[31m-        height: u32, 
(B[m[32m+        height: u32,
(B[m         /// Peer address
[31m-        peer: SocketAddr 
(B[m[32m+        peer: SocketAddr,
(B[m     },
 }
 
Diff in /home/ubuntu/neo-rs/crates/network/src/sync.rs:1524:
         let config = NetworkConfig::testnet();
         let (_, command_receiver) = tokio::sync::mpsc::channel(100);
         let p2p_node = Arc::new(
[31m-            P2pNode::new(config, command_receiver)
(B[m[31m-                .expect("Failed to create P2P node for test")
(B[m[32m+            P2pNode::new(config, command_receiver).expect("Failed to create P2P node for test"),
(B[m         );
         let sync_manager = Arc::new(SyncManager::new(blockchain.clone(), p2p_node.clone()));
         (sync_manager, blockchain, p2p_node)
Diff in /home/ubuntu/neo-rs/crates/network/src/sync.rs:1549:
         ];
 
         for state in states {
[31m-            let serialized = serde_json::to_string(&state)
(B[m[31m-                .expect("Failed to serialize sync state");
(B[m[32m+            let serialized = serde_json::to_string(&state).expect("Failed to serialize sync state");
(B[m             let deserialized: SyncState =
                 serde_json::from_str(&serialized).expect("Failed to parse from string");
             assert_eq!(state, deserialized);
Diff in /home/ubuntu/neo-rs/crates/persistence/src/compression.rs:23:
         CompressionAlgorithm::Zstd => {
             #[cfg(feature = "compression")]
             {
[31m-                // ZSTD temporarily disabled due to build issues  
(B[m[31m-                Err(crate::Error::CompressionError("ZSTD compression not available".to_string()))
(B[m[32m+                // ZSTD temporarily disabled due to build issues
(B[m[32m+                Err(crate::Error::CompressionError(
(B[m[32m+                    "ZSTD compression not available".to_string(),
(B[m[32m+                ))
(B[m             }
             #[cfg(not(feature = "compression"))]
             {
Diff in /home/ubuntu/neo-rs/crates/persistence/src/compression.rs:59:
             #[cfg(feature = "compression")]
             {
                 // ZSTD temporarily disabled due to build issues
[31m-                Err(crate::Error::CompressionError("ZSTD decompression not available".to_string()))
(B[m[32m+                Err(crate::Error::CompressionError(
(B[m[32m+                    "ZSTD decompression not available".to_string(),
(B[m[32m+                ))
(B[m             }
             #[cfg(not(feature = "compression"))]
             {
Diff in /home/ubuntu/neo-rs/crates/persistence/src/lib.rs:39:
 //! # async fn example() -> Result<(), Box<dyn std::error::Error>> {
 //! // Create storage configuration
 //! let config = StorageConfig::default();
[31m-//! 
(B[m[32m+//!
(B[m //! // Create RocksDB storage provider
 //! let provider = Arc::new(RocksDbStorageProvider::new("./data".into())?);
 //!
Diff in /home/ubuntu/neo-rs/crates/persistence/src/lib.rs:73:
 //!         value: b"value1".to_vec(),
 //!     },
 //!     BatchOperation::Put {
[31m-//!         key: b"key2".to_vec(), 
(B[m[32m+//!         key: b"key2".to_vec(),
(B[m //!         value: b"value2".to_vec(),
 //!     },
 //!     BatchOperation::Delete {
Diff in /home/ubuntu/neo-rs/crates/persistence/src/lib.rs:569:
 ///
 /// // Create a storage key for contract 5 with key "balance"
 /// let key = StorageKey::new(5, b"balance".to_vec());
[31m-/// 
(B[m[32m+///
(B[m /// // Convert to bytes for storage
 /// let bytes = key.as_bytes();
[31m-/// 
(B[m[32m+///
(B[m /// // Reconstruct from bytes
 /// let reconstructed = StorageKey::from_bytes(bytes);
 /// assert_eq!(key, reconstructed);
Diff in /home/ubuntu/neo-rs/crates/persistence/src/lib.rs:691:
 ///
 /// // Create from bytes
 /// let value = StorageValue::from_bytes(b"hello world".to_vec());
[31m-/// 
(B[m[32m+///
(B[m /// // Access the data
 /// assert_eq!(value.as_bytes(), b"hello world");
 /// assert_eq!(value.len(), 11);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/src/lib.rs:11:
 pub use neo_vm::{ApplicationEngine, TriggerType};
 
 // Re-export smart contract types
[31m-pub use contract_state::{ContractState, NefFile, MethodToken};
(B[m[32m+pub use contract_state::{ContractState, MethodToken, NefFile};
(B[m pub use manifest::{
[31m-    ContractAbi, ContractGroup, ContractManifest, ContractPermission,
(B[m[31m-    ContractMethod as ContractMethodDescriptor, ContractEvent as ContractEventDescriptor, 
(B[m[31m-    ContractParameter as ContractParameterDefinition,
(B[m[31m-    ContractParameterType, ContractPermissionDescriptor as PermissionContract
(B[m[32m+    ContractAbi, ContractEvent as ContractEventDescriptor, ContractGroup, ContractManifest,
(B[m[32m+    ContractMethod as ContractMethodDescriptor, ContractParameter as ContractParameterDefinition,
(B[m[32m+    ContractParameterType, ContractPermission, ContractPermissionDescriptor as PermissionContract,
(B[m };
 pub use storage::{StorageItem, StorageKey};
 // Note: Types are accessed through proper crate boundaries to maintain clean architecture
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:26:
     assert_eq!(ContractParameterType::Void as u8, 0xff);
 }
 
[31m-#[test] 
(B[m[32m+#[test]
(B[m fn test_contract_parameter_boolean_compatibility() {
     // Test boolean parameter handling matches C# Neo
     let param_true = ContractParameter::Boolean(true);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:33:
     let param_false = ContractParameter::Boolean(false);
[31m-    
(B[m[32m+
(B[m     assert_eq!(param_true.get_type(), ContractParameterType::Boolean);
     assert_eq!(param_false.get_type(), ContractParameterType::Boolean);
[31m-    
(B[m[32m+
(B[m     // Test serialization
     let serialized_true = param_true.to_bytes();
     let serialized_false = param_false.to_bytes();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:41:
[31m-    
(B[m[32m+
(B[m     assert_eq!(serialized_true, vec![0x10, 0x01]); // Type + true value
     assert_eq!(serialized_false, vec![0x10, 0x00]); // Type + false value
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:47:
 fn test_contract_parameter_integer_compatibility() {
     // Test integer parameter handling matches C# Neo
     let test_cases = vec![
[31m-        (0i64, vec![0x11, 0x00]), // Zero
(B[m[31m-        (1i64, vec![0x11, 0x01]), // Positive small
(B[m[31m-        (-1i64, vec![0x11, 0xff]), // Negative small
(B[m[31m-        (127i64, vec![0x11, 0x7f]), // Max byte
(B[m[31m-        (128i64, vec![0x11, 0x80, 0x00]), // Min 2-byte
(B[m[31m-        (32767i64, vec![0x11, 0xff, 0x7f]), // Max 2-byte
(B[m[32m+        (0i64, vec![0x11, 0x00]),            // Zero
(B[m[32m+        (1i64, vec![0x11, 0x01]),            // Positive small
(B[m[32m+        (-1i64, vec![0x11, 0xff]),           // Negative small
(B[m[32m+        (127i64, vec![0x11, 0x7f]),          // Max byte
(B[m[32m+        (128i64, vec![0x11, 0x80, 0x00]),    // Min 2-byte
(B[m[32m+        (32767i64, vec![0x11, 0xff, 0x7f]),  // Max 2-byte
(B[m         (-32768i64, vec![0x11, 0x00, 0x80]), // Min signed 2-byte
     ];
[31m-    
(B[m[32m+
(B[m     for (value, expected) in test_cases {
         let param = ContractParameter::Integer(value);
         assert_eq!(param.get_type(), ContractParameterType::Integer);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:62:
[31m-        
(B[m[32m+
(B[m         let serialized = param.to_bytes();
         assert_eq!(serialized[0], 0x11); // Type byte
[31m-        // Note: Full serialization would require actual BigInteger implementation
(B[m[32m+                                         // Note: Full serialization would require actual BigInteger implementation
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:71:
     // Test byte array parameter handling matches C# Neo
     let test_data = vec![0x01, 0x02, 0x03, 0x04, 0x05];
     let param = ContractParameter::ByteArray(test_data.clone());
[31m-    
(B[m[32m+
(B[m     assert_eq!(param.get_type(), ContractParameterType::ByteArray);
[31m-    
(B[m[32m+
(B[m     // Test serialization format matches C# Neo
     let serialized = param.to_bytes();
     assert_eq!(serialized[0], 0x12); // Type byte
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:86:
     // Test string parameter handling matches C# Neo
     let test_string = "Hello Neo";
     let param = ContractParameter::String(test_string.to_string());
[31m-    
(B[m[32m+
(B[m     assert_eq!(param.get_type(), ContractParameterType::String);
[31m-    
(B[m[32m+
(B[m     // Test UTF-8 encoding matches C# Neo
     let serialized = param.to_bytes();
     assert_eq!(serialized[0], 0x13); // Type byte
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:95:
[31m-    
(B[m[32m+
(B[m     let utf8_bytes = test_string.as_bytes();
     assert_eq!(serialized[1], utf8_bytes.len() as u8); // Length
     assert_eq!(&serialized[2..], utf8_bytes); // UTF-8 data
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:103:
     // Test Hash160 parameter handling matches C# Neo
     let hash = UInt160::from([42u8; 20]);
     let param = ContractParameter::Hash160(hash);
[31m-    
(B[m[32m+
(B[m     assert_eq!(param.get_type(), ContractParameterType::Hash160);
[31m-    
(B[m[32m+
(B[m     // Test serialization format matches C# Neo
     let serialized = param.to_bytes();
     assert_eq!(serialized[0], 0x14); // Type byte
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:118:
     // Test Hash256 parameter handling matches C# Neo
     let hash = UInt256::from([42u8; 32]);
     let param = ContractParameter::Hash256(hash);
[31m-    
(B[m[32m+
(B[m     assert_eq!(param.get_type(), ContractParameterType::Hash256);
[31m-    
(B[m[32m+
(B[m     // Test serialization format matches C# Neo
     let serialized = param.to_bytes();
     assert_eq!(serialized[0], 0x15); // Type byte
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:132:
 fn test_contract_parameter_publickey_compatibility() {
     // Test PublicKey parameter handling matches C# Neo
     let pubkey_data = vec![
[31m-        0x03, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
(B[m[31m-        0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
(B[m[31m-        0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
(B[m[31m-        0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
(B[m[31m-        0xf0
(B[m[32m+        0x03, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
(B[m[32m+        0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
(B[m[32m+        0xbc, 0xde, 0xf0,
(B[m     ]; // 33 bytes compressed public key
[31m-    
(B[m[32m+
(B[m     let param = ContractParameter::PublicKey(pubkey_data.clone());
[31m-    
(B[m[32m+
(B[m     assert_eq!(param.get_type(), ContractParameterType::PublicKey);
[31m-    
(B[m[32m+
(B[m     // Test serialization format matches C# Neo
     let serialized = param.to_bytes();
     assert_eq!(serialized[0], 0x16); // Type byte
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:155:
     // Test Signature parameter handling matches C# Neo
     let signature_data = vec![0u8; 64]; // 64-byte signature
     let param = ContractParameter::Signature(signature_data.clone());
[31m-    
(B[m[32m+
(B[m     assert_eq!(param.get_type(), ContractParameterType::Signature);
[31m-    
(B[m[32m+
(B[m     // Test serialization format matches C# Neo
     let serialized = param.to_bytes();
     assert_eq!(serialized[0], 0x17); // Type byte
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:174:
         ContractParameter::ByteArray(vec![1, 2, 3]),
     ];
     let param = ContractParameter::Array(elements.clone());
[31m-    
(B[m[32m+
(B[m     assert_eq!(param.get_type(), ContractParameterType::Array);
[31m-    
(B[m[32m+
(B[m     // Test serialization format matches C# Neo
     let serialized = param.to_bytes();
     assert_eq!(serialized[0], 0x20); // Type byte
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:183:
     assert_eq!(serialized[1], elements.len() as u8); // Element count
[31m-    
(B[m[32m+
(B[m     // Verify each element is serialized
     let mut offset = 2;
     for element in &elements {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:188:
         let element_serialized = element.to_bytes();
[31m-        assert_eq!(&serialized[offset..offset + element_serialized.len()], &element_serialized);
(B[m[32m+        assert_eq!(
(B[m[32m+            &serialized[offset..offset + element_serialized.len()],
(B[m[32m+            &element_serialized
(B[m[32m+        );
(B[m         offset += element_serialized.len();
     }
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:203:
         ContractParameter::String("key2".to_string()),
         ContractParameter::Boolean(true),
     );
[31m-    
(B[m[32m+
(B[m     let param = ContractParameter::Map(map_data.clone());
[31m-    
(B[m[32m+
(B[m     assert_eq!(param.get_type(), ContractParameterType::Map);
[31m-    
(B[m[32m+
(B[m     // Test serialization format matches C# Neo
     let serialized = param.to_bytes();
     assert_eq!(serialized[0], 0x22); // Type byte
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:214:
     assert_eq!(serialized[1], map_data.len() as u8); // Entry count
[31m-    
(B[m[32m+
(B[m     // Map serialization order must be deterministic for C# compatibility
     // In C# Neo, maps are serialized in insertion order
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:221:
 fn test_contract_parameter_void_compatibility() {
     // Test Void parameter handling matches C# Neo
     let param = ContractParameter::Void;
[31m-    
(B[m[32m+
(B[m     assert_eq!(param.get_type(), ContractParameterType::Void);
[31m-    
(B[m[32m+
(B[m     // Test serialization format matches C# Neo
     let serialized = param.to_bytes();
     assert_eq!(serialized, vec![0xff]); // Only type byte for Void
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:235:
     let test_cases = vec![
         (vec![0x10, 0x01], ContractParameter::Boolean(true)),
         (vec![0x10, 0x00], ContractParameter::Boolean(false)),
[31m-        (vec![0x12, 0x03, 0x01, 0x02, 0x03], ContractParameter::ByteArray(vec![1, 2, 3])),
(B[m[32m+        (
(B[m[32m+            vec![0x12, 0x03, 0x01, 0x02, 0x03],
(B[m[32m+            ContractParameter::ByteArray(vec![1, 2, 3]),
(B[m[32m+        ),
(B[m         (vec![0xff], ContractParameter::Void),
     ];
[31m-    
(B[m[32m+
(B[m     for (serialized, expected) in test_cases {
         let deserialized = ContractParameter::from_bytes(&serialized).unwrap();
         assert_eq!(deserialized, expected);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:257:
         ContractParameter::Hash256(UInt256::from([99u8; 32])),
         ContractParameter::Void,
     ];
[31m-    
(B[m[32m+
(B[m     for param in test_params {
         let serialized = param.to_bytes();
         let deserialized = ContractParameter::from_bytes(&serialized).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:287:
         }),
         ContractParameter::Boolean(false),
     ]);
[31m-    
(B[m[32m+
(B[m     assert_eq!(nested_array.get_type(), ContractParameterType::Array);
[31m-    
(B[m[32m+
(B[m     // Test serialization of complex structures
     let serialized = nested_array.to_bytes();
     let deserialized = ContractParameter::from_bytes(&serialized).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:321:
             ContractParameter::Void => ContractParameterType::Void,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Serialize to bytes (matches C# Neo ContractParameter serialization)
     pub fn to_bytes(&self) -> Vec<u8> {
         let mut result = vec![self.get_type() as u8];
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:328:
[31m-        
(B[m[32m+
(B[m         match self {
             ContractParameter::Boolean(value) => {
                 result.push(if *value { 0x01 } else { 0x00 });
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:332:
[31m-            },
(B[m[32m+            }
(B[m             ContractParameter::Integer(value) => {
                 // Simplified integer encoding - in production would use BigInteger
                 result.push(*value as u8);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:336:
[31m-            },
(B[m[32m+            }
(B[m             ContractParameter::ByteArray(data) => {
                 result.push(data.len() as u8);
                 result.extend_from_slice(data);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:340:
[31m-            },
(B[m[32m+            }
(B[m             ContractParameter::String(s) => {
                 let bytes = s.as_bytes();
                 result.push(bytes.len() as u8);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:344:
                 result.extend_from_slice(bytes);
[31m-            },
(B[m[32m+            }
(B[m             ContractParameter::Hash160(hash) => {
                 result.extend_from_slice(&hash.to_bytes());
[31m-            },
(B[m[32m+            }
(B[m             ContractParameter::Hash256(hash) => {
                 result.extend_from_slice(&hash.to_bytes());
[31m-            },
(B[m[32m+            }
(B[m             ContractParameter::PublicKey(pubkey) => {
                 result.extend_from_slice(pubkey);
[31m-            },
(B[m[32m+            }
(B[m             ContractParameter::Signature(sig) => {
                 result.push(sig.len() as u8);
                 result.extend_from_slice(sig);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:358:
[31m-            },
(B[m[32m+            }
(B[m             ContractParameter::Array(elements) => {
                 result.push(elements.len() as u8);
                 for element in elements {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:362:
                     result.extend_from_slice(&element.to_bytes());
                 }
[31m-            },
(B[m[32m+            }
(B[m             ContractParameter::Map(map) => {
                 result.push(map.len() as u8);
                 for (key, value) in map {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:368:
                     result.extend_from_slice(&key.to_bytes());
                     result.extend_from_slice(&value.to_bytes());
                 }
[31m-            },
(B[m[32m+            }
(B[m             ContractParameter::Void => {
                 // Void only has type byte
[31m-            },
(B[m[32m+            }
(B[m             _ => {
                 // Handle other parameter types
             }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:378:
         }
[31m-        
(B[m[32m+
(B[m         result
     }
[31m-    
(B[m[32m+
(B[m     /// Deserialize from bytes (matches C# Neo ContractParameter deserialization)
     pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
         if bytes.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:386:
             return Err("Empty bytes".to_string());
         }
[31m-        
(B[m[32m+
(B[m         let param_type = bytes[0];
         let data = &bytes[1..];
[31m-        
(B[m[32m+
(B[m         match param_type {
[31m-            0x10 => { // Boolean
(B[m[32m+            0x10 => {
(B[m[32m+                // Boolean
(B[m                 if data.is_empty() {
                     return Err("Boolean parameter missing value".to_string());
                 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:397:
                 Ok(ContractParameter::Boolean(data[0] != 0))
[31m-            },
(B[m[31m-            0x11 => { // Integer
(B[m[32m+            }
(B[m[32m+            0x11 => {
(B[m[32m+                // Integer
(B[m                 if data.is_empty() {
                     return Err("Integer parameter missing value".to_string());
                 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:403:
                 // Simplified - in production would deserialize BigInteger
                 Ok(ContractParameter::Integer(data[0] as i64))
[31m-            },
(B[m[31m-            0x12 => { // ByteArray
(B[m[32m+            }
(B[m[32m+            0x12 => {
(B[m[32m+                // ByteArray
(B[m                 if data.is_empty() {
                     return Err("ByteArray parameter missing length".to_string());
                 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:412:
                     return Err("ByteArray parameter truncated".to_string());
                 }
                 Ok(ContractParameter::ByteArray(data[1..1 + length].to_vec()))
[31m-            },
(B[m[31m-            0xff => { // Void
(B[m[32m+            }
(B[m[32m+            0xff => {
(B[m[32m+                // Void
(B[m                 Ok(ContractParameter::Void)
[31m-            },
(B[m[32m+            }
(B[m             _ => Err(format!("Unknown parameter type: {:#x}", param_type)),
         }
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/contract_parameter_compatibility_tests.rs:476:
     InteropInterface = 0x30,
     Void = 0xff,
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:14:
     // All C# Neo unit test files start with "UT_" prefix
     let test_files = vec![
         "UT_ApplicationEngine.cs",
[31m-        "UT_PolicyContract.cs", 
(B[m[32m+        "UT_PolicyContract.cs",
(B[m         "UT_BinarySerializer.cs",
         "UT_Syscalls.cs",
         "UT_ContractParameterContext.cs",
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:21:
     ];
[31m-    
(B[m[32m+
(B[m     for file in test_files {
[31m-        assert!(file.starts_with("UT_"), "Test file {} should follow UT_ naming convention", file);
(B[m[32m+        assert!(
(B[m[32m+            file.starts_with("UT_"),
(B[m[32m+            "Test file {} should follow UT_ naming convention",
(B[m[32m+            file
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:29:
 fn test_csharp_neo_static_constants_pattern() {
     // Test static constants pattern from C# Neo
     struct PolicyConstants;
[31m-    
(B[m[32m+
(B[m     impl PolicyConstants {
         pub const MAX_BLOCK_SIZE: u32 = 2_097_152; // 2MB - matches C# Neo
         pub const MAX_TRANSACTION_SIZE: u32 = 102_400; // 100KB - matches C# Neo
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:39:
         pub const DEFAULT_EXEC_FEE_FACTOR: i64 = 30; // matches C# Neo
         pub const MAX_MAX_TRACEABLE_BLOCKS: u32 = 2102400; // matches C# Neo
     }
[31m-    
(B[m[32m+
(B[m     // Verify constants match C# Neo values exactly
     assert_eq!(PolicyConstants::MAX_BLOCK_SIZE, 2_097_152);
     assert_eq!(PolicyConstants::MAX_TRANSACTION_SIZE, 102_400);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:55:
     // Test error handling pattern from C# Neo
     fn validate_transaction_size(size: usize) -> Result<(), NeoError> {
         const MAX_SIZE: usize = 102_400; // From C# Neo
[31m-        
(B[m[32m+
(B[m         if size > MAX_SIZE {
             return Err(NeoError::InvalidFormat("Transaction too large".to_string()));
         }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:62:
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     // Test valid size
     assert!(validate_transaction_size(1000).is_ok());
[31m-    
(B[m[32m+
(B[m     // Test invalid size
     let result = validate_transaction_size(200_000);
     assert!(result.is_err());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:72:
[31m-    
(B[m[32m+
(B[m     match result.unwrap_err() {
         NeoError::InvalidFormat(msg) => {
             assert_eq!(msg, "Transaction too large");
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:76:
[31m-        },
(B[m[32m+        }
(B[m         _ => panic!("Wrong error type"),
     }
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:83:
     // Test network magic numbers match C# Neo exactly
     #[derive(Debug, Clone, Copy, PartialEq, Eq)]
     pub enum NetworkMagic {
[31m-        MainNet = 0x4F454E, // "NEO" in ASCII, little-endian
(B[m[31m-        TestNet = 0x3352454E, // "NEO3" in ASCII, little-endian  
(B[m[32m+        MainNet = 0x4F454E,   // "NEO" in ASCII, little-endian
(B[m[32m+        TestNet = 0x3352454E, // "NEO3" in ASCII, little-endian
(B[m         Private = 0x0000,
     }
[31m-    
(B[m[32m+
(B[m     assert_eq!(NetworkMagic::MainNet as u32, 0x4F454E);
     assert_eq!(NetworkMagic::TestNet as u32, 0x3352454E);
     assert_eq!(NetworkMagic::Private as u32, 0x0000);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:94:
[31m-    
(B[m[32m+
(B[m     // Test network magic validation
     fn validate_network_magic(magic: u32) -> bool {
         matches!(magic, 0x4F454E | 0x3352454E | 0x0000)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:98:
     }
[31m-    
(B[m[32m+
(B[m     assert!(validate_network_magic(NetworkMagic::MainNet as u32));
     assert!(validate_network_magic(NetworkMagic::TestNet as u32));
     assert!(validate_network_magic(NetworkMagic::Private as u32));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:111:
         price: u64,
         required_call_flags: u8,
     }
[31m-    
(B[m[32m+
(B[m     impl InteropService {
         pub const fn new(name: &'static str, price: u64, flags: u8) -> Self {
             Self {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:121:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Define services matching C# Neo InteropService exactly
[31m-    const SYSTEM_RUNTIME_PLATFORM: InteropService = InteropService::new("System.Runtime.Platform", 250, 0x00);
(B[m[31m-    const SYSTEM_RUNTIME_GETTRIGGER: InteropService = InteropService::new("System.Runtime.GetTrigger", 250, 0x00);
(B[m[31m-    const SYSTEM_RUNTIME_GETTIME: InteropService = InteropService::new("System.Runtime.GetTime", 250, 0x01);
(B[m[31m-    const SYSTEM_RUNTIME_GETSCRIPTCONTAINER: InteropService = InteropService::new("System.Runtime.GetScriptContainer", 250, 0x00);
(B[m[31m-    const SYSTEM_RUNTIME_GETEXECUTINGSCRIPTHASH: InteropService = InteropService::new("System.Runtime.GetExecutingScriptHash", 400, 0x00);
(B[m[31m-    
(B[m[32m+    const SYSTEM_RUNTIME_PLATFORM: InteropService =
(B[m[32m+        InteropService::new("System.Runtime.Platform", 250, 0x00);
(B[m[32m+    const SYSTEM_RUNTIME_GETTRIGGER: InteropService =
(B[m[32m+        InteropService::new("System.Runtime.GetTrigger", 250, 0x00);
(B[m[32m+    const SYSTEM_RUNTIME_GETTIME: InteropService =
(B[m[32m+        InteropService::new("System.Runtime.GetTime", 250, 0x01);
(B[m[32m+    const SYSTEM_RUNTIME_GETSCRIPTCONTAINER: InteropService =
(B[m[32m+        InteropService::new("System.Runtime.GetScriptContainer", 250, 0x00);
(B[m[32m+    const SYSTEM_RUNTIME_GETEXECUTINGSCRIPTHASH: InteropService =
(B[m[32m+        InteropService::new("System.Runtime.GetExecutingScriptHash", 400, 0x00);
(B[m[32m+
(B[m     // Test service properties
     assert_eq!(SYSTEM_RUNTIME_PLATFORM.name, "System.Runtime.Platform");
     assert_eq!(SYSTEM_RUNTIME_PLATFORM.price, 250);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:144:
         script_hash: UInt160,
         key: Vec<u8>,
     }
[31m-    
(B[m[32m+
(B[m     impl StorageKey {
         pub fn new(script_hash: UInt160, key: Vec<u8>) -> Self {
             Self { script_hash, key }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:151:
         }
[31m-        
(B[m[32m+
(B[m         pub fn create_search_prefix(&self, prefix: &[u8]) -> Vec<u8> {
             // Matches C# Neo StorageKey.CreateSearchPrefix
             let mut result = self.script_hash.to_bytes().to_vec();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:157:
             result.extend_from_slice(prefix);
             result
         }
[31m-        
(B[m[32m+
(B[m         pub fn equals(&self, other: &StorageKey) -> bool {
             // Matches C# Neo StorageKey.Equals
             self.script_hash == other.script_hash && self.key == other.key
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:164:
         }
     }
[31m-    
(B[m[32m+
(B[m     let script_hash = UInt160::from([42u8; 20]);
     let key_data = vec![1, 2, 3, 4];
     let storage_key = StorageKey::new(script_hash, key_data.clone());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:170:
[31m-    
(B[m[32m+
(B[m     assert_eq!(storage_key.script_hash, script_hash);
     assert_eq!(storage_key.key, key_data);
[31m-    
(B[m[32m+
(B[m     // Test search prefix
     let prefix = vec![0xaa, 0xbb];
     let search_prefix = storage_key.create_search_prefix(&prefix);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:177:
     assert_eq!(search_prefix.len(), 20 + 4 + 2); // script_hash + key + prefix
     assert_eq!(&search_prefix[20..24], &key_data[..]);
     assert_eq!(&search_prefix[24..26], &prefix[..]);
[31m-    
(B[m[32m+
(B[m     // Test equality
     let other_key = StorageKey::new(script_hash, key_data);
     assert!(storage_key.equals(&other_key));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:184:
[31m-    
(B[m[32m+
(B[m     let different_key = StorageKey::new(script_hash, vec![5, 6, 7, 8]);
     assert!(!storage_key.equals(&different_key));
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:194:
         pub event_name: String,
         pub state: Vec<StackItem>,
     }
[31m-    
(B[m[32m+
(B[m     #[derive(Debug, Clone, PartialEq)]
     enum StackItem {
         Null,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:203:
         ByteString(Vec<u8>),
         Array(Vec<StackItem>),
     }
[31m-    
(B[m[32m+
(B[m     impl NotifyEventArgs {
         pub fn new(script_hash: UInt160, event_name: String, state: Vec<StackItem>) -> Self {
             Self {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:213:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Test notification creation
     let script_hash = UInt160::from([99u8; 20]);
     let event_name = "Transfer".to_string();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:220:
     let state = vec![
         StackItem::ByteString(vec![1, 2, 3]), // from address
         StackItem::ByteString(vec![4, 5, 6]), // to address
[31m-        StackItem::Integer(1000000000),        // amount
(B[m[32m+        StackItem::Integer(1000000000),       // amount
(B[m     ];
[31m-    
(B[m[32m+
(B[m     let notification = NotifyEventArgs::new(script_hash, event_name.clone(), state.clone());
[31m-    
(B[m[32m+
(B[m     assert_eq!(notification.script_hash, script_hash);
     assert_eq!(notification.event_name, event_name);
     assert_eq!(notification.state, state);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:241:
         HighPriority = 0x01,
         NotValidBefore = 0x20,
     }
[31m-    
(B[m[32m+
(B[m     #[derive(Debug, Clone)]
     struct TransactionAttribute {
         attr_type: TransactionAttributeType,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:248:
         data: Vec<u8>,
     }
[31m-    
(B[m[32m+
(B[m     impl TransactionAttribute {
         pub fn new(attr_type: TransactionAttributeType, data: Vec<u8>) -> Self {
             Self { attr_type, data }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:254:
         }
[31m-        
(B[m[32m+
(B[m         pub fn get_size(&self) -> usize {
             // Matches C# Neo TransactionAttribute.Size property
             1 + self.data.len() // type byte + data
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:259:
         }
[31m-        
(B[m[32m+
(B[m         pub fn verify(&self) -> bool {
             // Matches C# Neo TransactionAttribute.Verify method pattern
             match self.attr_type {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:268:
             }
         }
     }
[31m-    
(B[m[32m+
(B[m     // Test conflict attribute
     let conflict_hash = vec![42u8; 32];
[31m-    let conflict_attr = TransactionAttribute::new(
(B[m[31m-        TransactionAttributeType::Conflicts,
(B[m[31m-        conflict_hash
(B[m[31m-    );
(B[m[31m-    
(B[m[32m+    let conflict_attr =
(B[m[32m+        TransactionAttribute::new(TransactionAttributeType::Conflicts, conflict_hash);
(B[m[32m+
(B[m     assert_eq!(conflict_attr.get_size(), 33); // 1 byte type + 32 bytes hash
     assert!(conflict_attr.verify());
[31m-    
(B[m[32m+
(B[m     // Test high priority attribute
[31m-    let priority_attr = TransactionAttribute::new(
(B[m[31m-        TransactionAttributeType::HighPriority,
(B[m[31m-        vec![]
(B[m[31m-    );
(B[m[31m-    
(B[m[32m+    let priority_attr = TransactionAttribute::new(TransactionAttributeType::HighPriority, vec![]);
(B[m[32m+
(B[m     assert_eq!(priority_attr.get_size(), 1); // Only type byte
     assert!(priority_attr.verify());
[31m-    
(B[m[32m+
(B[m     // Test invalid conflict attribute
     let invalid_conflict = TransactionAttribute::new(
         TransactionAttributeType::Conflicts,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:294:
[31m-        vec![1, 2, 3] // Wrong length
(B[m[32m+        vec![1, 2, 3], // Wrong length
(B[m     );
[31m-    
(B[m[32m+
(B[m     assert!(!invalid_conflict.verify());
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:304:
     struct ScriptBuilder {
         instructions: Vec<u8>,
     }
[31m-    
(B[m[32m+
(B[m     impl ScriptBuilder {
         pub fn new() -> Self {
             Self {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:311:
                 instructions: Vec::new(),
             }
         }
[31m-        
(B[m[32m+
(B[m         pub fn emit(&mut self, opcode: OpCode) -> &mut Self {
             self.instructions.push(opcode as u8);
             self
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:318:
         }
[31m-        
(B[m[32m+
(B[m         pub fn emit_push(&mut self, data: &[u8]) -> &mut Self {
             // Matches C# Neo ScriptBuilder.EmitPush pattern
             if data.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:332:
                 self.instructions.extend_from_slice(data);
             } else {
                 self.emit(OpCode::PUSHDATA2);
[31m-                self.instructions.extend_from_slice(&(data.len() as u16).to_le_bytes());
(B[m[32m+                self.instructions
(B[m[32m+                    .extend_from_slice(&(data.len() as u16).to_le_bytes());
(B[m                 self.instructions.extend_from_slice(data);
             }
             self
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:339:
         }
[31m-        
(B[m[32m+
(B[m         pub fn emit_call(&mut self, target: &UInt160) -> &mut Self {
             // Matches C# Neo ScriptBuilder.EmitDynamicCall
             self.emit_push(&target.to_bytes());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:344:
             self.emit(OpCode::SYSCALL);
             // Add syscall hash for System.Contract.Call
[31m-            let syscall_hash = [0x62, 0x7d, 0x5b, 0x52]; 
(B[m[32m+            let syscall_hash = [0x62, 0x7d, 0x5b, 0x52];
(B[m             self.instructions.extend_from_slice(&syscall_hash);
             self
         }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:350:
[31m-        
(B[m[32m+
(B[m         pub fn to_array(&self) -> Vec<u8> {
             self.instructions.clone()
         }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:354:
     }
[31m-    
(B[m[32m+
(B[m     #[derive(Debug, Clone, Copy)]
     #[repr(u8)]
     enum OpCode {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:362:
         PUSHDATA2 = 0x4D,
         SYSCALL = 0x41,
     }
[31m-    
(B[m[32m+
(B[m     impl std::ops::Add<u8> for OpCode {
         type Output = u8;
         fn add(self, rhs: u8) -> u8 {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:369:
             (self as u8) + rhs
         }
     }
[31m-    
(B[m[32m+
(B[m     let mut builder = ScriptBuilder::new();
[31m-    
(B[m[32m+
(B[m     // Test empty push
     builder.emit_push(&[]);
     assert_eq!(builder.instructions[0], OpCode::PUSH0 as u8);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:378:
[31m-    
(B[m[32m+
(B[m     // Test small integer push
     let mut builder2 = ScriptBuilder::new();
     builder2.emit_push(&[5]);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:382:
     assert_eq!(builder2.instructions[0], OpCode::PUSH1 as u8 + 4); // PUSH5
[31m-    
(B[m[32m+
(B[m     // Test data push
     let mut builder3 = ScriptBuilder::new();
     let test_data = vec![1, 2, 3, 4, 5];
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:387:
     builder3.emit_push(&test_data);
     assert_eq!(builder3.instructions[0], test_data.len() as u8); // Length prefix
     assert_eq!(&builder3.instructions[1..6], &test_data[..]);
[31m-    
(B[m[32m+
(B[m     // Test contract call
     let mut builder4 = ScriptBuilder::new();
     let contract_hash = UInt160::from([42u8; 20]);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:394:
     builder4.emit_call(&contract_hash);
[31m-    
(B[m[32m+
(B[m     let script = builder4.to_array();
     assert!(script.len() > 20); // At least contract hash + call instruction
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:406:
         }
         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     fn validate_public_key(pubkey: &[u8]) -> Result<(), ValidationError> {
         // C# Neo public key validation
         if pubkey.len() != 33 {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:413:
             return Err(ValidationError::InvalidPublicKeyLength);
         }
[31m-        
(B[m[32m+
(B[m         // Check compression format
         if pubkey[0] != 0x02 && pubkey[0] != 0x03 {
             return Err(ValidationError::InvalidPublicKeyFormat);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:419:
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     fn validate_signature(signature: &[u8]) -> Result<(), ValidationError> {
         // C# Neo signature validation
         if signature.len() != 64 {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:428:
         }
         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     // Test script hash validation
     let valid_hash = UInt160::from([42u8; 20]);
     assert!(validate_script_hash(&valid_hash).is_ok());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:435:
[31m-    
(B[m[32m+
(B[m     let zero_hash = UInt160::zero();
     assert!(validate_script_hash(&zero_hash).is_err());
[31m-    
(B[m[32m+
(B[m     // Test public key validation
     let valid_pubkey = {
         let mut key = vec![0x02]; // Compressed format
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:443:
         key
     };
     assert!(validate_public_key(&valid_pubkey).is_ok());
[31m-    
(B[m[32m+
(B[m     let invalid_pubkey = vec![0x01, 42u8]; // Wrong format and length
     assert!(validate_public_key(&invalid_pubkey).is_err());
[31m-    
(B[m[32m+
(B[m     // Test signature validation
     let valid_signature = vec![42u8; 64];
     assert!(validate_signature(&valid_signature).is_ok());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:453:
[31m-    
(B[m[32m+
(B[m     let invalid_signature = vec![42u8; 32]; // Wrong length
     assert!(validate_signature(&invalid_signature).is_err());
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:459:
 fn test_csharp_neo_json_rpc_compatibility() {
     // Test JSON-RPC patterns from C# Neo
     use serde_json::{json, Value};
[31m-    
(B[m[32m+
(B[m     fn create_rpc_response(id: u64, result: Value) -> Value {
         json!({
             "jsonrpc": "2.0",
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:467:
             "result": result
         })
     }
[31m-    
(B[m[32m+
(B[m     fn create_rpc_error(id: u64, code: i32, message: &str) -> Value {
         json!({
[31m-            "jsonrpc": "2.0", 
(B[m[32m+            "jsonrpc": "2.0",
(B[m             "id": id,
             "error": {
                 "code": code,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:478:
             }
         })
     }
[31m-    
(B[m[32m+
(B[m     // Test successful response
[31m-    let response = create_rpc_response(1, json!({
(B[m[31m-        "hash": "0x1234567890abcdef1234567890abcdef12345678",
(B[m[31m-        "size": 248,
(B[m[31m-        "version": 0
(B[m[31m-    }));
(B[m[31m-    
(B[m[32m+    let response = create_rpc_response(
(B[m[32m+        1,
(B[m[32m+        json!({
(B[m[32m+            "hash": "0x1234567890abcdef1234567890abcdef12345678",
(B[m[32m+            "size": 248,
(B[m[32m+            "version": 0
(B[m[32m+        }),
(B[m[32m+    );
(B[m[32m+
(B[m     assert_eq!(response["jsonrpc"], "2.0");
     assert_eq!(response["id"], 1);
     assert!(response["result"].is_object());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:492:
[31m-    
(B[m[32m+
(B[m     // Test error response
     let error_response = create_rpc_error(2, -32602, "Invalid params");
[31m-    
(B[m[32m+
(B[m     assert_eq!(error_response["jsonrpc"], "2.0");
     assert_eq!(error_response["id"], 2);
     assert_eq!(error_response["error"]["code"], -32602);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:503:
 fn test_csharp_neo_base58_encoding_pattern() {
     // Test Base58 encoding pattern from C# Neo
     const BASE58_ALPHABET: &[u8] = b"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
[31m-    
(B[m[32m+
(B[m     fn base58_encode(data: &[u8]) -> String {
         // Simplified Base58 encoding (C# Neo compatible)
         if data.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:510:
             return String::new();
         }
[31m-        
(B[m[32m+
(B[m         // Count leading zeros
         let zero_count = data.iter().take_while(|&&b| b == 0).count();
[31m-        
(B[m[32m+
(B[m         // Convert to base 58
         let mut num = num_bigint::BigUint::from_bytes_be(data);
         let mut result = String::new();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:519:
         let base = num_bigint::BigUint::from(58u8);
[31m-        
(B[m[32m+
(B[m         while num > num_bigint::BigUint::from(0u8) {
             let remainder = &num % &base;
             num = num / &base;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:524:
             let idx = remainder.to_bytes_be()[0] as usize;
             result.insert(0, BASE58_ALPHABET[idx] as char);
         }
[31m-        
(B[m[32m+
(B[m         // Add leading '1' for each leading zero byte
         "1".repeat(zero_count) + &result
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:531:
[31m-    
(B[m[32m+
(B[m     // Test with known values
     let test_data = vec![0x00, 0x01, 0x02, 0x03];
     let encoded = base58_encode(&test_data);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:535:
     assert!(!encoded.is_empty());
     assert!(encoded.starts_with('1')); // Leading zero byte
[31m-    
(B[m[32m+
(B[m     // Test empty data
     assert_eq!(base58_encode(&[]), "");
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:542:
 #[test]
 fn test_csharp_neo_cryptographic_hash_pattern() {
     // Test cryptographic hash pattern from C# Neo
[31m-    use sha2::{Sha256, Digest};
(B[m[31m-    
(B[m[32m+    use sha2::{Digest, Sha256};
(B[m[32m+
(B[m     fn hash160(data: &[u8]) -> UInt160 {
         // C# Neo Hash160: RIPEMD160(SHA256(data))
         let sha256_hash = Sha256::digest(data);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:550:
[31m-        
(B[m[32m+
(B[m         // Note: For testing, we'll use SHA256 truncated to 20 bytes
         // In production, this should be RIPEMD160(SHA256(data))
         let truncated: [u8; 20] = sha256_hash[..20].try_into().unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:554:
         UInt160::from(truncated)
     }
[31m-    
(B[m[32m+
(B[m     fn hash256(data: &[u8]) -> UInt256 {
[31m-        // C# Neo Hash256: SHA256(SHA256(data)) 
(B[m[32m+        // C# Neo Hash256: SHA256(SHA256(data))
(B[m         let first_hash = Sha256::digest(data);
         let second_hash = Sha256::digest(&first_hash);
         UInt256::from(second_hash.into())
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:562:
     }
[31m-    
(B[m[32m+
(B[m     let test_data = b"Hello Neo";
[31m-    
(B[m[32m+
(B[m     // Test Hash160
     let hash160_result = hash160(test_data);
     assert!(!hash160_result.is_zero());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:569:
[31m-    
(B[m[32m+
(B[m     // Test Hash256
     let hash256_result = hash256(test_data);
     assert!(!hash256_result.is_zero());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:573:
[31m-    
(B[m[32m+
(B[m     // Test consistency
     let hash160_again = hash160(test_data);
     let hash256_again = hash256(test_data);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:577:
[31m-    
(B[m[32m+
(B[m     assert_eq!(hash160_result, hash160_again);
     assert_eq!(hash256_result, hash256_again);
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:586:
         if gas_limit == 0 {
             return Err(VMException::OutOfGas);
         }
[31m-        
(B[m[32m+
(B[m         if gas_limit < 1000 {
[31m-            return Err(VMException::InsufficientGas("Minimum 1000 gas required".to_string()));
(B[m[32m+            return Err(VMException::InsufficientGas(
(B[m[32m+                "Minimum 1000 gas required".to_string(),
(B[m[32m+            ));
(B[m         }
[31m-        
(B[m[32m+
(B[m         // Simulate execution
         let gas_consumed = 500;
         if gas_consumed > gas_limit {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:597:
             return Err(VMException::OutOfGas);
         }
[31m-        
(B[m[32m+
(B[m         Ok(ExecutionResult {
             state: VMState::Halt,
             gas_consumed,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:603:
             stack: vec![],
         })
     }
[31m-    
(B[m[32m+
(B[m     // Test successful execution
     let result = execute_with_gas_limit(2000);
     assert!(result.is_ok());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:610:
[31m-    
(B[m[32m+
(B[m     let exec_result = result.unwrap();
     assert_eq!(exec_result.state, VMState::Halt);
     assert_eq!(exec_result.gas_consumed, 500);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:614:
[31m-    
(B[m[32m+
(B[m     // Test gas limit errors
     let result_zero = execute_with_gas_limit(0);
     assert!(matches!(result_zero.unwrap_err(), VMException::OutOfGas));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:618:
[31m-    
(B[m[32m+
(B[m     let result_low = execute_with_gas_limit(500);
[31m-    assert!(matches!(result_low.unwrap_err(), VMException::InsufficientGas(_)));
(B[m[32m+    assert!(matches!(
(B[m[32m+        result_low.unwrap_err(),
(B[m[32m+        VMException::InsufficientGas(_)
(B[m[32m+    ));
(B[m }
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/csharp_neo_patterns_tests.rs:674:
 use num_bigint;
 use serde_json;
 use sha2;
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:1:
 //! Enhanced Policy contract tests - Comprehensive coverage addressing identified gaps
 //! Provides 10+ additional tests for Policy native contract functionality
 
[31m-use neo_smart_contract::native::policy_contract::PolicyContract;
(B[m use neo_core::UInt160;
[32m+use neo_smart_contract::native::policy_contract::PolicyContract;
(B[m 
 // ============================================================================
 // Enhanced Policy Contract Tests (10+ additional tests)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:13:
     // Test fee calculations for different transaction sizes
     let policy = PolicyContract::new();
     let base_fee_per_byte = PolicyContract::DEFAULT_FEE_PER_BYTE;
[31m-    
(B[m[32m+
(B[m     let test_cases = vec![
         (100, base_fee_per_byte * 100),   // Small transaction
[31m-        (500, base_fee_per_byte * 500),   // Medium transaction  
(B[m[32m+        (500, base_fee_per_byte * 500),   // Medium transaction
(B[m         (1000, base_fee_per_byte * 1000), // Large transaction
     ];
[31m-    
(B[m[32m+
(B[m     for (size, expected_fee) in test_cases {
         // Test fee calculation logic
         let calculated_fee = base_fee_per_byte * size;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:26:
[31m-        assert_eq!(calculated_fee, expected_fee, 
(B[m[31m-                  "Fee calculation should match for size {}", size);
(B[m[32m+        assert_eq!(
(B[m[32m+            calculated_fee, expected_fee,
(B[m[32m+            "Fee calculation should match for size {}",
(B[m[32m+            size
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:33:
     // Test storage pricing mechanisms
     let policy = PolicyContract::new();
     let base_storage_price = PolicyContract::DEFAULT_STORAGE_PRICE;
[31m-    
(B[m[32m+
(B[m     // Test different storage amounts
     let storage_amounts = vec![1, 10, 100, 1000];
[31m-    
(B[m[32m+
(B[m     for amount in storage_amounts {
         let storage_cost = base_storage_price * amount;
[31m-        assert!(storage_cost >= base_storage_price * amount, 
(B[m[31m-               "Storage cost should be at least base price * amount for {}", amount);
(B[m[32m+        assert!(
(B[m[32m+            storage_cost >= base_storage_price * amount,
(B[m[32m+            "Storage cost should be at least base price * amount for {}",
(B[m[32m+            amount
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:49:
     // Test execution fee factor validation
     let policy = PolicyContract::new();
     let default_factor = PolicyContract::DEFAULT_EXEC_FEE_FACTOR;
[31m-    
(B[m[32m+
(B[m     // Test valid execution factors
     let valid_factors = vec![1, 10, 30, 100, 1000];
[31m-    
(B[m[32m+
(B[m     for factor in valid_factors {
         // Test that factors are within reasonable ranges
         assert!(factor > 0, "Execution factor {} should be positive", factor);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:59:
[31m-        assert!(factor <= 10000, "Execution factor {} should be reasonable", factor);
(B[m[32m+        assert!(
(B[m[32m+            factor <= 10000,
(B[m[32m+            "Execution factor {} should be reasonable",
(B[m[32m+            factor
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Test default factor is valid
[31m-    assert!(default_factor > 0 && default_factor <= 10000, 
(B[m[31m-           "Default execution factor should be valid");
(B[m[32m+    assert!(
(B[m[32m+        default_factor > 0 && default_factor <= 10000,
(B[m[32m+        "Default execution factor should be valid"
(B[m[32m+    );
(B[m }
 
[31m-#[test] 
(B[m[32m+#[test]
(B[m fn test_policy_contract_block_limits() {
     // Test block size and transaction limits
     let policy = PolicyContract::new();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:71:
[31m-    
(B[m[32m+
(B[m     let max_block_size = PolicyContract::MAX_BLOCK_SIZE;
     let max_transactions = PolicyContract::MAX_TRANSACTIONS_PER_BLOCK;
     let max_system_fee = PolicyContract::MAX_BLOCK_SYSTEM_FEE;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:75:
[31m-    
(B[m[32m+
(B[m     // Validate reasonable limits
     assert!(max_block_size > 0, "Max block size should be positive");
     assert!(max_transactions > 0, "Max transactions should be positive");
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:79:
     assert!(max_system_fee > 0, "Max system fee should be positive");
[31m-    
(B[m[32m+
(B[m     // Test limit validation logic
[31m-    assert!(max_block_size / 2 < max_block_size, "Half max block size should be valid");
(B[m[31m-    assert!(max_block_size + 1 > max_block_size, "Over max block size should be invalid");
(B[m[32m+    assert!(
(B[m[32m+        max_block_size / 2 < max_block_size,
(B[m[32m+        "Half max block size should be valid"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        max_block_size + 1 > max_block_size,
(B[m[32m+        "Over max block size should be invalid"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:92:
         UInt160::from([100u8; 20]),
         UInt160::from([255u8; 20]),
     ];
[31m-    
(B[m[32m+
(B[m     // Test account hash validity
     for account in &test_accounts {
         assert!(!account.is_zero(), "Test account should have valid hash");
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:99:
[31m-        assert_eq!(account.to_bytes().len(), 20, "Account hash should be 20 bytes");
(B[m[32m+        assert_eq!(
(B[m[32m+            account.to_bytes().len(),
(B[m[32m+            20,
(B[m[32m+            "Account hash should be 20 bytes"
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Test accounts are different
     assert_ne!(test_accounts[0], test_accounts[1]);
     assert_ne!(test_accounts[1], test_accounts[2]);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:110:
     // Test fee per byte boundary conditions
     let policy = PolicyContract::new();
     let default_fee = PolicyContract::DEFAULT_FEE_PER_BYTE;
[31m-    
(B[m[32m+
(B[m     // Test boundary values
     let boundary_fees = vec![1, 100, 1000, 10000, 100000];
[31m-    
(B[m[32m+
(B[m     for fee in boundary_fees {
         // Test fee validation logic
         assert!(fee > 0, "Fee {} should be positive", fee);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:120:
[31m-        
(B[m[32m+
(B[m         // Test fee calculations
         let tx_size = 250u32;
         let total_fee = fee * tx_size;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:124:
[31m-        assert_eq!(total_fee, fee * tx_size, "Fee calculation should be accurate");
(B[m[32m+        assert_eq!(
(B[m[32m+            total_fee,
(B[m[32m+            fee * tx_size,
(B[m[32m+            "Fee calculation should be accurate"
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Test default fee is reasonable
[31m-    assert!(default_fee >= 100 && default_fee <= 100000, 
(B[m[31m-           "Default fee should be in reasonable range");
(B[m[32m+    assert!(
(B[m[32m+        default_fee >= 100 && default_fee <= 100000,
(B[m[32m+        "Default fee should be in reasonable range"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:134:
     // Test max traceable blocks configuration
     let policy = PolicyContract::new();
     let max_traceable = PolicyContract::MAX_MAX_TRACEABLE_BLOCKS;
[31m-    
(B[m[32m+
(B[m     // Should have reasonable limit
     assert!(max_traceable > 0, "Max traceable blocks should be positive");
[31m-    assert!(max_traceable <= 2102400, "Max traceable should not exceed ~1 year");
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        max_traceable <= 2102400,
(B[m[32m+        "Max traceable should not exceed ~1 year"
(B[m[32m+    );
(B[m[32m+
(B[m     // Test boundary conditions
     let test_values = vec![
[31m-        max_traceable / 4,     // Quarter max
(B[m[31m-        max_traceable / 2,     // Half max
(B[m[31m-        max_traceable - 1,     // Just under max
(B[m[31m-        max_traceable,         // Exactly max
(B[m[32m+        max_traceable / 4, // Quarter max
(B[m[32m+        max_traceable / 2, // Half max
(B[m[32m+        max_traceable - 1, // Just under max
(B[m[32m+        max_traceable,     // Exactly max
(B[m     ];
[31m-    
(B[m[32m+
(B[m     for value in test_values {
[31m-        assert!(value <= max_traceable, "Value {} should not exceed max", value);
(B[m[32m+        assert!(
(B[m[32m+            value <= max_traceable,
(B[m[32m+            "Value {} should not exceed max",
(B[m[32m+            value
(B[m[32m+        );
(B[m         assert!(value > 0, "Value {} should be positive", value);
     }
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:158:
     // Test attribute fee configuration
     let policy = PolicyContract::new();
     let default_attribute_fee = PolicyContract::DEFAULT_ATTRIBUTE_FEE;
[31m-    
(B[m[32m+
(B[m     // Test attribute fee calculation logic
     let attribute_counts = vec![0, 1, 5, 10, 20];
[31m-    
(B[m[32m+
(B[m     for count in attribute_counts {
         let total_attribute_fee = default_attribute_fee * count;
[31m-        assert_eq!(total_attribute_fee, default_attribute_fee * count, 
(B[m[31m-                  "Attribute fee should be count * default fee for count {}", count);
(B[m[32m+        assert_eq!(
(B[m[32m+            total_attribute_fee,
(B[m[32m+            default_attribute_fee * count,
(B[m[32m+            "Attribute fee should be count * default fee for count {}",
(B[m[32m+            count
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Test zero attributes
     let zero_fee = default_attribute_fee * 0;
     assert_eq!(zero_fee, 0, "Zero attributes should have zero fee");
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:178:
     // Test system fee validation logic
     let policy = PolicyContract::new();
     let max_system_fee = PolicyContract::MAX_BLOCK_SYSTEM_FEE;
[31m-    
(B[m[32m+
(B[m     // Test valid system fees
     let valid_fees = vec![
[31m-        0,                        // Zero fee
(B[m[31m-        max_system_fee / 2,       // Half max
(B[m[31m-        max_system_fee - 1,       // Just under max
(B[m[31m-        max_system_fee,           // Exactly max
(B[m[32m+        0,                  // Zero fee
(B[m[32m+        max_system_fee / 2, // Half max
(B[m[32m+        max_system_fee - 1, // Just under max
(B[m[32m+        max_system_fee,     // Exactly max
(B[m     ];
[31m-    
(B[m[32m+
(B[m     for fee in valid_fees {
[31m-        assert!(fee <= max_system_fee, "System fee {} should not exceed max", fee);
(B[m[32m+        assert!(
(B[m[32m+            fee <= max_system_fee,
(B[m[32m+            "System fee {} should not exceed max",
(B[m[32m+            fee
(B[m[32m+        );
(B[m         assert!(fee >= 0, "System fee {} should be non-negative", fee);
     }
[31m-    
(B[m[32m+
(B[m     // Test invalid system fee (over max)
     let invalid_fee = max_system_fee + 1;
[31m-    assert!(invalid_fee > max_system_fee, "Over-max fee should exceed limit");
(B[m[32m+    assert!(
(B[m[32m+        invalid_fee > max_system_fee,
(B[m[32m+        "Over-max fee should exceed limit"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:201:
 fn test_policy_contract_comprehensive_limits() {
     // Test comprehensive policy limits work together
     let policy = PolicyContract::new();
[31m-    
(B[m[32m+
(B[m     // Test all default constants are reasonable
     let max_block_size = PolicyContract::MAX_BLOCK_SIZE;
     let max_transactions = PolicyContract::MAX_TRANSACTIONS_PER_BLOCK;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:209:
     let fee_per_byte = PolicyContract::DEFAULT_FEE_PER_BYTE;
     let exec_fee_factor = PolicyContract::DEFAULT_EXEC_FEE_FACTOR;
     let storage_price = PolicyContract::DEFAULT_STORAGE_PRICE;
[31m-    
(B[m[32m+
(B[m     // All limits should be positive and reasonable
[31m-    assert!(max_block_size > 0 && max_block_size <= 16_777_216, 
(B[m[31m-           "Block size limit should be reasonable"); // 16MB max
(B[m[31m-    assert!(max_transactions > 0 && max_transactions <= 65536, 
(B[m[31m-           "Transaction limit should be reasonable");
(B[m[32m+    assert!(
(B[m[32m+        max_block_size > 0 && max_block_size <= 16_777_216,
(B[m[32m+        "Block size limit should be reasonable"
(B[m[32m+    ); // 16MB max
(B[m[32m+    assert!(
(B[m[32m+        max_transactions > 0 && max_transactions <= 65536,
(B[m[32m+        "Transaction limit should be reasonable"
(B[m[32m+    );
(B[m     assert!(max_system_fee > 0, "System fee limit should be positive");
     assert!(fee_per_byte > 0, "Fee per byte should be positive");
     assert!(exec_fee_factor > 0, "Exec fee factor should be positive");
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:221:
     assert!(storage_price > 0, "Storage price should be positive");
[31m-    
(B[m[32m+
(B[m     // Test that limits work together logically
     let estimated_min_tx_size = 100u32; // bytes
     let theoretical_max_fee = max_transactions * fee_per_byte * estimated_min_tx_size;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:226:
[31m-    
(B[m[32m+
(B[m     // The system should be able to handle theoretical maximums
[31m-    assert!(theoretical_max_fee > 0, "Theoretical max fee should be calculable");
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        theoretical_max_fee > 0,
(B[m[32m+        "Theoretical max fee should be calculable"
(B[m[32m+    );
(B[m[32m+
(B[m     // Test storage and execution fees are related
     let storage_factor = storage_price / fee_per_byte;
[31m-    assert!(storage_factor >= 1, "Storage should cost more per byte than network fee");
(B[m[32m+    assert!(
(B[m[32m+        storage_factor >= 1,
(B[m[32m+        "Storage should cost more per byte than network fee"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:236:
 fn test_policy_contract_constants_consistency() {
     // Test that all policy constants are consistent and valid
     let policy = PolicyContract::new();
[31m-    
(B[m[32m+
(B[m     // Test key byte arrays are valid
[31m-    assert!(!PolicyContract::MAX_BLOCK_SIZE_KEY.is_empty(), 
(B[m[31m-           "Max block size key should not be empty");
(B[m[31m-    assert!(!PolicyContract::MAX_BLOCK_SYSTEM_FEE_KEY.is_empty(), 
(B[m[31m-           "Max system fee key should not be empty");
(B[m[31m-    assert!(!PolicyContract::FEE_PER_BYTE_KEY.is_empty(), 
(B[m[31m-           "Fee per byte key should not be empty");
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        !PolicyContract::MAX_BLOCK_SIZE_KEY.is_empty(),
(B[m[32m+        "Max block size key should not be empty"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        !PolicyContract::MAX_BLOCK_SYSTEM_FEE_KEY.is_empty(),
(B[m[32m+        "Max system fee key should not be empty"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        !PolicyContract::FEE_PER_BYTE_KEY.is_empty(),
(B[m[32m+        "Fee per byte key should not be empty"
(B[m[32m+    );
(B[m[32m+
(B[m     // Test keys have reasonable lengths
[31m-    assert!(PolicyContract::MAX_BLOCK_SIZE_KEY.len() <= 64, 
(B[m[31m-           "Key should not be too long");
(B[m[31m-    assert!(PolicyContract::MAX_BLOCK_SYSTEM_FEE_KEY.len() <= 64, 
(B[m[31m-           "Key should not be too long");
(B[m[31m-    assert!(PolicyContract::FEE_PER_BYTE_KEY.len() <= 64, 
(B[m[31m-           "Key should not be too long");
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        PolicyContract::MAX_BLOCK_SIZE_KEY.len() <= 64,
(B[m[32m+        "Key should not be too long"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        PolicyContract::MAX_BLOCK_SYSTEM_FEE_KEY.len() <= 64,
(B[m[32m+        "Key should not be too long"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        PolicyContract::FEE_PER_BYTE_KEY.len() <= 64,
(B[m[32m+        "Key should not be too long"
(B[m[32m+    );
(B[m[32m+
(B[m     // Test key contents are ASCII-like
[31m-    for key in [PolicyContract::MAX_BLOCK_SIZE_KEY, 
(B[m[31m-                PolicyContract::MAX_BLOCK_SYSTEM_FEE_KEY,
(B[m[31m-                PolicyContract::FEE_PER_BYTE_KEY] {
(B[m[32m+    for key in [
(B[m[32m+        PolicyContract::MAX_BLOCK_SIZE_KEY,
(B[m[32m+        PolicyContract::MAX_BLOCK_SYSTEM_FEE_KEY,
(B[m[32m+        PolicyContract::FEE_PER_BYTE_KEY,
(B[m[32m+    ] {
(B[m         for &byte in key {
[31m-            assert!(byte >= 32 && byte <= 126, 
(B[m[31m-                   "Key bytes should be printable ASCII");
(B[m[32m+            assert!(
(B[m[32m+                byte >= 32 && byte <= 126,
(B[m[32m+                "Key bytes should be printable ASCII"
(B[m[32m+            );
(B[m         }
     }
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:268:
 fn test_policy_contract_method_signatures() {
     // Test policy contract method signatures and metadata
     let policy = PolicyContract::new();
[31m-    
(B[m[32m+
(B[m     // Contract should have valid hash and ID
[31m-    assert!(!policy.get_hash().is_zero(), "Policy contract should have valid hash");
(B[m[32m+    assert!(
(B[m[32m+        !policy.get_hash().is_zero(),
(B[m[32m+        "Policy contract should have valid hash"
(B[m[32m+    );
(B[m     assert!(policy.get_id() >= 0, "Policy contract should have valid ID");
[31m-    
(B[m[32m+
(B[m     // Contract should have methods
     let methods = policy.get_methods();
     assert!(!methods.is_empty(), "Policy contract should have methods");
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:279:
[31m-    
(B[m[32m+
(B[m     // Methods should have valid properties
     for method in methods {
         assert!(!method.name.is_empty(), "Method name should not be empty");
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:283:
         assert!(method.gas >= 0, "Method gas cost should be non-negative");
[31m-        
(B[m[32m+
(B[m         // Method names should be reasonable length
[31m-        assert!(method.name.len() <= 64, "Method name should not be too long");
(B[m[32m+        assert!(
(B[m[32m+            method.name.len() <= 64,
(B[m[32m+            "Method name should not be too long"
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[32m+
(B[m     // Policy contract manifest should be valid
     let manifest = policy.get_manifest();
[31m-    assert!(!manifest.name.is_empty(), "Contract manifest should have name");
(B[m[32m+    assert!(
(B[m[32m+        !manifest.name.is_empty(),
(B[m[32m+        "Contract manifest should have name"
(B[m[32m+    );
(B[m }
 
 #[cfg(test)]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:295:
 mod integration_tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_policy_contract_full_integration() {
         // Test full Policy contract integration
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:301:
         let policy = PolicyContract::new();
[31m-        
(B[m[32m+
(B[m         // Test contract creation and initialization
         assert!(!policy.get_hash().is_zero());
         assert!(!policy.get_methods().is_empty());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:306:
[31m-        
(B[m[32m+
(B[m         // Test all default values are set
         let fee_per_byte = PolicyContract::DEFAULT_FEE_PER_BYTE;
         let storage_price = PolicyContract::DEFAULT_STORAGE_PRICE;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:310:
         let exec_fee_factor = PolicyContract::DEFAULT_EXEC_FEE_FACTOR;
[31m-        
(B[m[32m+
(B[m         assert!(fee_per_byte > 0);
         assert!(storage_price > 0);
         assert!(exec_fee_factor > 0);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:315:
[31m-        
(B[m[32m+
(B[m         // Test complex fee calculations
         let transaction_size = 500u32;
         let storage_size = 100u32;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:319:
         let execution_ops = 1000u32;
[31m-        
(B[m[32m+
(B[m         let network_fee = fee_per_byte * transaction_size;
         let storage_fee = storage_price * storage_size;
         let execution_fee = exec_fee_factor * execution_ops;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/enhanced_policy_contract_tests.rs:324:
[31m-        
(B[m[32m+
(B[m         let total_fee = network_fee + storage_fee + execution_fee;
[31m-        
(B[m[31m-        assert!(total_fee > network_fee, "Total fee should include all components");
(B[m[31m-        assert!(total_fee > storage_fee, "Total fee should include all components");
(B[m[31m-        assert!(total_fee > execution_fee, "Total fee should include all components");
(B[m[32m+
(B[m[32m+        assert!(
(B[m[32m+            total_fee > network_fee,
(B[m[32m+            "Total fee should include all components"
(B[m[32m+        );
(B[m[32m+        assert!(
(B[m[32m+            total_fee > storage_fee,
(B[m[32m+            "Total fee should include all components"
(B[m[32m+        );
(B[m[32m+        assert!(
(B[m[32m+            total_fee > execution_fee,
(B[m[32m+            "Total fee should include all components"
(B[m[32m+        );
(B[m     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:465:
                 } else {
                     panic!("Invalid attribute type parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "getStoragePrice" => StackItem::Integer(Self::DEFAULT_STORAGE_PRICE),
             "getExecFeeFactor" => StackItem::Integer(Self::DEFAULT_EXEC_FEE_FACTOR),
             "isBlocked" => StackItem::Boolean(false), // Default not blocked
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:484:
         if witness.is_none() {
             panic!("No witness provided");
         }
[31m-        
(B[m[32m+
(B[m         match method {
             "setAttributeFee" => {
                 if params.len() >= 2 {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:491:
[31m-                    if let (Some(ContractParameter::Integer(attr_type)), Some(ContractParameter::Integer(fee))) = 
(B[m[31m-                        (params.get(0), params.get(1)) {
(B[m[32m+                    if let (
(B[m[32m+                        Some(ContractParameter::Integer(attr_type)),
(B[m[32m+                        Some(ContractParameter::Integer(fee)),
(B[m[32m+                    ) = (params.get(0), params.get(1))
(B[m[32m+                    {
(B[m                         // Validate fee range (simplified)
                         if *fee > 10_0000_0000 {
                             panic!("Fee too high");
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:502:
                 } else {
                     panic!("Insufficient parameters")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "setFeePerByte" => {
                 if let Some(ContractParameter::Integer(fee)) = params.first() {
                     // Store fee per byte (in real implementation)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:510:
                 } else {
                     panic!("Invalid fee parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "setStoragePrice" => {
                 if let Some(ContractParameter::Integer(price)) = params.first() {
                     // Store storage price (in real implementation)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:518:
                 } else {
                     panic!("Invalid price parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "setExecFeeFactor" => {
                 if let Some(ContractParameter::Integer(factor)) = params.first() {
                     // Store execution fee factor (in real implementation)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:526:
                 } else {
                     panic!("Invalid factor parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "blockAccount" => {
                 if let Some(ContractParameter::Hash160(_account)) = params.first() {
                     // Block account (in real implementation)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:534:
                 } else {
                     panic!("Invalid account parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "unblockAccount" => {
                 if let Some(ContractParameter::Hash160(_account)) = params.first() {
                     // Unblock account (in real implementation)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:542:
                 } else {
                     panic!("Invalid account parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             _ => StackItem::Null,
         }
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:551:
 impl NeoToken {
     fn get_committee_address(&self, _engine: &ApplicationEngine) -> UInt160 {
         // Return a test committee address
[31m-        UInt160::from([0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
(B[m[31m-                      0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
(B[m[31m-                      0x12, 0x34, 0x56, 0x78])
(B[m[32m+        UInt160::from([
(B[m[32m+            0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
(B[m[32m+            0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
(B[m[32m+        ])
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/notify_event_args_tests.rs:7:
 use neo_smart_contract::{ApplicationEngine, NotifyEventArgs, OpCode, ScriptBuilder, TriggerType};
 use neo_vm::types::{Array, StackItem};
 use neo_vm::ReferenceCounter;
[31m-use std::rc::Rc;
(B[m use std::cell::RefCell;
[32m+use std::rc::Rc;
(B[m 
 // ============================================================================
 // Test NotifyEventArgs basic functionality
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:1:
 //! Comprehensive Oracle contract tests - Addressing identified test coverage gaps
 //! Provides 15+ tests for Oracle native contract functionality
 
[31m-use neo_smart_contract::native::oracle_contract::{OracleContract, OracleRequest, OracleNode};
(B[m[31m-use neo_smart_contract::application_engine::ApplicationEngine;
(B[m use neo_core::{UInt160, UInt256};
 use neo_cryptography::ECPoint;
[32m+use neo_smart_contract::application_engine::ApplicationEngine;
(B[m[32m+use neo_smart_contract::native::oracle_contract::{OracleContract, OracleNode, OracleRequest};
(B[m 
 // ============================================================================
 // Oracle Contract Initialization Tests (5 tests)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:14:
 fn test_oracle_contract_creation() {
     // Test Oracle contract can be created
     let oracle = OracleContract::new();
[31m-    
(B[m[31m-    assert!(!oracle.get_hash().is_zero(), "Oracle contract should have valid hash");
(B[m[31m-    assert!(oracle.get_methods().len() > 0, "Oracle contract should have methods");
(B[m[32m+
(B[m[32m+    assert!(
(B[m[32m+        !oracle.get_hash().is_zero(),
(B[m[32m+        "Oracle contract should have valid hash"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        oracle.get_methods().len() > 0,
(B[m[32m+        "Oracle contract should have methods"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:24:
     // Test Oracle contract hash is consistent
     let oracle1 = OracleContract::new();
     let oracle2 = OracleContract::new();
[31m-    
(B[m[31m-    assert_eq!(oracle1.get_hash(), oracle2.get_hash(), 
(B[m[31m-              "Oracle contract hash should be consistent");
(B[m[32m+
(B[m[32m+    assert_eq!(
(B[m[32m+        oracle1.get_hash(),
(B[m[32m+        oracle2.get_hash(),
(B[m[32m+        "Oracle contract hash should be consistent"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:34:
     // Test Oracle contract methods are properly registered
     let oracle = OracleContract::new();
     let methods = oracle.get_methods();
[31m-    
(B[m[32m+
(B[m     // Oracle should have key methods like request, finish, setPrice, etc.
     assert!(methods.len() >= 3, "Oracle should have at least 3 methods");
[31m-    
(B[m[32m+
(B[m     // Methods should have valid names and gas costs
     for method in methods {
         assert!(!method.name.is_empty(), "Method name should not be empty");
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:49:
 fn test_oracle_contract_native_compliance() {
     // Test Oracle contract follows native contract interface
     let oracle = OracleContract::new();
[31m-    
(B[m[32m+
(B[m     // Should have valid contract metadata
[31m-    assert!(!oracle.get_hash().is_zero(), "Should have valid contract hash");
(B[m[32m+    assert!(
(B[m[32m+        !oracle.get_hash().is_zero(),
(B[m[32m+        "Should have valid contract hash"
(B[m[32m+    );
(B[m     assert!(oracle.get_id() >= 0, "Should have valid contract ID");
[31m-    assert!(!oracle.get_manifest().name.is_empty(), "Should have contract name");
(B[m[32m+    assert!(
(B[m[32m+        !oracle.get_manifest().name.is_empty(),
(B[m[32m+        "Should have contract name"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:60:
 fn test_oracle_contract_default_configuration() {
     // Test Oracle contract default configuration values
     let oracle = OracleContract::new();
[31m-    
(B[m[32m+
(B[m     // Test default gas costs and limits
[31m-    assert!(oracle.get_price() >= 0, "Default price should be non-negative");
(B[m[31m-    assert!(oracle.get_max_url_length() > 0, "Max URL length should be positive");
(B[m[31m-    assert!(oracle.get_max_filter_length() >= 0, "Max filter length should be non-negative");
(B[m[32m+    assert!(
(B[m[32m+        oracle.get_price() >= 0,
(B[m[32m+        "Default price should be non-negative"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        oracle.get_max_url_length() > 0,
(B[m[32m+        "Max URL length should be positive"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        oracle.get_max_filter_length() >= 0,
(B[m[32m+        "Max filter length should be non-negative"
(B[m[32m+    );
(B[m }
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:83:
         user_data: vec![0x42, 0x43, 0x44],
         gas_for_response: 1000000,
     };
[31m-    
(B[m[32m+
(B[m     assert_eq!(request.id, 1);
     assert_eq!(request.url, "https://api.example.com/data");
     assert_eq!(request.filter, Some("$.price".to_string()));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:104:
         user_data: vec![],
         gas_for_response: 500000,
     };
[31m-    
(B[m[32m+
(B[m     // Valid request should have all required fields
     assert!(valid_request.id > 0, "Request ID should be positive");
[31m-    assert!(!valid_request.requesting_contract.is_zero(), "Requesting contract should be valid");
(B[m[32m+    assert!(
(B[m[32m+        !valid_request.requesting_contract.is_zero(),
(B[m[32m+        "Requesting contract should be valid"
(B[m[32m+    );
(B[m     assert!(!valid_request.url.is_empty(), "URL should not be empty");
[31m-    assert!(!valid_request.callback.is_empty(), "Callback should not be empty");
(B[m[31m-    assert!(valid_request.gas_for_response > 0, "Gas for response should be positive");
(B[m[32m+    assert!(
(B[m[32m+        !valid_request.callback.is_empty(),
(B[m[32m+        "Callback should not be empty"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        valid_request.gas_for_response > 0,
(B[m[32m+        "Gas for response should be positive"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:121:
         "http://localhost:3000/test",
         "https://secure.api.io/endpoint?param=value",
     ];
[31m-    
(B[m[32m+
(B[m     for (i, url) in test_cases.iter().enumerate() {
         let request = OracleRequest {
             id: (i + 10) as u64,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:132:
             user_data: vec![],
             gas_for_response: 750000,
         };
[31m-        
(B[m[32m+
(B[m         assert_eq!(request.url, *url, "URL should match expected format");
[31m-        assert!(request.url.starts_with("http"), "URL should have valid protocol");
(B[m[32m+        assert!(
(B[m[32m+            request.url.starts_with("http"),
(B[m[32m+            "URL should have valid protocol"
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:147:
         "$..temperature",
         "$.exchange.rates.USD",
     ];
[31m-    
(B[m[32m+
(B[m     for (i, filter) in filter_patterns.iter().enumerate() {
         let request = OracleRequest {
             id: (i + 20) as u64,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:158:
             user_data: vec![i as u8],
             gas_for_response: 1000000,
         };
[31m-        
(B[m[32m+
(B[m         assert_eq!(request.filter.as_ref().unwrap(), filter);
[31m-        assert!(request.filter.as_ref().unwrap().starts_with("$"), 
(B[m[31m-               "Filter should be valid JSONPath expression");
(B[m[32m+        assert!(
(B[m[32m+            request.filter.as_ref().unwrap().starts_with("$"),
(B[m[32m+            "Filter should be valid JSONPath expression"
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:170:
     // Test gas calculations for Oracle requests
     let base_gas = 500000i64;
     let additional_gas = 250000i64;
[31m-    
(B[m[32m+
(B[m     let request = OracleRequest {
         id: 100,
         requesting_contract: UInt160::from([100u8; 20]),
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:180:
         user_data: vec![0u8; 100], // Large user data
         gas_for_response: base_gas + additional_gas,
     };
[31m-    
(B[m[32m+
(B[m     assert_eq!(request.gas_for_response, 750000);
[31m-    assert!(request.gas_for_response > base_gas, "Should account for additional complexity");
(B[m[31m-    assert!(request.user_data.len() == 100, "User data should be preserved");
(B[m[32m+    assert!(
(B[m[32m+        request.gas_for_response > base_gas,
(B[m[32m+        "Should account for additional complexity"
(B[m[32m+    );
(B[m[32m+    assert!(
(B[m[32m+        request.user_data.len() == 100,
(B[m[32m+        "User data should be preserved"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:198:
         user_data: vec![1, 2, 3, 4, 5],
         gas_for_response: 2000000,
     };
[31m-    
(B[m[32m+
(B[m     // Test serialization (assuming serde is available)
     let serialized = serde_json::to_string(&original).expect("Should serialize");
[31m-    assert!(!serialized.is_empty(), "Serialized data should not be empty");
(B[m[31m-    
(B[m[31m-    let deserialized: OracleRequest = serde_json::from_str(&serialized).expect("Should deserialize");
(B[m[32m+    assert!(
(B[m[32m+        !serialized.is_empty(),
(B[m[32m+        "Serialized data should not be empty"
(B[m[32m+    );
(B[m[32m+
(B[m[32m+    let deserialized: OracleRequest =
(B[m[32m+        serde_json::from_str(&serialized).expect("Should deserialize");
(B[m     assert_eq!(deserialized.id, original.id);
     assert_eq!(deserialized.url, original.url);
     assert_eq!(deserialized.filter, original.filter);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:219:
 fn test_oracle_node_creation() {
     // Test creating Oracle node
     let test_key = ECPoint::from_bytes(&[
[31m-        0x02, 0x48, 0x6f, 0xd1, 0x57, 0x02, 0xc4, 0x49, 0x0a, 0x26, 0x70, 0x31, 0x12, 0xa5, 0xcc, 0x1d,
(B[m[31m-        0x09, 0x23, 0xfd, 0x69, 0x7a, 0x33, 0x40, 0x6b, 0xd5, 0xa1, 0xc0, 0x0e, 0x00, 0x13, 0xb0, 0x9a, 0x70
(B[m[31m-    ]).expect("Should create valid ECPoint");
(B[m[31m-    
(B[m[32m+        0x02, 0x48, 0x6f, 0xd1, 0x57, 0x02, 0xc4, 0x49, 0x0a, 0x26, 0x70, 0x31, 0x12, 0xa5, 0xcc,
(B[m[32m+        0x1d, 0x09, 0x23, 0xfd, 0x69, 0x7a, 0x33, 0x40, 0x6b, 0xd5, 0xa1, 0xc0, 0x0e, 0x00, 0x13,
(B[m[32m+        0xb0, 0x9a, 0x70,
(B[m[32m+    ])
(B[m[32m+    .expect("Should create valid ECPoint");
(B[m[32m+
(B[m     let node = OracleNode {
         script_hash: UInt160::from([42u8; 20]),
         public_key: test_key,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:229:
         is_active: true,
     };
[31m-    
(B[m[32m+
(B[m     assert_eq!(node.script_hash, UInt160::from([42u8; 20]));
     assert!(node.is_active);
     assert_eq!(node.public_key.to_bytes().len(), 33); // Compressed public key
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:238:
 fn test_oracle_node_activation() {
     // Test Oracle node activation/deactivation
     let test_key = ECPoint::from_bytes(&[
[31m-        0x03, 0x88, 0x6f, 0xd1, 0x57, 0x02, 0xc4, 0x49, 0x0a, 0x26, 0x70, 0x31, 0x12, 0xa5, 0xcc, 0x1d,
(B[m[31m-        0x09, 0x23, 0xfd, 0x69, 0x7a, 0x33, 0x40, 0x6b, 0xd5, 0xa1, 0xc0, 0x0e, 0x00, 0x13, 0xb0, 0x9a, 0x70
(B[m[31m-    ]).expect("Should create valid ECPoint");
(B[m[31m-    
(B[m[32m+        0x03, 0x88, 0x6f, 0xd1, 0x57, 0x02, 0xc4, 0x49, 0x0a, 0x26, 0x70, 0x31, 0x12, 0xa5, 0xcc,
(B[m[32m+        0x1d, 0x09, 0x23, 0xfd, 0x69, 0x7a, 0x33, 0x40, 0x6b, 0xd5, 0xa1, 0xc0, 0x0e, 0x00, 0x13,
(B[m[32m+        0xb0, 0x9a, 0x70,
(B[m[32m+    ])
(B[m[32m+    .expect("Should create valid ECPoint");
(B[m[32m+
(B[m     let mut node = OracleNode {
         script_hash: UInt160::from([99u8; 20]),
         public_key: test_key,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:248:
         is_active: false,
     };
[31m-    
(B[m[32m+
(B[m     // Initially inactive
     assert!(!node.is_active);
[31m-    
(B[m[32m+
(B[m     // Activate node
     node.is_active = true;
     assert!(node.is_active);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:257:
[31m-    
(B[m[32m+
(B[m     // Deactivate node
     node.is_active = false;
     assert!(!node.is_active);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:264:
 fn test_oracle_node_public_key_validation() {
     // Test Oracle node public key validation
     let valid_compressed_key = ECPoint::from_bytes(&[
[31m-        0x02, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
(B[m[31m-        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88
(B[m[31m-    ]).expect("Should create valid compressed ECPoint");
(B[m[31m-    
(B[m[32m+        0x02, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
(B[m[32m+        0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
(B[m[32m+        0x66, 0x77, 0x88,
(B[m[32m+    ])
(B[m[32m+    .expect("Should create valid compressed ECPoint");
(B[m[32m+
(B[m     let node = OracleNode {
         script_hash: UInt160::from([123u8; 20]),
         public_key: valid_compressed_key,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:274:
         is_active: true,
     };
[31m-    
(B[m[32m+
(B[m     // Compressed public key should be 33 bytes
     assert_eq!(node.public_key.to_bytes().len(), 33);
[31m-    
(B[m[32m+
(B[m     // First byte should be 0x02 or 0x03 for compressed keys
     let key_bytes = node.public_key.to_bytes();
[31m-    assert!(key_bytes[0] == 0x02 || key_bytes[0] == 0x03, 
(B[m[31m-           "Compressed key should start with 0x02 or 0x03");
(B[m[32m+    assert!(
(B[m[32m+        key_bytes[0] == 0x02 || key_bytes[0] == 0x03,
(B[m[32m+        "Compressed key should start with 0x02 or 0x03"
(B[m[32m+    );
(B[m }
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:287:
 fn test_oracle_node_serialization() {
     // Test Oracle node serialization
     let test_key = ECPoint::from_bytes(&[
[31m-        0x02, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
(B[m[31m-        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x12
(B[m[31m-    ]).expect("Should create valid ECPoint");
(B[m[31m-    
(B[m[32m+        0x02, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
(B[m[32m+        0x99, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
(B[m[32m+        0xee, 0xff, 0x12,
(B[m[32m+    ])
(B[m[32m+    .expect("Should create valid ECPoint");
(B[m[32m+
(B[m     let original = OracleNode {
         script_hash: UInt160::from([200u8; 20]),
         public_key: test_key,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:297:
         is_active: true,
     };
[31m-    
(B[m[32m+
(B[m     // Test serialization
     let serialized = serde_json::to_string(&original).expect("Should serialize");
[31m-    assert!(!serialized.is_empty(), "Serialized data should not be empty");
(B[m[31m-    
(B[m[32m+    assert!(
(B[m[32m+        !serialized.is_empty(),
(B[m[32m+        "Serialized data should not be empty"
(B[m[32m+    );
(B[m[32m+
(B[m     let deserialized: OracleNode = serde_json::from_str(&serialized).expect("Should deserialize");
     assert_eq!(deserialized.script_hash, original.script_hash);
[31m-    assert_eq!(deserialized.public_key.to_bytes(), original.public_key.to_bytes());
(B[m[32m+    assert_eq!(
(B[m[32m+        deserialized.public_key.to_bytes(),
(B[m[32m+        original.public_key.to_bytes()
(B[m[32m+    );
(B[m     assert_eq!(deserialized.is_active, original.is_active);
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:314:
 #[cfg(test)]
 mod integration_tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_oracle_contract_request_lifecycle() {
         // Test complete Oracle request lifecycle
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:321:
         let oracle = OracleContract::new();
[31m-        
(B[m[32m+
(B[m         // Create a request
         let request = OracleRequest {
             id: 1001,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:330:
             user_data: vec![1, 2, 3],
             gas_for_response: 1500000,
         };
[31m-        
(B[m[32m+
(B[m         // Request should be valid for processing
         assert!(request.id > 0);
         assert!(!request.url.is_empty());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:337:
         assert!(request.gas_for_response > 0);
[31m-        
(B[m[32m+
(B[m         // Test request can be processed by Oracle contract
[31m-        assert!(!oracle.get_hash().is_zero(), "Oracle should be ready to process requests");
(B[m[32m+        assert!(
(B[m[32m+            !oracle.get_hash().is_zero(),
(B[m[32m+            "Oracle should be ready to process requests"
(B[m[32m+        );
(B[m     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_oracle_contract_multiple_requests() {
         // Test handling multiple Oracle requests
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:346:
         let oracle = OracleContract::new();
         let mut requests = Vec::new();
[31m-        
(B[m[32m+
(B[m         // Create multiple requests
         for i in 1..=5 {
             let request = OracleRequest {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:352:
                 id: 2000 + i,
                 requesting_contract: UInt160::from([i as u8; 20]),
                 url: format!("https://api{}.test.com", i),
[31m-                filter: if i % 2 == 0 { Some("$.value".to_string()) } else { None },
(B[m[32m+                filter: if i % 2 == 0 {
(B[m[32m+                    Some("$.value".to_string())
(B[m[32m+                } else {
(B[m[32m+                    None
(B[m[32m+                },
(B[m                 callback: format!("callback{}", i),
                 user_data: vec![i as u8; i as usize],
                 gas_for_response: 1000000 + (i as i64 * 100000),
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:359:
             };
             requests.push(request);
         }
[31m-        
(B[m[32m+
(B[m         // All requests should be valid
         assert_eq!(requests.len(), 5);
[31m-        
(B[m[32m+
(B[m         for (i, request) in requests.iter().enumerate() {
             assert_eq!(request.id, 2001 + i as u64);
             assert!(request.url.contains(&format!("api{}", i + 1)));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:369:
             assert_eq!(request.user_data.len(), i + 1);
         }
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_oracle_contract_gas_cost_validation() {
         // Test Oracle contract gas cost validation
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:376:
         let oracle = OracleContract::new();
[31m-        
(B[m[32m+
(B[m         let expensive_request = OracleRequest {
             id: 3001,
             requesting_contract: UInt160::from([75u8; 20]),
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:382:
             filter: Some("$.deeply.nested.array[*].complex.structure".to_string()),
             callback: "expensiveCallback".to_string(),
             user_data: vec![0u8; 1000], // Large user data
[31m-            gas_for_response: 5000000, // High gas limit
(B[m[32m+            gas_for_response: 5000000,  // High gas limit
(B[m         };
[31m-        
(B[m[32m+
(B[m         // High gas request should still be valid
         assert!(expensive_request.gas_for_response > 1000000);
         assert_eq!(expensive_request.user_data.len(), 1000);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:391:
[31m-        
(B[m[32m+
(B[m         // Oracle should be able to handle expensive requests
         assert!(!oracle.get_hash().is_zero());
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:395:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_oracle_contract_error_handling() {
         // Test Oracle contract error handling scenarios
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:399:
         let oracle = OracleContract::new();
[31m-        
(B[m[32m+
(B[m         // Test with minimal valid request
         let minimal_request = OracleRequest {
             id: 4001,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:408:
             user_data: vec![],
             gas_for_response: 100000, // Minimal gas
         };
[31m-        
(B[m[32m+
(B[m         // Minimal request should still be valid
         assert!(minimal_request.id > 0);
         assert!(!minimal_request.url.is_empty());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:415:
         assert!(!minimal_request.callback.is_empty());
         assert!(minimal_request.gas_for_response > 0);
[31m-        
(B[m[32m+
(B[m         // Oracle should handle minimal requests
         assert!(!oracle.get_hash().is_zero());
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:421:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_oracle_contract_node_management() {
         // Test Oracle contract node management
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:425:
         let oracle = OracleContract::new();
[31m-        
(B[m[32m+
(B[m         // Create test nodes
         let test_key1 = ECPoint::from_bytes(&[
[31m-            0x02, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
(B[m[31m-            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00
(B[m[31m-        ]).expect("Should create valid ECPoint");
(B[m[31m-        
(B[m[32m+            0x02, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
(B[m[32m+            0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
(B[m[32m+            0xcc, 0xdd, 0xee, 0xff, 0x00,
(B[m[32m+        ])
(B[m[32m+        .expect("Should create valid ECPoint");
(B[m[32m+
(B[m         let node1 = OracleNode {
             script_hash: UInt160::from([111u8; 20]),
             public_key: test_key1,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:436:
             is_active: true,
         };
[31m-        
(B[m[32m+
(B[m         let test_key2 = ECPoint::from_bytes(&[
[31m-            0x03, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11,
(B[m[31m-            0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00
(B[m[31m-        ]).expect("Should create valid ECPoint");
(B[m[31m-        
(B[m[32m+            0x03, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33,
(B[m[32m+            0x22, 0x11, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x77, 0x66, 0x55,
(B[m[32m+            0x44, 0x33, 0x22, 0x11, 0x00,
(B[m[32m+        ])
(B[m[32m+        .expect("Should create valid ECPoint");
(B[m[32m+
(B[m         let node2 = OracleNode {
             script_hash: UInt160::from([222u8; 20]),
             public_key: test_key2,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:447:
             is_active: false,
         };
[31m-        
(B[m[32m+
(B[m         // Nodes should have different properties
         assert_ne!(node1.script_hash, node2.script_hash);
         assert_ne!(node1.public_key.to_bytes(), node2.public_key.to_bytes());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:453:
         assert_ne!(node1.is_active, node2.is_active);
[31m-        
(B[m[32m+
(B[m         // Oracle should be able to manage multiple nodes
         assert!(!oracle.get_hash().is_zero());
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/oracle_contract_tests.rs:458:
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:465:
                 } else {
                     panic!("Invalid attribute type parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "getStoragePrice" => StackItem::Integer(Self::DEFAULT_STORAGE_PRICE),
             "getExecFeeFactor" => StackItem::Integer(Self::DEFAULT_EXEC_FEE_FACTOR),
             "isBlocked" => StackItem::Boolean(false), // Default not blocked
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:484:
         if witness.is_none() {
             panic!("No witness provided");
         }
[31m-        
(B[m[32m+
(B[m         match method {
             "setAttributeFee" => {
                 if params.len() >= 2 {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:491:
[31m-                    if let (Some(ContractParameter::Integer(attr_type)), Some(ContractParameter::Integer(fee))) = 
(B[m[31m-                        (params.get(0), params.get(1)) {
(B[m[32m+                    if let (
(B[m[32m+                        Some(ContractParameter::Integer(attr_type)),
(B[m[32m+                        Some(ContractParameter::Integer(fee)),
(B[m[32m+                    ) = (params.get(0), params.get(1))
(B[m[32m+                    {
(B[m                         // Validate fee range (simplified)
                         if *fee > 10_0000_0000 {
                             panic!("Fee too high");
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:502:
                 } else {
                     panic!("Insufficient parameters")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "setFeePerByte" => {
                 if let Some(ContractParameter::Integer(fee)) = params.first() {
                     // Store fee per byte (in real implementation)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:510:
                 } else {
                     panic!("Invalid fee parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "setStoragePrice" => {
                 if let Some(ContractParameter::Integer(price)) = params.first() {
                     // Store storage price (in real implementation)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:518:
                 } else {
                     panic!("Invalid price parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "setExecFeeFactor" => {
                 if let Some(ContractParameter::Integer(factor)) = params.first() {
                     // Store execution fee factor (in real implementation)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:526:
                 } else {
                     panic!("Invalid factor parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "blockAccount" => {
                 if let Some(ContractParameter::Hash160(_account)) = params.first() {
                     // Block account (in real implementation)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:534:
                 } else {
                     panic!("Invalid account parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             "unblockAccount" => {
                 if let Some(ContractParameter::Hash160(_account)) = params.first() {
                     // Unblock account (in real implementation)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:542:
                 } else {
                     panic!("Invalid account parameter")
                 }
[31m-            },
(B[m[32m+            }
(B[m             _ => StackItem::Null,
         }
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/policy_contract_tests.rs:551:
 impl NeoToken {
     fn get_committee_address(&self, _engine: &ApplicationEngine) -> UInt160 {
         // Return a test committee address
[31m-        UInt160::from([0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
(B[m[31m-                      0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
(B[m[31m-                      0x12, 0x34, 0x56, 0x78])
(B[m[32m+        UInt160::from([
(B[m[32m+            0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
(B[m[32m+            0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
(B[m[32m+        ])
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:5:
 use neo_smart_contract::{BinaryReader, BinaryWriter, Serializable, SerializationError};
 use std::io::{Cursor, Read, Write};
 
[31m-// ============================================================================  
(B[m[32m+// ============================================================================
(B[m // Binary Serialization Compatibility (25 tests)
 // ============================================================================
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:13:
 fn test_uint160_serialization_compatibility() {
     // Test UInt160 serialization matches C# Neo exactly
     let hash = UInt160::from([42u8; 20]);
[31m-    
(B[m[32m+
(B[m     let mut writer = BinaryWriter::new();
     hash.serialize(&mut writer).unwrap();
     let serialized = writer.to_bytes();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:20:
[31m-    
(B[m[32m+
(B[m     // Should be exactly 20 bytes
     assert_eq!(serialized.len(), 20);
     assert_eq!(serialized, hash.to_bytes());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:24:
[31m-    
(B[m[32m+
(B[m     // Test deserialization
     let mut reader = BinaryReader::new(&serialized);
     let deserialized = UInt160::deserialize(&mut reader).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:32:
 fn test_uint256_serialization_compatibility() {
     // Test UInt256 serialization matches C# Neo exactly
     let hash = UInt256::from([99u8; 32]);
[31m-    
(B[m[32m+
(B[m     let mut writer = BinaryWriter::new();
     hash.serialize(&mut writer).unwrap();
     let serialized = writer.to_bytes();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:39:
[31m-    
(B[m[32m+
(B[m     // Should be exactly 32 bytes
     assert_eq!(serialized.len(), 32);
     assert_eq!(serialized, hash.to_bytes());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:43:
[31m-    
(B[m[32m+
(B[m     // Test deserialization
     let mut reader = BinaryReader::new(&serialized);
     let deserialized = UInt256::deserialize(&mut reader).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:51:
 fn test_variable_length_encoding_compatibility() {
     // Test variable length encoding matches C# Neo exactly
     let test_cases = vec![
[31m-        (0u64, vec![0x00]),                           // 1 byte
(B[m[31m-        (252u64, vec![0xfc]),                         // 1 byte max
(B[m[31m-        (253u64, vec![0xfd, 0xfd, 0x00]),            // 3 bytes min
(B[m[31m-        (65535u64, vec![0xfd, 0xff, 0xff]),          // 3 bytes max
(B[m[31m-        (65536u64, vec![0xfe, 0x00, 0x00, 0x01, 0x00]), // 5 bytes min
(B[m[32m+        (0u64, vec![0x00]),                                  // 1 byte
(B[m[32m+        (252u64, vec![0xfc]),                                // 1 byte max
(B[m[32m+        (253u64, vec![0xfd, 0xfd, 0x00]),                    // 3 bytes min
(B[m[32m+        (65535u64, vec![0xfd, 0xff, 0xff]),                  // 3 bytes max
(B[m[32m+        (65536u64, vec![0xfe, 0x00, 0x00, 0x01, 0x00]),      // 5 bytes min
(B[m         (4294967295u64, vec![0xfe, 0xff, 0xff, 0xff, 0xff]), // 5 bytes max
     ];
[31m-    
(B[m[32m+
(B[m     for (value, expected) in test_cases {
         let mut writer = BinaryWriter::new();
         writer.write_var_int(value).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:65:
         let serialized = writer.to_bytes();
[31m-        
(B[m[31m-        assert_eq!(serialized, expected, "VarInt encoding failed for value: {}", value);
(B[m[31m-        
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            serialized, expected,
(B[m[32m+            "VarInt encoding failed for value: {}",
(B[m[32m+            value
(B[m[32m+        );
(B[m[32m+
(B[m         // Test deserialization
         let mut reader = BinaryReader::new(&serialized);
         let deserialized = reader.read_var_int().unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:72:
[31m-        assert_eq!(value, deserialized, "VarInt decoding failed for value: {}", value);
(B[m[32m+        assert_eq!(
(B[m[32m+            value, deserialized,
(B[m[32m+            "VarInt decoding failed for value: {}",
(B[m[32m+            value
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:76:
 #[test]
 fn test_string_serialization_compatibility() {
[31m-    // Test string serialization matches C# Neo exactly  
(B[m[32m+    // Test string serialization matches C# Neo exactly
(B[m     let test_strings = vec![
[31m-        "",                    // Empty string
(B[m[31m-        "Hello",              // Simple ASCII
(B[m[31m-        "Neo Blockchain",     // ASCII with space
(B[m[31m-        "你好世界",           // Unicode
(B[m[31m-        "🚀 Neo N3",          // Emoji
(B[m[32m+        "",               // Empty string
(B[m[32m+        "Hello",          // Simple ASCII
(B[m[32m+        "Neo Blockchain", // ASCII with space
(B[m[32m+        "你好世界",       // Unicode
(B[m[32m+        "🚀 Neo N3",      // Emoji
(B[m     ];
[31m-    
(B[m[32m+
(B[m     for test_string in test_strings {
         let mut writer = BinaryWriter::new();
         writer.write_string(test_string).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:90:
         let serialized = writer.to_bytes();
[31m-        
(B[m[32m+
(B[m         // Format: VarInt(length) + UTF-8 bytes
         let utf8_bytes = test_string.as_bytes();
[31m-        
(B[m[32m+
(B[m         let mut expected = Vec::new();
         let mut expected_writer = BinaryWriter::new();
[31m-        expected_writer.write_var_int(utf8_bytes.len() as u64).unwrap();
(B[m[32m+        expected_writer
(B[m[32m+            .write_var_int(utf8_bytes.len() as u64)
(B[m[32m+            .unwrap();
(B[m         expected.extend_from_slice(&expected_writer.to_bytes());
         expected.extend_from_slice(utf8_bytes);
[31m-        
(B[m[31m-        assert_eq!(serialized, expected, "String serialization failed for: {}", test_string);
(B[m[31m-        
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            serialized, expected,
(B[m[32m+            "String serialization failed for: {}",
(B[m[32m+            test_string
(B[m[32m+        );
(B[m[32m+
(B[m         // Test deserialization
         let mut reader = BinaryReader::new(&serialized);
         let deserialized = reader.read_string().unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:106:
[31m-        assert_eq!(test_string, deserialized, "String deserialization failed for: {}", test_string);
(B[m[32m+        assert_eq!(
(B[m[32m+            test_string, deserialized,
(B[m[32m+            "String deserialization failed for: {}",
(B[m[32m+            test_string
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:111:
 fn test_byte_array_serialization_compatibility() {
     // Test byte array serialization matches C# Neo exactly
     let test_arrays = vec![
[31m-        vec![],                           // Empty array
(B[m[31m-        vec![0x00],                       // Single byte
(B[m[31m-        vec![0x01, 0x02, 0x03],          // Small array
(B[m[31m-        vec![0u8; 255],                  // Medium array
(B[m[31m-        vec![0xffu8; 1000],              // Large array
(B[m[32m+        vec![],                 // Empty array
(B[m[32m+        vec![0x00],             // Single byte
(B[m[32m+        vec![0x01, 0x02, 0x03], // Small array
(B[m[32m+        vec![0u8; 255],         // Medium array
(B[m[32m+        vec![0xffu8; 1000],     // Large array
(B[m     ];
[31m-    
(B[m[32m+
(B[m     for test_array in test_arrays {
         let mut writer = BinaryWriter::new();
         writer.write_bytes(&test_array).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:124:
         let serialized = writer.to_bytes();
[31m-        
(B[m[32m+
(B[m         // Format: VarInt(length) + bytes
         let mut expected = Vec::new();
         let mut expected_writer = BinaryWriter::new();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:129:
[31m-        expected_writer.write_var_int(test_array.len() as u64).unwrap();
(B[m[32m+        expected_writer
(B[m[32m+            .write_var_int(test_array.len() as u64)
(B[m[32m+            .unwrap();
(B[m         expected.extend_from_slice(&expected_writer.to_bytes());
         expected.extend_from_slice(&test_array);
[31m-        
(B[m[31m-        assert_eq!(serialized, expected, "Byte array serialization failed for array of length: {}", test_array.len());
(B[m[31m-        
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            serialized,
(B[m[32m+            expected,
(B[m[32m+            "Byte array serialization failed for array of length: {}",
(B[m[32m+            test_array.len()
(B[m[32m+        );
(B[m[32m+
(B[m         // Test deserialization
         let mut reader = BinaryReader::new(&serialized);
         let deserialized = reader.read_bytes().unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:138:
[31m-        assert_eq!(test_array, deserialized, "Byte array deserialization failed for array of length: {}", test_array.len());
(B[m[32m+        assert_eq!(
(B[m[32m+            test_array,
(B[m[32m+            deserialized,
(B[m[32m+            "Byte array deserialization failed for array of length: {}",
(B[m[32m+            test_array.len()
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:143:
 fn test_fixed_array_serialization_compatibility() {
     // Test fixed-length array serialization matches C# Neo exactly
     let test_array = [1u8, 2u8, 3u8, 4u8, 5u8];
[31m-    
(B[m[32m+
(B[m     let mut writer = BinaryWriter::new();
     writer.write_fixed_bytes(&test_array).unwrap();
     let serialized = writer.to_bytes();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:150:
[31m-    
(B[m[32m+
(B[m     // Fixed array should not include length prefix
     assert_eq!(serialized, test_array.to_vec());
[31m-    
(B[m[32m+
(B[m     // Test deserialization
     let mut reader = BinaryReader::new(&serialized);
     let mut deserialized = [0u8; 5];
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:169:
         (65536u32 as u64, vec![0x00, 0x00, 0x01, 0x00]),
         (4294967295u32 as u64, vec![0xff, 0xff, 0xff, 0xff]),
     ];
[31m-    
(B[m[32m+
(B[m     for (value, expected) in test_cases {
         // Test different integer sizes
         if value <= u8::MAX as u64 {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:178:
             let serialized = writer.to_bytes();
             assert_eq!(serialized, expected[..1].to_vec());
         }
[31m-        
(B[m[32m+
(B[m         if value <= u16::MAX as u64 {
             let mut writer = BinaryWriter::new();
             writer.write_u16(value as u16).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:187:
                 assert_eq!(serialized, expected[..2].to_vec());
             }
         }
[31m-        
(B[m[32m+
(B[m         if value <= u32::MAX as u64 {
             let mut writer = BinaryWriter::new();
             writer.write_u32(value as u32).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:203:
 fn test_boolean_serialization_compatibility() {
     // Test boolean serialization matches C# Neo exactly
     let mut writer = BinaryWriter::new();
[31m-    
(B[m[32m+
(B[m     writer.write_bool(true).unwrap();
     writer.write_bool(false).unwrap();
[31m-    
(B[m[32m+
(B[m     let serialized = writer.to_bytes();
     assert_eq!(serialized, vec![0x01, 0x00]);
[31m-    
(B[m[32m+
(B[m     // Test deserialization
     let mut reader = BinaryReader::new(&serialized);
     assert_eq!(reader.read_bool().unwrap(), true);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:216:
     assert_eq!(reader.read_bool().unwrap(), false);
 }
 
[31m-#[test] 
(B[m[32m+#[test]
(B[m fn test_biginteger_serialization_compatibility() {
     // Test BigInteger serialization matches C# Neo exactly
     let test_cases = vec![
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:223:
[31m-        (0i64, vec![0x00]),                    // Zero
(B[m[31m-        (1i64, vec![0x01]),                    // Positive small
(B[m[31m-        (-1i64, vec![0xff]),                   // Negative small
(B[m[31m-        (127i64, vec![0x7f]),                  // Max positive byte
(B[m[31m-        (128i64, vec![0x80, 0x00]),           // Min 2-byte positive
(B[m[31m-        (-128i64, vec![0x80]),                 // Min negative byte
(B[m[31m-        (-129i64, vec![0x7f, 0xff]),          // Max 2-byte negative
(B[m[31m-        (32767i64, vec![0xff, 0x7f]),         // Max positive 2-byte
(B[m[31m-        (-32768i64, vec![0x00, 0x80]),        // Min negative 2-byte
(B[m[32m+        (0i64, vec![0x00]),            // Zero
(B[m[32m+        (1i64, vec![0x01]),            // Positive small
(B[m[32m+        (-1i64, vec![0xff]),           // Negative small
(B[m[32m+        (127i64, vec![0x7f]),          // Max positive byte
(B[m[32m+        (128i64, vec![0x80, 0x00]),    // Min 2-byte positive
(B[m[32m+        (-128i64, vec![0x80]),         // Min negative byte
(B[m[32m+        (-129i64, vec![0x7f, 0xff]),   // Max 2-byte negative
(B[m[32m+        (32767i64, vec![0xff, 0x7f]),  // Max positive 2-byte
(B[m[32m+        (-32768i64, vec![0x00, 0x80]), // Min negative 2-byte
(B[m     ];
[31m-    
(B[m[32m+
(B[m     for (value, expected) in test_cases {
         let bigint = BigInteger::from(value);
         let mut writer = BinaryWriter::new();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:237:
         bigint.serialize(&mut writer).unwrap();
         let serialized = writer.to_bytes();
[31m-        
(B[m[31m-        assert_eq!(serialized, expected, "BigInteger serialization failed for value: {}", value);
(B[m[31m-        
(B[m[32m+
(B[m[32m+        assert_eq!(
(B[m[32m+            serialized, expected,
(B[m[32m+            "BigInteger serialization failed for value: {}",
(B[m[32m+            value
(B[m[32m+        );
(B[m[32m+
(B[m         // Test deserialization
         let mut reader = BinaryReader::new(&serialized);
         let deserialized = BigInteger::deserialize(&mut reader).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:245:
[31m-        assert_eq!(bigint, deserialized, "BigInteger deserialization failed for value: {}", value);
(B[m[32m+        assert_eq!(
(B[m[32m+            bigint, deserialized,
(B[m[32m+            "BigInteger deserialization failed for value: {}",
(B[m[32m+            value
(B[m[32m+        );
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:254:
         UInt160::from([2u8; 20]),
         UInt160::from([3u8; 20]),
     ];
[31m-    
(B[m[32m+
(B[m     let mut writer = BinaryWriter::new();
     writer.write_var_int(array_data.len() as u64).unwrap();
     for item in &array_data {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:261:
         item.serialize(&mut writer).unwrap();
     }
[31m-    
(B[m[32m+
(B[m     let serialized = writer.to_bytes();
[31m-    
(B[m[32m+
(B[m     // Verify structure: VarInt(count) + items
     let mut expected = Vec::new();
     expected.push(array_data.len() as u8); // VarInt for small array
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:269:
     for item in &array_data {
         expected.extend_from_slice(&item.to_bytes());
     }
[31m-    
(B[m[32m+
(B[m     assert_eq!(serialized, expected);
[31m-    
(B[m[32m+
(B[m     // Test deserialization
     let mut reader = BinaryReader::new(&serialized);
     let count = reader.read_var_int().unwrap() as usize;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:278:
     let mut deserialized = Vec::with_capacity(count);
[31m-    
(B[m[32m+
(B[m     for _ in 0..count {
         let item = UInt160::deserialize(&mut reader).unwrap();
         deserialized.push(item);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:283:
     }
[31m-    
(B[m[32m+
(B[m     assert_eq!(array_data, deserialized);
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:292:
     dict_data.insert("key1".to_string(), 100u64);
     dict_data.insert("key2".to_string(), 200u64);
     dict_data.insert("key3".to_string(), 300u64);
[31m-    
(B[m[32m+
(B[m     let mut writer = BinaryWriter::new();
     writer.write_var_int(dict_data.len() as u64).unwrap();
[31m-    
(B[m[32m+
(B[m     for (key, value) in &dict_data {
         writer.write_string(key).unwrap();
         writer.write_u64(*value).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:302:
     }
[31m-    
(B[m[32m+
(B[m     let serialized = writer.to_bytes();
[31m-    
(B[m[32m+
(B[m     // Test deserialization
     let mut reader = BinaryReader::new(&serialized);
     let count = reader.read_var_int().unwrap() as usize;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:309:
     let mut deserialized = std::collections::BTreeMap::new();
[31m-    
(B[m[32m+
(B[m     for _ in 0..count {
         let key = reader.read_string().unwrap();
         let value = reader.read_u64().unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:314:
         deserialized.insert(key, value);
     }
[31m-    
(B[m[32m+
(B[m     assert_eq!(dict_data, deserialized);
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:322:
     // Test null value serialization matches C# Neo exactly
     let mut writer = BinaryWriter::new();
     writer.write_bool(false).unwrap(); // Null indicator
[31m-    
(B[m[32m+
(B[m     let serialized = writer.to_bytes();
     assert_eq!(serialized, vec![0x00]);
[31m-    
(B[m[32m+
(B[m     // Test deserialization
     let mut reader = BinaryReader::new(&serialized);
     let is_null = !reader.read_bool().unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:348:
             map
         },
     };
[31m-    
(B[m[32m+
(B[m     let mut writer = BinaryWriter::new();
     structure.serialize(&mut writer).unwrap();
     let serialized = writer.to_bytes();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:355:
[31m-    
(B[m[32m+
(B[m     // Test deserialization
     let mut reader = BinaryReader::new(&serialized);
     let deserialized = ComplexStructure::deserialize(&mut reader).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:359:
[31m-    
(B[m[32m+
(B[m     assert_eq!(structure, deserialized);
 }
 
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:366:
     let test_u16 = 0x1234u16;
     let test_u32 = 0x12345678u32;
     let test_u64 = 0x123456789abcdef0u64;
[31m-    
(B[m[32m+
(B[m     let mut writer = BinaryWriter::new();
     writer.write_u16(test_u16).unwrap();
     writer.write_u32(test_u32).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:373:
     writer.write_u64(test_u64).unwrap();
[31m-    
(B[m[32m+
(B[m     let serialized = writer.to_bytes();
[31m-    
(B[m[32m+
(B[m     // Verify little-endian byte order
     assert_eq!(&serialized[0..2], &[0x34, 0x12]); // u16
     assert_eq!(&serialized[2..6], &[0x78, 0x56, 0x34, 0x12]); // u32
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:380:
[31m-    assert_eq!(&serialized[6..14], &[0xf0, 0xde, 0xbc, 0x9a, 0x78, 0x56, 0x34, 0x12]); // u64
(B[m[31m-    
(B[m[32m+    assert_eq!(
(B[m[32m+        &serialized[6..14],
(B[m[32m+        &[0xf0, 0xde, 0xbc, 0x9a, 0x78, 0x56, 0x34, 0x12]
(B[m[32m+    ); // u64
(B[m[32m+
(B[m     // Test deserialization
     let mut reader = BinaryReader::new(&serialized);
     assert_eq!(reader.read_u16().unwrap(), test_u16);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:391:
     // Test stream position tracking matches C# Neo BinaryReader
     let test_data = vec![1, 2, 3, 4, 5, 6, 7, 8];
     let mut reader = BinaryReader::new(&test_data);
[31m-    
(B[m[32m+
(B[m     assert_eq!(reader.position(), 0);
[31m-    
(B[m[32m+
(B[m     let _ = reader.read_u8().unwrap();
     assert_eq!(reader.position(), 1);
[31m-    
(B[m[32m+
(B[m     let _ = reader.read_u16().unwrap();
     assert_eq!(reader.position(), 3);
[31m-    
(B[m[32m+
(B[m     let _ = reader.read_u32().unwrap();
     assert_eq!(reader.position(), 7);
[31m-    
(B[m[32m+
(B[m     let _ = reader.read_u8().unwrap();
     assert_eq!(reader.position(), 8);
[31m-    
(B[m[32m+
(B[m     // Test end of stream
     assert!(reader.read_u8().is_err());
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:415:
     // Test error handling matches C# Neo behavior
     let empty_data = vec![];
     let mut reader = BinaryReader::new(&empty_data);
[31m-    
(B[m[32m+
(B[m     // Reading from empty stream should error
     assert!(reader.read_u8().is_err());
     assert!(reader.read_u16().is_err());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:422:
     assert!(reader.read_string().is_err());
[31m-    
(B[m[32m+
(B[m     // Test truncated data
     let truncated_data = vec![0xff]; // VarInt indicating string length 255, but no data
     let mut reader = BinaryReader::new(&truncated_data);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:427:
     assert!(reader.read_string().is_err());
 }
 
[31m-#[test] 
(B[m[32m+#[test]
(B[m fn test_buffer_management_compatibility() {
     // Test buffer management matches C# Neo MemoryStream behavior
     let mut writer = BinaryWriter::new();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:434:
[31m-    
(B[m[32m+
(B[m     // Write progressively larger data to test buffer expansion
     for i in 0..1000 {
         writer.write_u32(i).unwrap();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:438:
     }
[31m-    
(B[m[32m+
(B[m     let serialized = writer.to_bytes();
     assert_eq!(serialized.len(), 1000 * 4);
[31m-    
(B[m[32m+
(B[m     // Verify all data was written correctly
     let mut reader = BinaryReader::new(&serialized);
     for i in 0..1000 {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:452:
     // Test serialization limits match C# Neo
     const MAX_ARRAY_SIZE: usize = 16777216; // 16MB limit from C# Neo
     const MAX_STRING_LENGTH: usize = 65536; // 64KB limit from C# Neo
[31m-    
(B[m[32m+
(B[m     // Test string length limit
     let long_string = "a".repeat(MAX_STRING_LENGTH + 1);
     let mut writer = BinaryWriter::new();
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:459:
     let result = writer.write_string(&long_string);
     assert!(result.is_err(), "Should reject string longer than 64KB");
[31m-    
(B[m[31m-    // Test array size limit  
(B[m[32m+
(B[m[32m+    // Test array size limit
(B[m     let large_array = vec![0u8; MAX_ARRAY_SIZE + 1];
     let mut writer = BinaryWriter::new();
     let result = writer.write_bytes(&large_array);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:477:
 
 impl BinaryWriter {
     pub fn new() -> Self {
[31m-        Self {
(B[m[31m-            buffer: Vec::new(),
(B[m[31m-        }
(B[m[32m+        Self { buffer: Vec::new() }
(B[m     }
[31m-    
(B[m[32m+
(B[m     pub fn to_bytes(&self) -> Vec<u8> {
         self.buffer.clone()
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:488:
[31m-    
(B[m[32m+
(B[m     pub fn write_u8(&mut self, value: u8) -> Result<(), SerializationError> {
         self.buffer.push(value);
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:492:
     }
[31m-    
(B[m[32m+
(B[m     pub fn write_u16(&mut self, value: u16) -> Result<(), SerializationError> {
         self.buffer.extend_from_slice(&value.to_le_bytes());
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:497:
     }
[31m-    
(B[m[32m+
(B[m     pub fn write_u32(&mut self, value: u32) -> Result<(), SerializationError> {
         self.buffer.extend_from_slice(&value.to_le_bytes());
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:502:
     }
[31m-    
(B[m[32m+
(B[m     pub fn write_u64(&mut self, value: u64) -> Result<(), SerializationError> {
         self.buffer.extend_from_slice(&value.to_le_bytes());
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:507:
     }
[31m-    
(B[m[32m+
(B[m     pub fn write_bool(&mut self, value: bool) -> Result<(), SerializationError> {
         self.write_u8(if value { 0x01 } else { 0x00 })
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:512:
[31m-    
(B[m[32m+
(B[m     pub fn write_var_int(&mut self, mut value: u64) -> Result<(), SerializationError> {
         if value < 0xfd {
             self.write_u8(value as u8)?;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:525:
         }
         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     pub fn write_string(&mut self, value: &str) -> Result<(), SerializationError> {
         const MAX_STRING_LENGTH: usize = 65536;
[31m-        
(B[m[32m+
(B[m         let bytes = value.as_bytes();
         if bytes.len() > MAX_STRING_LENGTH {
             return Err(SerializationError::StringTooLong);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:535:
         }
[31m-        
(B[m[32m+
(B[m         self.write_var_int(bytes.len() as u64)?;
         self.buffer.extend_from_slice(bytes);
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:540:
     }
[31m-    
(B[m[32m+
(B[m     pub fn write_bytes(&mut self, value: &[u8]) -> Result<(), SerializationError> {
         const MAX_ARRAY_SIZE: usize = 16777216;
[31m-        
(B[m[32m+
(B[m         if value.len() > MAX_ARRAY_SIZE {
             return Err(SerializationError::ArrayTooLarge);
         }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:548:
[31m-        
(B[m[32m+
(B[m         self.write_var_int(value.len() as u64)?;
         self.buffer.extend_from_slice(value);
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:552:
     }
[31m-    
(B[m[32m+
(B[m     pub fn write_fixed_bytes(&mut self, value: &[u8]) -> Result<(), SerializationError> {
         self.buffer.extend_from_slice(value);
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:567:
     pub fn new(data: &'a [u8]) -> Self {
         Self { data, position: 0 }
     }
[31m-    
(B[m[32m+
(B[m     pub fn position(&self) -> usize {
         self.position
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:574:
[31m-    
(B[m[32m+
(B[m     pub fn read_u8(&mut self) -> Result<u8, SerializationError> {
         if self.position >= self.data.len() {
             return Err(SerializationError::EndOfStream);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:578:
         }
[31m-        
(B[m[32m+
(B[m         let value = self.data[self.position];
         self.position += 1;
         Ok(value)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:583:
     }
[31m-    
(B[m[32m+
(B[m     pub fn read_u16(&mut self) -> Result<u16, SerializationError> {
         if self.position + 2 > self.data.len() {
             return Err(SerializationError::EndOfStream);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:588:
         }
[31m-        
(B[m[32m+
(B[m         let bytes = [self.data[self.position], self.data[self.position + 1]];
         self.position += 2;
         Ok(u16::from_le_bytes(bytes))
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:593:
     }
[31m-    
(B[m[32m+
(B[m     pub fn read_u32(&mut self) -> Result<u32, SerializationError> {
         if self.position + 4 > self.data.len() {
             return Err(SerializationError::EndOfStream);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:598:
         }
[31m-        
(B[m[32m+
(B[m         let bytes = [
             self.data[self.position],
             self.data[self.position + 1],
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:606:
         self.position += 4;
         Ok(u32::from_le_bytes(bytes))
     }
[31m-    
(B[m[32m+
(B[m     pub fn read_u64(&mut self) -> Result<u64, SerializationError> {
         if self.position + 8 > self.data.len() {
             return Err(SerializationError::EndOfStream);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:613:
         }
[31m-        
(B[m[32m+
(B[m         let mut bytes = [0u8; 8];
         bytes.copy_from_slice(&self.data[self.position..self.position + 8]);
         self.position += 8;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:618:
         Ok(u64::from_le_bytes(bytes))
     }
[31m-    
(B[m[32m+
(B[m     pub fn read_bool(&mut self) -> Result<bool, SerializationError> {
         let value = self.read_u8()?;
         Ok(value != 0)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:624:
     }
[31m-    
(B[m[32m+
(B[m     pub fn read_var_int(&mut self) -> Result<u64, SerializationError> {
         let first_byte = self.read_u8()?;
[31m-        
(B[m[32m+
(B[m         match first_byte {
             0xfd => Ok(self.read_u16()? as u64),
             0xfe => Ok(self.read_u32()? as u64),
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:633:
             _ => Ok(first_byte as u64),
         }
     }
[31m-    
(B[m[32m+
(B[m     pub fn read_string(&mut self) -> Result<String, SerializationError> {
         let length = self.read_var_int()? as usize;
[31m-        
(B[m[32m+
(B[m         if self.position + length > self.data.len() {
             return Err(SerializationError::EndOfStream);
         }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:643:
[31m-        
(B[m[32m+
(B[m         let bytes = &self.data[self.position..self.position + length];
         self.position += length;
[31m-        
(B[m[31m-        String::from_utf8(bytes.to_vec())
(B[m[31m-            .map_err(|_| SerializationError::InvalidUtf8)
(B[m[32m+
(B[m[32m+        String::from_utf8(bytes.to_vec()).map_err(|_| SerializationError::InvalidUtf8)
(B[m     }
[31m-    
(B[m[32m+
(B[m     pub fn read_bytes(&mut self) -> Result<Vec<u8>, SerializationError> {
         let length = self.read_var_int()? as usize;
[31m-        
(B[m[32m+
(B[m         if self.position + length > self.data.len() {
             return Err(SerializationError::EndOfStream);
         }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:657:
[31m-        
(B[m[32m+
(B[m         let bytes = self.data[self.position..self.position + length].to_vec();
         self.position += length;
         Ok(bytes)
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:661:
     }
[31m-    
(B[m[32m+
(B[m     pub fn read_fixed_bytes(&mut self, buffer: &mut [u8]) -> Result<(), SerializationError> {
         if self.position + buffer.len() > self.data.len() {
             return Err(SerializationError::EndOfStream);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:666:
         }
[31m-        
(B[m[32m+
(B[m         buffer.copy_from_slice(&self.data[self.position..self.position + buffer.len()]);
         self.position += buffer.len();
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:720:
             writer.write_fixed_bytes(&bytes[..end])
         }
     }
[31m-    
(B[m[32m+
(B[m     fn deserialize(reader: &mut BinaryReader) -> Result<Self, SerializationError> {
         let first_byte = reader.read_u8()?;
         if first_byte <= 127 {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:749:
         self.hash.serialize(writer)?;
         writer.write_bool(self.flags)?;
         writer.write_bytes(&self.data)?;
[31m-        
(B[m[32m+
(B[m         writer.write_var_int(self.metadata.len() as u64)?;
         for (key, value) in &self.metadata {
             writer.write_string(key)?;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:756:
             writer.write_u64(*value)?;
         }
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     fn deserialize(reader: &mut BinaryReader) -> Result<Self, SerializationError> {
         let id = reader.read_u32()?;
         let name = reader.read_string()?;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:765:
         let hash = UInt160::deserialize(reader)?;
         let flags = reader.read_bool()?;
         let data = reader.read_bytes()?;
[31m-        
(B[m[32m+
(B[m         let metadata_count = reader.read_var_int()? as usize;
         let mut metadata = std::collections::BTreeMap::new();
         for _ in 0..metadata_count {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:773:
             let value = reader.read_u64()?;
             metadata.insert(key, value);
         }
[31m-        
(B[m[32m+
(B[m         Ok(ComplexStructure {
             id,
             name,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:789:
     fn serialize(&self, writer: &mut BinaryWriter) -> Result<(), SerializationError> {
         writer.write_fixed_bytes(&self.to_bytes())
     }
[31m-    
(B[m[32m+
(B[m     fn deserialize(reader: &mut BinaryReader) -> Result<Self, SerializationError> {
         let mut bytes = [0u8; 20];
         reader.read_fixed_bytes(&mut bytes)?;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:801:
     fn serialize(&self, writer: &mut BinaryWriter) -> Result<(), SerializationError> {
         writer.write_fixed_bytes(&self.to_bytes())
     }
[31m-    
(B[m[32m+
(B[m     fn deserialize(reader: &mut BinaryReader) -> Result<Self, SerializationError> {
         let mut bytes = [0u8; 32];
         reader.read_fixed_bytes(&mut bytes)?;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/serialization_compatibility_tests.rs:808:
         Ok(UInt256::from(bytes))
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:2:
 //! These tests ensure 100% compatibility with C# Neo witness scope validation
 
 use neo_core::{UInt160, UInt256};
[31m-use neo_smart_contract::{WitnessRule, WitnessScope, WitnessRuleAction, WitnessCondition};
(B[m[32m+use neo_smart_contract::{WitnessCondition, WitnessRule, WitnessRuleAction, WitnessScope};
(B[m use std::collections::HashSet;
 
 // ============================================================================
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:9:
[31m-// Witness Scope Validation Compatibility (20 tests)  
(B[m[32m+// Witness Scope Validation Compatibility (20 tests)
(B[m // ============================================================================
 
 #[test]
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:15:
     assert_eq!(WitnessScope::None as u8, 0x00);
     assert_eq!(WitnessScope::CalledByEntry as u8, 0x01);
     assert_eq!(WitnessScope::CustomContracts as u8, 0x10);
[31m-    assert_eq!(WitnessScope::CustomGroups as u8, 0x20);  
(B[m[32m+    assert_eq!(WitnessScope::CustomGroups as u8, 0x20);
(B[m     assert_eq!(WitnessScope::WitnessRules as u8, 0x40);
     assert_eq!(WitnessScope::Global as u8, 0x80);
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:24:
 fn test_witness_scope_none_validation() {
     // Test None scope validation matches C# Neo
     let scope = WitnessScope::None;
[31m-    
(B[m[32m+
(B[m     // None scope should have no allowed contracts or groups
     assert!(!scope.has_custom_contracts());
     assert!(!scope.has_custom_groups());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:31:
     assert!(!scope.has_witness_rules());
     assert!(!scope.is_global());
[31m-    
(B[m[32m+
(B[m     // Validate scope restrictions
     assert!(!scope.allows_contract(&UInt160::from([42u8; 20])));
     assert!(!scope.allows_group(&[0u8; 33])); // Public key
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:37:
 }
 
[31m-#[test] 
(B[m[32m+#[test]
(B[m fn test_witness_scope_called_by_entry_validation() {
     // Test CalledByEntry scope validation matches C# Neo
     let scope = WitnessScope::CalledByEntry;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:43:
[31m-    
(B[m[32m+
(B[m     // CalledByEntry should only work for entry contracts
     assert!(!scope.has_custom_contracts());
     assert!(!scope.has_custom_groups());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:47:
     assert!(!scope.has_witness_rules());
     assert!(!scope.is_global());
[31m-    
(B[m[32m+
(B[m     // Should allow entry contract only
     assert!(scope.is_called_by_entry());
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:59:
         UInt160::from([2u8; 20]),
         UInt160::from([3u8; 20]),
     ];
[31m-    
(B[m[32m+
(B[m     let scope = WitnessScope::CustomContracts;
     let mut witness_scope = WitnessScopeValidator::new(scope);
     witness_scope.add_allowed_contracts(contracts.clone());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:66:
[31m-    
(B[m[32m+
(B[m     assert!(witness_scope.has_custom_contracts());
     assert!(!witness_scope.has_custom_groups());
     assert!(!witness_scope.has_witness_rules());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:70:
     assert!(!witness_scope.is_global());
[31m-    
(B[m[32m+
(B[m     // Test allowed contracts
     for contract in &contracts {
         assert!(witness_scope.allows_contract(contract));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:75:
     }
[31m-    
(B[m[32m+
(B[m     // Test disallowed contract
     let disallowed = UInt160::from([99u8; 20]);
     assert!(!witness_scope.allows_contract(&disallowed));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:87:
         [2u8; 33], // Public key 2
         [3u8; 33], // Public key 3
     ];
[31m-    
(B[m[32m+
(B[m     let scope = WitnessScope::CustomGroups;
     let mut witness_scope = WitnessScopeValidator::new(scope);
     witness_scope.add_allowed_groups(groups.clone());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:94:
[31m-    
(B[m[32m+
(B[m     assert!(!witness_scope.has_custom_contracts());
     assert!(witness_scope.has_custom_groups());
     assert!(!witness_scope.has_witness_rules());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:98:
     assert!(!witness_scope.is_global());
[31m-    
(B[m[32m+
(B[m     // Test allowed groups
     for group in &groups {
         assert!(witness_scope.allows_group(group));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:103:
     }
[31m-    
(B[m[32m+
(B[m     // Test disallowed group
     let disallowed = [99u8; 33];
     assert!(!witness_scope.allows_group(&disallowed));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:120:
             condition: WitnessCondition::ScriptHash(UInt160::from([2u8; 20])),
         },
     ];
[31m-    
(B[m[32m+
(B[m     let scope = WitnessScope::WitnessRules;
     let mut witness_scope = WitnessScopeValidator::new(scope);
     witness_scope.add_witness_rules(rules.clone());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:127:
[31m-    
(B[m[32m+
(B[m     assert!(!witness_scope.has_custom_contracts());
     assert!(!witness_scope.has_custom_groups());
     assert!(witness_scope.has_witness_rules());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:131:
     assert!(!witness_scope.is_global());
[31m-    
(B[m[32m+
(B[m     // Test witness rule evaluation
     let allowed_contract = UInt160::from([1u8; 20]);
     let denied_contract = UInt160::from([2u8; 20]);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:136:
     let neutral_contract = UInt160::from([3u8; 20]);
[31m-    
(B[m[32m+
(B[m     assert!(witness_scope.check_witness_rules(&allowed_contract));
     assert!(!witness_scope.check_witness_rules(&denied_contract));
     assert!(!witness_scope.check_witness_rules(&neutral_contract)); // Default deny
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:145:
     // Test Global scope validation matches C# Neo
     let scope = WitnessScope::Global;
     let witness_scope = WitnessScopeValidator::new(scope);
[31m-    
(B[m[32m+
(B[m     assert!(!witness_scope.has_custom_contracts());
     assert!(!witness_scope.has_custom_groups());
     assert!(!witness_scope.has_witness_rules());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:152:
     assert!(witness_scope.is_global());
[31m-    
(B[m[32m+
(B[m     // Global should allow everything
     assert!(witness_scope.allows_contract(&UInt160::from([1u8; 20])));
     assert!(witness_scope.allows_contract(&UInt160::from([99u8; 20])));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:158:
     assert!(witness_scope.allows_group(&[99u8; 33]));
 }
 
[31m-#[test] 
(B[m[32m+#[test]
(B[m fn test_witness_scope_combination_validation() {
     // Test combined scopes validation matches C# Neo
     let combined_scope = WitnessScope::CustomContracts | WitnessScope::CustomGroups;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:165:
     let mut witness_scope = WitnessScopeValidator::new(combined_scope);
[31m-    
(B[m[32m+
(B[m     let contracts = vec![UInt160::from([1u8; 20])];
     let groups = vec![[2u8; 33]];
[31m-    
(B[m[32m+
(B[m     witness_scope.add_allowed_contracts(contracts.clone());
     witness_scope.add_allowed_groups(groups.clone());
[31m-    
(B[m[32m+
(B[m     assert!(witness_scope.has_custom_contracts());
     assert!(witness_scope.has_custom_groups());
     assert!(!witness_scope.has_witness_rules());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:176:
     assert!(!witness_scope.is_global());
[31m-    
(B[m[32m+
(B[m     // Both contracts and groups should be allowed
     assert!(witness_scope.allows_contract(&contracts[0]));
     assert!(witness_scope.allows_group(&groups[0]));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:190:
         (WitnessScope::CustomGroups, vec![0x20]),
         (WitnessScope::WitnessRules, vec![0x40]),
         (WitnessScope::Global, vec![0x80]),
[31m-        (WitnessScope::CustomContracts | WitnessScope::CustomGroups, vec![0x30]),
(B[m[32m+        (
(B[m[32m+            WitnessScope::CustomContracts | WitnessScope::CustomGroups,
(B[m[32m+            vec![0x30],
(B[m[32m+        ),
(B[m     ];
[31m-    
(B[m[32m+
(B[m     for (scope, expected_bytes) in test_cases {
         let serialized = scope.to_bytes();
         assert_eq!(serialized, expected_bytes);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:199:
[31m-        
(B[m[32m+
(B[m         let deserialized = WitnessScope::from_bytes(&serialized).unwrap();
         assert_eq!(deserialized, scope);
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:212:
         (vec![0x20], WitnessScope::CustomGroups),
         (vec![0x40], WitnessScope::WitnessRules),
         (vec![0x80], WitnessScope::Global),
[31m-        (vec![0x30], WitnessScope::CustomContracts | WitnessScope::CustomGroups),
(B[m[32m+        (
(B[m[32m+            vec![0x30],
(B[m[32m+            WitnessScope::CustomContracts | WitnessScope::CustomGroups,
(B[m[32m+        ),
(B[m     ];
[31m-    
(B[m[32m+
(B[m     for (bytes, expected_scope) in test_cases {
         let deserialized = WitnessScope::from_bytes(&bytes).unwrap();
         assert_eq!(deserialized, expected_scope);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:247:
     // Test boolean witness conditions match C# Neo
     let condition_true = WitnessCondition::Boolean(true);
     let condition_false = WitnessCondition::Boolean(false);
[31m-    
(B[m[32m+
(B[m     assert_eq!(condition_true.get_type(), WitnessConditionType::Boolean);
     assert_eq!(condition_false.get_type(), WitnessConditionType::Boolean);
[31m-    
(B[m[32m+
(B[m     // Test evaluation
     assert!(condition_true.evaluate(&create_test_context()));
     assert!(!condition_false.evaluate(&create_test_context()));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:261:
     // Test NOT witness conditions match C# Neo
     let inner_condition = WitnessCondition::Boolean(true);
     let not_condition = WitnessCondition::Not(Box::new(inner_condition));
[31m-    
(B[m[32m+
(B[m     assert_eq!(not_condition.get_type(), WitnessConditionType::Not);
[31m-    
(B[m[32m+
(B[m     // Test evaluation (should invert inner condition)
     assert!(!not_condition.evaluate(&create_test_context()));
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:276:
         WitnessCondition::Boolean(true),
     ];
     let and_condition = WitnessCondition::And(conditions);
[31m-    
(B[m[32m+
(B[m     assert_eq!(and_condition.get_type(), WitnessConditionType::And);
[31m-    
(B[m[32m+
(B[m     // Test evaluation (all must be true)
     assert!(and_condition.evaluate(&create_test_context()));
[31m-    
(B[m[32m+
(B[m     // Test with one false condition
     let conditions_with_false = vec![
         WitnessCondition::Boolean(true),
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:299:
         WitnessCondition::Boolean(true),
     ];
     let or_condition = WitnessCondition::Or(conditions);
[31m-    
(B[m[32m+
(B[m     assert_eq!(or_condition.get_type(), WitnessConditionType::Or);
[31m-    
(B[m[32m+
(B[m     // Test evaluation (at least one must be true)
     assert!(or_condition.evaluate(&create_test_context()));
[31m-    
(B[m[32m+
(B[m     // Test with all false conditions
     let conditions_all_false = vec![
         WitnessCondition::Boolean(false),
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:319:
     // Test ScriptHash witness conditions match C# Neo
     let script_hash = UInt160::from([42u8; 20]);
     let condition = WitnessCondition::ScriptHash(script_hash);
[31m-    
(B[m[32m+
(B[m     assert_eq!(condition.get_type(), WitnessConditionType::ScriptHash);
[31m-    
(B[m[32m+
(B[m     // Test evaluation with matching contract
     let mut context = create_test_context();
     context.current_script_hash = script_hash;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:328:
     assert!(condition.evaluate(&context));
[31m-    
(B[m[32m+
(B[m     // Test evaluation with non-matching contract
     context.current_script_hash = UInt160::from([99u8; 20]);
     assert!(!condition.evaluate(&context));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:337:
     // Test Group witness conditions match C# Neo
     let group_pubkey = [42u8; 33];
     let condition = WitnessCondition::Group(group_pubkey);
[31m-    
(B[m[32m+
(B[m     assert_eq!(condition.get_type(), WitnessConditionType::Group);
[31m-    
(B[m[32m+
(B[m     // Test evaluation with matching group
     let mut context = create_test_context();
     context.contract_groups.insert(group_pubkey);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:346:
     assert!(condition.evaluate(&context));
[31m-    
(B[m[32m+
(B[m     // Test evaluation with non-matching group
     context.contract_groups.clear();
     context.contract_groups.insert([99u8; 33]);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:355:
 fn test_witness_condition_called_by_entry_compatibility() {
     // Test CalledByEntry witness conditions match C# Neo
     let condition = WitnessCondition::CalledByEntry;
[31m-    
(B[m[32m+
(B[m     assert_eq!(condition.get_type(), WitnessConditionType::CalledByEntry);
[31m-    
(B[m[32m+
(B[m     // Test evaluation when called by entry
     let mut context = create_test_context();
     context.is_entry_script = true;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:364:
     assert!(condition.evaluate(&context));
[31m-    
(B[m[32m+
(B[m     // Test evaluation when not called by entry
     context.is_entry_script = false;
     assert!(!condition.evaluate(&context));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:373:
     // Test CalledByContract witness conditions match C# Neo
     let contract_hash = UInt160::from([42u8; 20]);
     let condition = WitnessCondition::CalledByContract(contract_hash);
[31m-    
(B[m[32m+
(B[m     assert_eq!(condition.get_type(), WitnessConditionType::CalledByContract);
[31m-    
(B[m[32m+
(B[m     // Test evaluation with matching caller
     let mut context = create_test_context();
     context.calling_script_hash = Some(contract_hash);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:382:
     assert!(condition.evaluate(&context));
[31m-    
(B[m[32m+
(B[m     // Test evaluation with non-matching caller
     context.calling_script_hash = Some(UInt160::from([99u8; 20]));
     assert!(!condition.evaluate(&context));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:387:
[31m-    
(B[m[32m+
(B[m     // Test evaluation with no caller
     context.calling_script_hash = None;
     assert!(!condition.evaluate(&context));
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:395:
     // Test CalledByGroup witness conditions match C# Neo
     let group_pubkey = [42u8; 33];
     let condition = WitnessCondition::CalledByGroup(group_pubkey);
[31m-    
(B[m[32m+
(B[m     assert_eq!(condition.get_type(), WitnessConditionType::CalledByGroup);
[31m-    
(B[m[32m+
(B[m     // Test evaluation with matching caller group
     let mut context = create_test_context();
     context.calling_contract_groups.insert(group_pubkey);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:404:
     assert!(condition.evaluate(&context));
[31m-    
(B[m[32m+
(B[m     // Test evaluation with non-matching caller group
     context.calling_contract_groups.clear();
     context.calling_contract_groups.insert([99u8; 33]);
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:431:
             witness_rules: Vec::new(),
         }
     }
[31m-    
(B[m[32m+
(B[m     pub fn add_allowed_contracts(&mut self, contracts: Vec<UInt160>) {
         self.allowed_contracts.extend(contracts);
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:438:
[31m-    
(B[m[32m+
(B[m     pub fn add_allowed_groups(&mut self, groups: Vec<[u8; 33]>) {
         self.allowed_groups.extend(groups);
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:442:
[31m-    
(B[m[32m+
(B[m     pub fn add_witness_rules(&mut self, rules: Vec<WitnessRule>) {
         self.witness_rules.extend(rules);
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:446:
[31m-    
(B[m[32m+
(B[m     pub fn has_custom_contracts(&self) -> bool {
         self.scope.contains(WitnessScope::CustomContracts)
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:450:
[31m-    
(B[m[32m+
(B[m     pub fn has_custom_groups(&self) -> bool {
         self.scope.contains(WitnessScope::CustomGroups)
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:454:
[31m-    
(B[m[32m+
(B[m     pub fn has_witness_rules(&self) -> bool {
         self.scope.contains(WitnessScope::WitnessRules)
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:458:
[31m-    
(B[m[32m+
(B[m     pub fn is_global(&self) -> bool {
         self.scope.contains(WitnessScope::Global)
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:462:
[31m-    
(B[m[32m+
(B[m     pub fn allows_contract(&self, contract: &UInt160) -> bool {
         if self.is_global() {
             return true;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:466:
         }
[31m-        
(B[m[32m+
(B[m         if self.has_custom_contracts() {
             return self.allowed_contracts.contains(contract);
         }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:471:
[31m-        
(B[m[32m+
(B[m         false
     }
[31m-    
(B[m[32m+
(B[m     pub fn allows_group(&self, group: &[u8; 33]) -> bool {
         if self.is_global() {
             return true;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:478:
         }
[31m-        
(B[m[32m+
(B[m         if self.has_custom_groups() {
             return self.allowed_groups.contains(group);
         }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:483:
[31m-        
(B[m[32m+
(B[m         false
     }
[31m-    
(B[m[32m+
(B[m     pub fn check_witness_rules(&self, contract: &UInt160) -> bool {
         if !self.has_witness_rules() {
             return false;
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:490:
         }
[31m-        
(B[m[32m+
(B[m         let context = WitnessContext {
             current_script_hash: *contract,
             calling_script_hash: None,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:496:
             calling_contract_groups: HashSet::new(),
             is_entry_script: false,
         };
[31m-        
(B[m[32m+
(B[m         // Evaluate rules in order - first match wins
         for rule in &self.witness_rules {
             if rule.condition.evaluate(&context) {
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:503:
                 return matches!(rule.action, WitnessRuleAction::Allow);
             }
         }
[31m-        
(B[m[32m+
(B[m         false // Default deny if no rules match
     }
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:547:
     pub fn is_called_by_entry(&self) -> bool {
         self.contains(WitnessScope::CalledByEntry)
     }
[31m-    
(B[m[32m+
(B[m     pub fn to_bytes(&self) -> Vec<u8> {
         vec![self.bits()]
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:554:
[31m-    
(B[m[32m+
(B[m     pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
         if bytes.is_empty() {
             return Err("Empty bytes".to_string());
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:558:
         }
[31m-        
(B[m[32m+
(B[m         WitnessScope::from_bits(bytes[0])
             .ok_or_else(|| format!("Invalid witness scope: {:#x}", bytes[0]))
     }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:614:
             WitnessCondition::CalledByGroup(_) => WitnessConditionType::CalledByGroup,
         }
     }
[31m-    
(B[m[32m+
(B[m     pub fn evaluate(&self, context: &WitnessContext) -> bool {
         match self {
             WitnessCondition::Boolean(value) => *value,
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:621:
             WitnessCondition::Not(inner) => !inner.evaluate(context),
[31m-            WitnessCondition::And(conditions) => {
(B[m[31m-                conditions.iter().all(|c| c.evaluate(context))
(B[m[31m-            },
(B[m[31m-            WitnessCondition::Or(conditions) => {
(B[m[31m-                conditions.iter().any(|c| c.evaluate(context))
(B[m[31m-            },
(B[m[31m-            WitnessCondition::ScriptHash(hash) => {
(B[m[31m-                context.current_script_hash == *hash
(B[m[31m-            },
(B[m[31m-            WitnessCondition::Group(group) => {
(B[m[31m-                context.contract_groups.contains(group)
(B[m[31m-            },
(B[m[32m+            WitnessCondition::And(conditions) => conditions.iter().all(|c| c.evaluate(context)),
(B[m[32m+            WitnessCondition::Or(conditions) => conditions.iter().any(|c| c.evaluate(context)),
(B[m[32m+            WitnessCondition::ScriptHash(hash) => context.current_script_hash == *hash,
(B[m[32m+            WitnessCondition::Group(group) => context.contract_groups.contains(group),
(B[m             WitnessCondition::CalledByEntry => context.is_entry_script,
[31m-            WitnessCondition::CalledByContract(hash) => {
(B[m[31m-                context.calling_script_hash == Some(*hash)
(B[m[31m-            },
(B[m[32m+            WitnessCondition::CalledByContract(hash) => context.calling_script_hash == Some(*hash),
(B[m             WitnessCondition::CalledByGroup(group) => {
                 context.calling_contract_groups.contains(group)
[31m-            },
(B[m[32m+            }
(B[m         }
     }
 }
Diff in /home/ubuntu/neo-rs/crates/smart_contract/tests/witness_scope_compatibility_tests.rs:644:
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/vm/benches/memory_optimization_bench.rs:3:
 //! This benchmark validates the effectiveness of our memory optimizations
 
 use criterion::{black_box, criterion_group, criterion_main, Criterion};
[31m-use neo_vm::memory_pool::{VmMemoryPools, with_pools};
(B[m use neo_vm::evaluation_stack::EvaluationStack;
[32m+use neo_vm::memory_pool::{with_pools, VmMemoryPools};
(B[m use neo_vm::reference_counter::ReferenceCounter;
 use neo_vm::stack_item::StackItem;
 
Diff in /home/ubuntu/neo-rs/crates/vm/benches/memory_optimization_bench.rs:28:
                     buffer.push(neo_vm::instruction::Instruction::new(
                         neo_vm::op_code::OpCode::PUSH1,
                         i,
[31m-                        Some(vec![i as u8])
(B[m[32m+                        Some(vec![i as u8]),
(B[m                     ));
                 }
                 buffer.len()
Diff in /home/ubuntu/neo-rs/crates/vm/benches/memory_optimization_bench.rs:52:
 
 fn benchmark_evaluation_stack(c: &mut Criterion) {
     let rc = ReferenceCounter::new();
[31m-    
(B[m[32m+
(B[m     c.bench_function("evaluation_stack_operations", |b| {
         b.iter(|| {
             let mut stack = EvaluationStack::new(rc.clone());
Diff in /home/ubuntu/neo-rs/crates/vm/benches/memory_optimization_bench.rs:59:
[31m-            
(B[m[32m+
(B[m             // Simulate typical stack operations
             for i in 0..black_box(20) {
                 stack.push(StackItem::from_int(i));
Diff in /home/ubuntu/neo-rs/crates/vm/benches/memory_optimization_bench.rs:63:
             }
[31m-            
(B[m[32m+
(B[m             // Pop some items
             for _ in 0..black_box(10) {
                 if let Ok(_) = stack.pop() {
Diff in /home/ubuntu/neo-rs/crates/vm/benches/memory_optimization_bench.rs:68:
                     // Item popped successfully
                 }
             }
[31m-            
(B[m[32m+
(B[m             stack.size()
         })
     });
Diff in /home/ubuntu/neo-rs/crates/vm/benches/memory_optimization_bench.rs:82:
                 for _ in 0..50 {
                     let _buffer = pools.get_byte_buffer();
                 }
[31m-                
(B[m[32m+
(B[m                 let metrics = pools.performance_metrics();
                 black_box(metrics.overall_efficiency)
             })
Diff in /home/ubuntu/neo-rs/crates/vm/benches/memory_optimization_bench.rs:97:
     benchmark_memory_pool_performance
 );
 criterion_main!(memory_benches);
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/vm/src/debugger.rs:187:
         }
 
         let current_context = self.engine.current_context().cloned();
[31m-        let _current_instruction_pointer = current_context.as_ref().map(|c| c.instruction_pointer());
(B[m[32m+        let _current_instruction_pointer =
(B[m[32m+            current_context.as_ref().map(|c| c.instruction_pointer());
(B[m 
         // Execute the next instruction
         self.engine.execute_next()?;
Diff in /home/ubuntu/neo-rs/crates/vm/src/error.rs:132:
 
     /// Implementation provided I/O error (for testing)
     #[cfg(test)]
[31m-#[allow(dead_code)]
(B[m[32m+    #[allow(dead_code)]
(B[m     #[error("Mock I/O error: {message}")]
     MockIo { message: String },
 }
Diff in /home/ubuntu/neo-rs/crates/vm/src/error.rs:309:
 
     /// Implementation provided I/O error (for testing)
     #[cfg(test)]
[31m-#[allow(dead_code)]
(B[m[32m+    #[allow(dead_code)]
(B[m     pub fn real_io<S: Into<String>>(message: S) -> Self {
         Self::MockIo {
             message: message.into(),
Diff in /home/ubuntu/neo-rs/crates/vm/src/error.rs:400:
             VmError::InvalidScriptHash { .. } => "hash",
             VmError::InvalidWitness { .. } | VmError::VerificationFailed { .. } => "verification",
             #[cfg(test)]
[31m-#[allow(dead_code)]
(B[m[32m+            #[allow(dead_code)]
(B[m             VmError::MockIo { .. } => "real_io",
         }
     }
Diff in /home/ubuntu/neo-rs/crates/vm/src/execution_context.rs:560:
             .copy_to(shared_states.evaluation_stack_mut());
 
         // Create the new context
[31m-        
(B[m 
         // Note: Not cloning static_fields, local_variables, or arguments
         // as they would need separate reference counter handling
Diff in /home/ubuntu/neo-rs/crates/vm/src/execution_engine.rs:475:
                 .map(|sf| sf as *const _);
 
             if current_static_fields.is_none()
[31m-                || !std::ptr::eq(current_static_fields.expect("Operation failed"), static_fields)
(B[m[32m+                || !std::ptr::eq(
(B[m[32m+                    current_static_fields.expect("Operation failed"),
(B[m[32m+                    static_fields,
(B[m[32m+                )
(B[m             {
                 static_fields.clear_references();
             }
Diff in /home/ubuntu/neo-rs/crates/vm/src/jump_table/control/types.rs:236:
     /// Gets the signers of the transaction
     pub fn signers(&self) -> Vec<Signer> {
         // Safe conversion from neo_core::Signer to local Signer
[31m-        self.inner.signers().iter().map(|s| Signer::from_core(s.clone())).collect()
(B[m[32m+        self.inner
(B[m[32m+            .signers()
(B[m[32m+            .iter()
(B[m[32m+            .map(|s| Signer::from_core(s.clone()))
(B[m[32m+            .collect()
(B[m     }
 
     /// Gets the attributes of the transaction
Diff in /home/ubuntu/neo-rs/crates/vm/src/jump_table/control/types.rs:243:
     pub fn attributes(&self) -> Vec<TransactionAttribute> {
         // Safe conversion from neo_core attributes to VM types
         // Currently only supporting OracleResponse attribute in VM
[31m-        self.inner.attributes().iter().filter_map(|a| match a {
(B[m[31m-            neo_core::TransactionAttribute::OracleResponse { id, code, result } => {
(B[m[31m-                Some(TransactionAttribute::OracleResponse {
(B[m[31m-                    id: *id,
(B[m[31m-                    code: *code as u8,
(B[m[31m-                    result: result.clone(),
(B[m[31m-                })
(B[m[31m-            }
(B[m[31m-            _ => None, // Other attribute types not yet implemented in VM
(B[m[31m-        }).collect()
(B[m[32m+        self.inner
(B[m[32m+            .attributes()
(B[m[32m+            .iter()
(B[m[32m+            .filter_map(|a| match a {
(B[m[32m+                neo_core::TransactionAttribute::OracleResponse { id, code, result } => {
(B[m[32m+                    Some(TransactionAttribute::OracleResponse {
(B[m[32m+                        id: *id,
(B[m[32m+                        code: *code as u8,
(B[m[32m+                        result: result.clone(),
(B[m[32m+                    })
(B[m[32m+                }
(B[m[32m+                _ => None, // Other attribute types not yet implemented in VM
(B[m[32m+            })
(B[m[32m+            .collect()
(B[m     }
 
     /// Creates a minimal transaction for VM testing
Diff in /home/ubuntu/neo-rs/crates/vm/src/lib.rs:117:
 pub mod evaluation_stack;
 /// Exception handling and try-catch support
 pub mod exception_handling;
[31m-/// Memory pool for optimizing allocations
(B[m[31m-pub mod memory_pool;
(B[m[31m-/// Performance metrics collection
(B[m[31m-pub mod metrics;
(B[m /// Script execution context and local variables
 pub mod execution_context;
 /// Low-level VM execution engine
Diff in /home/ubuntu/neo-rs/crates/vm/src/lib.rs:131:
 pub mod interop_service;
 /// OpCode implementation and instruction dispatch
 pub mod jump_table;
[32m+/// Memory pool for optimizing allocations
(B[m[32m+pub mod memory_pool;
(B[m[32m+/// Performance metrics collection
(B[m[32m+pub mod metrics;
(B[m /// VM opcode definitions and utilities
 pub mod op_code;
[32m+/// Performance optimization utilities
(B[m[32m+pub mod performance_opt;
(B[m /// Memory management for complex data structures
 pub mod reference_counter;
[32m+/// Safe execution utilities for VM operations
(B[m[32m+pub mod safe_execution;
(B[m[32m+/// Safe type conversion utilities
(B[m[32m+pub mod safe_type_conversion;
(B[m /// VM script representation and validation
 pub mod script;
 /// Utility for constructing VM bytecode
Diff in /home/ubuntu/neo-rs/crates/vm/src/lib.rs:143:
 pub mod stack_item;
 /// Graph algorithms for garbage collection
 pub mod strongly_connected_components;
[31m-/// Safe execution utilities for VM operations
(B[m[31m-pub mod safe_execution;
(B[m[31m-/// Performance optimization utilities
(B[m[31m-pub mod performance_opt;
(B[m[31m-/// Safe type conversion utilities
(B[m[31m-pub mod safe_type_conversion;
(B[m 
 /// Test utilities and compatibility tests
 #[cfg(test)]
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:1:
 //! Memory pool for optimizing allocations in hot paths
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides object pooling to reduce allocation overhead
 //! for frequently created and destroyed objects in the VM.
 
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:6:
[31m-use std::sync::{Arc, Mutex};
(B[m[32m+use crate::execution_context::ExecutionContext;
(B[m[32m+use crate::stack_item::StackItem;
(B[m use std::collections::VecDeque;
 use std::sync::atomic::{AtomicUsize, Ordering};
[31m-use crate::stack_item::StackItem;
(B[m[31m-use crate::execution_context::ExecutionContext;
(B[m[32m+use std::sync::{Arc, Mutex};
(B[m 
 /// Maximum number of pooled objects per type
 const MAX_POOL_SIZE: usize = 1024;
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:49:
             self.allocations.fetch_add(1, Ordering::Relaxed);
             (self.factory)()
         };
[31m-        
(B[m[32m+
(B[m         PooledObject {
             inner: Some(obj),
             pool: Arc::clone(&self.pool),
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:67:
     pub fn clear(&self) {
         self.pool.lock().unwrap().clear();
     }
[31m-    
(B[m[32m+
(B[m     /// Gets the total number of allocations made
     pub fn total_allocations(&self) -> usize {
         self.allocations.load(Ordering::Relaxed)
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:74:
     }
[31m-    
(B[m[32m+
(B[m     /// Gets the number of pool hits (reused objects)
     pub fn pool_hits(&self) -> usize {
         self.hits.load(Ordering::Relaxed)
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:79:
     }
[31m-    
(B[m[32m+
(B[m     /// Gets the hit ratio as a percentage (0-100)
     pub fn hit_ratio(&self) -> f32 {
         let hits = self.hits.load(Ordering::Relaxed);
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:124:
         if let Some(mut obj) = self.inner.take() {
             // Reset the object before returning to pool
             (self.reset)(&mut obj);
[31m-            
(B[m[32m+
(B[m             // Return to pool if not full
             let mut pool = self.pool.lock().unwrap();
             if pool.len() < self.max_size {
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:150:
         Self {
             byte_buffers: ObjectPool::new(
                 || Vec::with_capacity(512), // Increased for typical script sizes
[31m-                |v| { v.clear(); v.shrink_to(512); }, // Prevent excessive growth
(B[m[32m+                |v| {
(B[m[32m+                    v.clear();
(B[m[32m+                    v.shrink_to(512);
(B[m[32m+                }, // Prevent excessive growth
(B[m             ),
             instruction_buffers: ObjectPool::new(
                 || Vec::with_capacity(128), // Increased for complex scripts
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:157:
[31m-                |v| { v.clear(); v.shrink_to(128); },
(B[m[32m+                |v| {
(B[m[32m+                    v.clear();
(B[m[32m+                    v.shrink_to(128);
(B[m[32m+                },
(B[m             ),
             stack_item_vecs: ObjectPool::new(
                 || Vec::with_capacity(32), // Increased for typical stack operations
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:161:
[31m-                |v| { v.clear(); v.shrink_to(32); },
(B[m[32m+                |v| {
(B[m[32m+                    v.clear();
(B[m[32m+                    v.shrink_to(32);
(B[m[32m+                },
(B[m             ),
         }
     }
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:190:
         let byte_buffer_allocs = self.byte_buffers.total_allocations();
         let instruction_allocs = self.instruction_buffers.total_allocations();
         let stack_item_allocs = self.stack_item_vecs.total_allocations();
[31m-        
(B[m[32m+
(B[m         // Estimate memory usage (rough calculation)
[31m-        let estimated_memory = 
(B[m[31m-            byte_buffer_allocs * 512 + // avg byte buffer size
(B[m[32m+        let estimated_memory = byte_buffer_allocs * 512 + // avg byte buffer size
(B[m             instruction_allocs * 128 * std::mem::size_of::<crate::instruction::Instruction>() +
             stack_item_allocs * 32 * std::mem::size_of::<crate::stack_item::StackItem>();
[31m-        
(B[m[32m+
(B[m         MemoryPoolStats {
             byte_buffers_pooled: self.byte_buffers.size(),
             instruction_buffers_pooled: self.instruction_buffers.size(),
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:207:
             total_memory_used: estimated_memory,
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Gets detailed pool performance metrics
     pub fn performance_metrics(&self) -> PoolPerformanceMetrics {
         PoolPerformanceMetrics {
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:214:
             byte_buffer_hit_ratio: self.byte_buffers.hit_ratio(),
             instruction_buffer_hit_ratio: self.instruction_buffers.hit_ratio(),
             stack_item_vec_hit_ratio: self.stack_item_vecs.hit_ratio(),
[31m-            overall_efficiency: (
(B[m[31m-                self.byte_buffers.hit_ratio() +
(B[m[31m-                self.instruction_buffers.hit_ratio() +
(B[m[31m-                self.stack_item_vecs.hit_ratio()
(B[m[31m-            ) / 3.0,
(B[m[32m+            overall_efficiency: (self.byte_buffers.hit_ratio()
(B[m[32m+                + self.instruction_buffers.hit_ratio()
(B[m[32m+                + self.stack_item_vecs.hit_ratio())
(B[m[32m+                / 3.0,
(B[m         }
     }
 }
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:256:
 }
 
 /// Gets the thread-local memory pools
[31m-/// 
(B[m[32m+///
(B[m /// Returns a reference to the thread-local memory pools with safe access.
 /// Uses a closure-based API to ensure memory safety.
 pub fn with_pools<F, R>(f: F) -> R
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:272:
 
     #[test]
     fn test_object_pool() {
[31m-        let pool: ObjectPool<Vec<u8>> = ObjectPool::new(
(B[m[31m-            || Vec::with_capacity(100),
(B[m[31m-            |v| v.clear(),
(B[m[31m-        );
(B[m[32m+        let pool: ObjectPool<Vec<u8>> = ObjectPool::new(|| Vec::with_capacity(100), |v| v.clear());
(B[m 
         // Get object from pool
         let mut obj1 = pool.get();
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:296:
     #[test]
     fn test_vm_memory_pools() {
         let pools = VmMemoryPools::new();
[31m-        
(B[m[32m+
(B[m         // Test byte buffer pool
         {
             let mut buffer = pools.get_byte_buffer();
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:303:
             buffer.extend_from_slice(b"test");
             assert_eq!(buffer.len(), 4);
         }
[31m-        
(B[m[32m+
(B[m         // Check that buffer was returned to pool
         assert_eq!(pools.byte_buffers.size(), 1);
[31m-        
(B[m[32m+
(B[m         // Get stats
         let stats = pools.stats();
         assert_eq!(stats.byte_buffers_pooled, 1);
Diff in /home/ubuntu/neo-rs/crates/vm/src/memory_pool.rs:313:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:1:
 //! Performance metrics collection for the Neo VM
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides comprehensive metrics tracking for monitoring
 //! VM performance, memory usage, and operation statistics.
 
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:6:
[32m+use std::collections::HashMap;
(B[m use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
 use std::sync::{Arc, RwLock};
 use std::time::{Duration, Instant};
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:9:
[31m-use std::collections::HashMap;
(B[m 
 /// VM performance metrics
 #[derive(Debug, Clone)]
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:75:
     /// Records a script execution
     pub fn record_execution(&self, success: bool, duration: Duration) {
         self.scripts_executed.fetch_add(1, Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         if success {
             self.successful_executions.fetch_add(1, Ordering::Relaxed);
         } else {
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:82:
             self.failed_executions.fetch_add(1, Ordering::Relaxed);
         }
[31m-        
(B[m[32m+
(B[m         let micros = duration.as_micros() as u64;
[31m-        self.total_execution_time_us.fetch_add(micros, Ordering::Relaxed);
(B[m[32m+        self.total_execution_time_us
(B[m[32m+            .fetch_add(micros, Ordering::Relaxed);
(B[m     }
 
     /// Updates stack depth
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:90:
     pub fn update_stack_depth(&self, depth: usize) {
         self.current_stack_depth.store(depth, Ordering::Relaxed);
[31m-        
(B[m[32m+
(B[m         // Update peak if necessary
         let mut peak = self.peak_stack_depth.load(Ordering::Relaxed);
         while depth > peak {
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:108:
     /// Records a memory allocation
     pub fn record_allocation(&self, bytes: usize) {
         self.memory_allocations.fetch_add(1, Ordering::Relaxed);
[31m-        let new_total = self.current_memory_bytes.fetch_add(bytes, Ordering::Relaxed) + bytes;
(B[m[31m-        
(B[m[32m+        let new_total = self
(B[m[32m+            .current_memory_bytes
(B[m[32m+            .fetch_add(bytes, Ordering::Relaxed)
(B[m[32m+            + bytes;
(B[m[32m+
(B[m         // Update peak if necessary
         let mut peak = self.peak_memory_bytes.load(Ordering::Relaxed);
         while new_total > peak {
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:128:
     /// Records a memory deallocation
     pub fn record_deallocation(&self, bytes: usize) {
         self.memory_deallocations.fetch_add(1, Ordering::Relaxed);
[31m-        self.current_memory_bytes.fetch_sub(bytes, Ordering::Relaxed);
(B[m[32m+        self.current_memory_bytes
(B[m[32m+            .fetch_sub(bytes, Ordering::Relaxed);
(B[m     }
 
     /// Records an operation timing
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:135:
     pub fn record_operation(&self, name: &str, duration: Duration) {
         let mut timings = self.operation_timings.write().unwrap();
[31m-        let metrics = timings.entry(name.to_string()).or_insert_with(OperationMetrics::new);
(B[m[32m+        let metrics = timings
(B[m[32m+            .entry(name.to_string())
(B[m[32m+            .or_insert_with(OperationMetrics::new);
(B[m         metrics.record(duration);
     }
 
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:148:
     pub fn snapshot(&self) -> MetricsSnapshot {
         let operation_timings = self.operation_timings.read().unwrap().clone();
         let syscall_counts = self.syscall_counts.read().unwrap().clone();
[31m-        
(B[m[32m+
(B[m         MetricsSnapshot {
             timestamp: Instant::now(),
             instructions_executed: self.instructions_executed.load(Ordering::Relaxed),
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:267:
     /// Formats metrics as a human-readable report
     pub fn format_report(&self) -> String {
         let mut report = String::new();
[31m-        
(B[m[32m+
(B[m         report.push_str("=== VM Performance Metrics ===\n");
[31m-        report.push_str(&format!("Instructions Executed: {}\n", self.instructions_executed));
(B[m[32m+        report.push_str(&format!(
(B[m[32m+            "Instructions Executed: {}\n",
(B[m[32m+            self.instructions_executed
(B[m[32m+        ));
(B[m         report.push_str(&format!("Gas Consumed: {}\n", self.gas_consumed));
[31m-        report.push_str(&format!("Scripts Executed: {} (Success: {}, Failed: {})\n", 
(B[m[31m-            self.scripts_executed, self.successful_executions, self.failed_executions));
(B[m[31m-        report.push_str(&format!("Average Execution Time: {} μs\n", self.average_execution_time_us));
(B[m[32m+        report.push_str(&format!(
(B[m[32m+            "Scripts Executed: {} (Success: {}, Failed: {})\n",
(B[m[32m+            self.scripts_executed, self.successful_executions, self.failed_executions
(B[m[32m+        ));
(B[m[32m+        report.push_str(&format!(
(B[m[32m+            "Average Execution Time: {} μs\n",
(B[m[32m+            self.average_execution_time_us
(B[m[32m+        ));
(B[m         report.push_str(&format!("Peak Stack Depth: {}\n", self.peak_stack_depth));
[31m-        report.push_str(&format!("Memory: {} allocations, {} deallocations\n", 
(B[m[31m-            self.memory_allocations, self.memory_deallocations));
(B[m[32m+        report.push_str(&format!(
(B[m[32m+            "Memory: {} allocations, {} deallocations\n",
(B[m[32m+            self.memory_allocations, self.memory_deallocations
(B[m[32m+        ));
(B[m         report.push_str(&format!("Peak Memory: {} bytes\n", self.peak_memory_bytes));
[31m-        
(B[m[32m+
(B[m         if !self.operation_timings.is_empty() {
             report.push_str("\n=== Operation Timings ===\n");
             for (name, metrics) in &self.operation_timings {
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:285:
[31m-                report.push_str(&format!("{}: {} calls, avg {} μs (min: {}, max: {})\n",
(B[m[31m-                    name, metrics.count, metrics.average_time_us(), 
(B[m[31m-                    metrics.min_time_us, metrics.max_time_us));
(B[m[32m+                report.push_str(&format!(
(B[m[32m+                    "{}: {} calls, avg {} μs (min: {}, max: {})\n",
(B[m[32m+                    name,
(B[m[32m+                    metrics.count,
(B[m[32m+                    metrics.average_time_us(),
(B[m[32m+                    metrics.min_time_us,
(B[m[32m+                    metrics.max_time_us
(B[m[32m+                ));
(B[m             }
         }
[31m-        
(B[m[32m+
(B[m         if !self.syscall_counts.is_empty() {
             report.push_str("\n=== Syscall Counts ===\n");
             for (name, count) in &self.syscall_counts {
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:294:
                 report.push_str(&format!("{}: {}\n", name, count));
             }
         }
[31m-        
(B[m[32m+
(B[m         report
     }
 }
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:301:
 
 /// Global metrics instance
[31m-static GLOBAL_METRICS: once_cell::sync::Lazy<VmMetrics> = 
(B[m[32m+static GLOBAL_METRICS: once_cell::sync::Lazy<VmMetrics> =
(B[m     once_cell::sync::Lazy::new(|| VmMetrics::new());
 
 /// Gets the global metrics instance
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:342:
     #[test]
     fn test_metrics_recording() {
         let metrics = VmMetrics::new();
[31m-        
(B[m[32m+
(B[m         // Record some operations
         metrics.record_instruction();
         metrics.record_instruction();
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:349:
         metrics.record_gas(100);
         metrics.record_execution(true, Duration::from_millis(10));
[31m-        
(B[m[32m+
(B[m         // Check metrics
         assert_eq!(metrics.instructions_executed.load(Ordering::Relaxed), 2);
         assert_eq!(metrics.gas_consumed.load(Ordering::Relaxed), 100);
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:358:
     #[test]
     fn test_stack_depth_tracking() {
         let metrics = VmMetrics::new();
[31m-        
(B[m[32m+
(B[m         metrics.update_stack_depth(5);
         metrics.update_stack_depth(10);
         metrics.update_stack_depth(3);
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:365:
[31m-        
(B[m[32m+
(B[m         assert_eq!(metrics.peak_stack_depth.load(Ordering::Relaxed), 10);
         assert_eq!(metrics.current_stack_depth.load(Ordering::Relaxed), 3);
     }
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:370:
     #[test]
     fn test_operation_timing() {
         let metrics = Arc::new(VmMetrics::new());
[31m-        
(B[m[32m+
(B[m         {
             let _timer = MetricsTimer::new("test_op", Arc::clone(&metrics));
             thread::sleep(Duration::from_millis(10));
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:377:
         }
[31m-        
(B[m[32m+
(B[m         let snapshot = metrics.snapshot();
         assert!(snapshot.operation_timings.contains_key("test_op"));
         let op_metrics = &snapshot.operation_timings["test_op"];
Diff in /home/ubuntu/neo-rs/crates/vm/src/metrics.rs:383:
         assert!(op_metrics.total_time_us > 0);
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:1:
 //! Performance optimization utilities for the VM
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides optimized alternatives to expensive operations
 //! like cloning and memory allocation in hot paths.
 
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:6:
[31m-use crate::{StackItem, VmResult, VmError};
(B[m[32m+use crate::{StackItem, VmError, VmResult};
(B[m[32m+use std::borrow::Cow;
(B[m use std::rc::Rc;
 use std::sync::Arc;
[31m-use std::borrow::Cow;
(B[m 
 /// Smart cloning strategies for stack items
 pub struct SmartClone;
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:13:
 
 impl SmartClone {
     /// Clone only if necessary using reference counting
[31m-    /// 
(B[m[32m+    ///
(B[m     /// This method avoids cloning when the item is already reference-counted
     /// or when a reference would suffice.
     pub fn clone_if_needed(item: &StackItem) -> StackItem {
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:21:
         // which is much cheaper than deep cloning
         match item {
             StackItem::Array(arr) => StackItem::Array(arr.clone()), // Rc clone
[31m-            StackItem::Map(map) => StackItem::Map(map.clone()), // Rc clone
(B[m[31m-            StackItem::Struct(s) => StackItem::Struct(s.clone()), // Rc clone
(B[m[32m+            StackItem::Map(map) => StackItem::Map(map.clone()),     // Rc clone
(B[m[32m+            StackItem::Struct(s) => StackItem::Struct(s.clone()),   // Rc clone
(B[m             StackItem::Buffer(buf) => StackItem::Buffer(buf.clone()), // Rc clone
             // For primitive types, cloning is cheap anyway
[31m-            _ => item.clone()
(B[m[32m+            _ => item.clone(),
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get a reference or clone only if mutation is needed
     pub fn cow_item<'a>(item: &'a StackItem) -> Cow<'a, StackItem> {
         Cow::Borrowed(item)
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:35:
     }
[31m-    
(B[m[32m+
(B[m     /// Share data using Arc for thread-safe access without cloning
     pub fn share_data<T: Clone>(data: T) -> Arc<T> {
         Arc::new(data)
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:49:
         // Direct move instead of clone when we own the item
         stack.push(item);
     }
[31m-    
(B[m[32m+
(B[m     /// Peek without cloning
     pub fn peek_ref(stack: &[StackItem], index: usize) -> VmResult<&StackItem> {
[31m-        stack.get(stack.len() - 1 - index)
(B[m[32m+        stack
(B[m[32m+            .get(stack.len() - 1 - index)
(B[m             .ok_or_else(|| VmError::StackUnderflow {
                 requested: index + 1,
[31m-                available: stack.len()
(B[m[32m+                available: stack.len(),
(B[m             })
     }
[31m-    
(B[m[32m+
(B[m     /// Pop and return ownership without extra cloning
     pub fn pop_owned(stack: &mut Vec<StackItem>) -> VmResult<StackItem> {
[31m-        stack.pop()
(B[m[31m-            .ok_or_else(|| VmError::StackUnderflow {
(B[m[31m-                requested: 1,
(B[m[31m-                available: 0
(B[m[31m-            })
(B[m[32m+        stack.pop().ok_or_else(|| VmError::StackUnderflow {
(B[m[32m+            requested: 1,
(B[m[32m+            available: 0,
(B[m[32m+        })
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:87:
             factory: Box::new(factory),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get an item from the pool or create a new one
     pub fn get(&mut self) -> T {
         self.pool.pop().unwrap_or_else(|| (self.factory)())
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:94:
     }
[31m-    
(B[m[32m+
(B[m     /// Return an item to the pool for reuse
     pub fn put(&mut self, item: T) {
         if self.pool.len() < self.pool.capacity() {
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:113:
             interned: std::collections::HashMap::new(),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Intern a string to avoid duplicates
     pub fn intern(&mut self, s: &str) -> Rc<str> {
         if let Some(interned) = self.interned.get(s) {
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:140:
             factory: Some(Box::new(factory)),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get the value, computing it if necessary
     pub fn get(&mut self) -> &T {
         if self.value.is_none() {
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:148:
                 self.value = Some(factory());
             }
         }
[31m-        self.value.as_ref().expect("LazyValue should have value after factory call")
(B[m[32m+        self.value
(B[m[32m+            .as_ref()
(B[m[32m+            .expect("LazyValue should have value after factory call")
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:168:
             processor: Box::new(processor),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Add an item to the batch
     pub fn add(&mut self, item: T) {
         self.batch.push(item);
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:176:
             self.flush();
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Process all pending items
     pub fn flush(&mut self) {
         if !self.batch.is_empty() {
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:189:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_memory_pool() {
         let mut pool = MemoryPool::new(5, || vec![0u8; 1024]);
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:196:
[31m-        
(B[m[32m+
(B[m         let mut items = Vec::new();
         for _ in 0..10 {
             items.push(pool.get());
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:200:
         }
[31m-        
(B[m[32m+
(B[m         // Return some items
         for item in items.drain(0..5) {
             pool.put(item);
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:205:
         }
[31m-        
(B[m[32m+
(B[m         // Get should reuse returned items
         let reused = pool.get();
         assert_eq!(reused.len(), 1024);
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:210:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_string_interner() {
         let mut interner = StringInterner::new();
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:215:
[31m-        
(B[m[32m+
(B[m         let s1 = interner.intern("hello");
         let s2 = interner.intern("hello");
[31m-        
(B[m[32m+
(B[m         // Should return the same Rc
         assert!(Rc::ptr_eq(&s1, &s2));
     }
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:222:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_lazy_value() {
         let mut lazy = LazyValue::new(|| {
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:226:
             // Expensive computation
             vec![1, 2, 3, 4, 5]
         });
[31m-        
(B[m[32m+
(B[m         // Value is computed on first access
         let value = lazy.get();
         assert_eq!(value.len(), 5);
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:233:
[31m-        
(B[m[32m+
(B[m         // Subsequent accesses return the same value
         let value2 = lazy.get();
         assert_eq!(value.len(), value2.len());
Diff in /home/ubuntu/neo-rs/crates/vm/src/performance_opt.rs:237:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/vm/src/reference_counter.rs:205:
 
         // 3. Check for potential references to other zero-count items (production heuristic)
         for (&other_id, &other_count) in references.iter() {
[31m-            if other_count == 0 && !processed.contains(&other_id)
(B[m[31m-                && self.items_might_reference_each_other(start_id, other_id) {
(B[m[31m-                    // Recursively find connected items
(B[m[31m-                    self.find_strongly_connected_component(
(B[m[31m-                        other_id, references, component, processed,
(B[m[31m-                    );
(B[m[31m-                }
(B[m[32m+            if other_count == 0
(B[m[32m+                && !processed.contains(&other_id)
(B[m[32m+                && self.items_might_reference_each_other(start_id, other_id)
(B[m[32m+            {
(B[m[32m+                // Recursively find connected items
(B[m[32m+                self.find_strongly_connected_component(other_id, references, component, processed);
(B[m[32m+            }
(B[m         }
     }
 
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:1:
 //! Safe execution utilities for the VM module
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides safe alternatives to panic! calls and unsafe operations
 //! in the VM execution engine.
 
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:6:
[31m-use crate::{VmResult, VmError, OpCode};
(B[m[32m+use crate::{OpCode, VmError, VmResult};
(B[m use std::fmt;
 
 /// Safe assertion for VM execution state
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:14:
     pub fn assert_execution_state<T: fmt::Debug>(
         state: T,
         expected: bool,
[31m-        context: &str
(B[m[32m+        context: &str,
(B[m     ) -> VmResult<()> {
         if !expected {
             return Err(VmError::ExecutionHalted {
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:21:
[31m-                reason: format!("Execution failed in {}: state={:?}", context, state)
(B[m[32m+                reason: format!("Execution failed in {}: state={:?}", context, state),
(B[m             });
         }
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:25:
     }
[31m-    
(B[m[32m+
(B[m     /// Validate jump operation
     pub fn validate_jump_operation(op: OpCode) -> VmResult<()> {
         match op {
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:30:
             OpCode::JMP | OpCode::JMPIF | OpCode::JMPIFNOT | OpCode::CALL => Ok(()),
             _ => Err(VmError::InvalidOperation {
                 operation: format!("Jump operation"),
[31m-                reason: format!("Invalid jump operation: {:?}", op)
(B[m[31m-            })
(B[m[32m+                reason: format!("Invalid jump operation: {:?}", op),
(B[m[32m+            }),
(B[m         }
     }
[31m-    
(B[m[32m+
(B[m     /// Validate syscall API length
     pub fn validate_syscall_api_length(api_bytes_len: usize) -> VmResult<()> {
         if api_bytes_len > 252 {
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:41:
             return Err(VmError::InvalidOperation {
                 operation: "Syscall".to_string(),
[31m-                reason: format!("Syscall API is too long: {} bytes (max 252)", api_bytes_len)
(B[m[32m+                reason: format!("Syscall API is too long: {} bytes (max 252)", api_bytes_len),
(B[m             });
         }
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:52:
 
 impl SafeMemoryOps {
     /// Safe memory copy with bounds checking
[31m-    pub fn safe_copy(
(B[m[31m-        src: &[u8],
(B[m[31m-        dst: &mut [u8],
(B[m[31m-        offset: usize,
(B[m[31m-        len: usize
(B[m[31m-    ) -> VmResult<()> {
(B[m[32m+    pub fn safe_copy(src: &[u8], dst: &mut [u8], offset: usize, len: usize) -> VmResult<()> {
(B[m         // Validate source bounds
         if src.len() < len {
             return Err(VmError::Overflow {
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:64:
[31m-                operation: format!("Buffer copy: source too small ({} < {})", src.len(), len)
(B[m[32m+                operation: format!("Buffer copy: source too small ({} < {})", src.len(), len),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         // Validate destination bounds
         if dst.len() < offset + len {
             return Err(VmError::Overflow {
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:71:
[31m-                operation: format!("Buffer copy: destination too small ({} < {})", dst.len(), offset + len)
(B[m[32m+                operation: format!(
(B[m[32m+                    "Buffer copy: destination too small ({} < {})",
(B[m[32m+                    dst.len(),
(B[m[32m+                    offset + len
(B[m[32m+                ),
(B[m             });
         }
[31m-        
(B[m[32m+
(B[m         // Safe copy using standard library
         dst[offset..offset + len].copy_from_slice(&src[..len]);
         Ok(())
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:78:
     }
[31m-    
(B[m[32m+
(B[m     /// Safe stack allocation with size limits
     pub fn safe_stack_alloc(size: usize, max_size: usize) -> VmResult<Vec<u8>> {
         if size > max_size {
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:83:
[31m-            return Err(VmError::StackOverflow {
(B[m[31m-                max_size
(B[m[31m-            });
(B[m[32m+            return Err(VmError::StackOverflow { max_size });
(B[m         }
[31m-        
(B[m[32m+
(B[m         // Use try_reserve to handle allocation failures
         let mut vec = Vec::new();
[31m-        vec.try_reserve(size)
(B[m[31m-            .map_err(|e| VmError::Parse { 
(B[m[31m-                message: format!("Failed to allocate stack: {}", e)
(B[m[31m-            })?;
(B[m[32m+        vec.try_reserve(size).map_err(|e| VmError::Parse {
(B[m[32m+            message: format!("Failed to allocate stack: {}", e),
(B[m[32m+        })?;
(B[m         vec.resize(size, 0);
         Ok(vec)
     }
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:101:
 
 impl SafeScriptBuilder {
     /// Build jump instruction safely
[31m-    pub fn build_jump_safely(
(B[m[31m-        op: OpCode,
(B[m[31m-        offset: i32,
(B[m[31m-        buffer: &mut Vec<u8>
(B[m[31m-    ) -> VmResult<()> {
(B[m[32m+    pub fn build_jump_safely(op: OpCode, offset: i32, buffer: &mut Vec<u8>) -> VmResult<()> {
(B[m         // Validate operation
         SafeVmAssertion::validate_jump_operation(op)?;
[31m-        
(B[m[32m+
(B[m         // Add opcode
         buffer.push(op as u8);
[31m-        
(B[m[32m+
(B[m         // Add offset (little-endian)
         buffer.extend_from_slice(&offset.to_le_bytes());
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
[31m-    
(B[m[32m+
(B[m     /// Build syscall safely
[31m-    pub fn build_syscall_safely(
(B[m[31m-        api: &str,
(B[m[31m-        buffer: &mut Vec<u8>
(B[m[31m-    ) -> VmResult<()> {
(B[m[32m+    pub fn build_syscall_safely(api: &str, buffer: &mut Vec<u8>) -> VmResult<()> {
(B[m         let api_bytes = api.as_bytes();
[31m-        
(B[m[32m+
(B[m         // Validate API length
         SafeVmAssertion::validate_syscall_api_length(api_bytes.len())?;
[31m-        
(B[m[32m+
(B[m         // Add syscall opcode
         buffer.push(OpCode::SYSCALL as u8);
[31m-        
(B[m[32m+
(B[m         // Add API length
         buffer.push(api_bytes.len() as u8);
[31m-        
(B[m[32m+
(B[m         // Add API string
         buffer.extend_from_slice(api_bytes);
[31m-        
(B[m[32m+
(B[m         Ok(())
     }
 }
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:144:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_vm_assertion() {
         // Test successful assertion
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:151:
[31m-        let result = SafeVmAssertion::assert_execution_state(
(B[m[31m-            "success",
(B[m[31m-            true,
(B[m[31m-            "test context"
(B[m[31m-        );
(B[m[32m+        let result = SafeVmAssertion::assert_execution_state("success", true, "test context");
(B[m         assert!(result.is_ok());
[31m-        
(B[m[32m+
(B[m         // Test failed assertion
[31m-        let result = SafeVmAssertion::assert_execution_state(
(B[m[31m-            "failure",
(B[m[31m-            false,
(B[m[31m-            "test context"
(B[m[31m-        );
(B[m[32m+        let result = SafeVmAssertion::assert_execution_state("failure", false, "test context");
(B[m         assert!(result.is_err());
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_validate_jump_operation() {
         // Valid operations
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:171:
         assert!(SafeVmAssertion::validate_jump_operation(OpCode::JMPIF).is_ok());
         assert!(SafeVmAssertion::validate_jump_operation(OpCode::JMPIFNOT).is_ok());
         assert!(SafeVmAssertion::validate_jump_operation(OpCode::CALL).is_ok());
[31m-        
(B[m[32m+
(B[m         // Invalid operation
         assert!(SafeVmAssertion::validate_jump_operation(OpCode::NOP).is_err());
     }
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:178:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_memory_copy() {
         let src = vec![1, 2, 3, 4, 5];
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:182:
         let mut dst = vec![0; 10];
[31m-        
(B[m[32m+
(B[m         // Successful copy
         let result = SafeMemoryOps::safe_copy(&src, &mut dst, 2, 3);
         assert!(result.is_ok());
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:187:
         assert_eq!(&dst[2..5], &[1, 2, 3]);
[31m-        
(B[m[32m+
(B[m         // Source too small
         let result = SafeMemoryOps::safe_copy(&src, &mut dst, 0, 10);
         assert!(result.is_err());
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:192:
[31m-        
(B[m[32m+
(B[m         // Destination too small
         let result = SafeMemoryOps::safe_copy(&src, &mut dst, 8, 5);
         assert!(result.is_err());
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:196:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_stack_alloc() {
         // Successful allocation
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:201:
         let result = SafeMemoryOps::safe_stack_alloc(100, 1000);
         assert!(result.is_ok());
         assert_eq!(result.unwrap().len(), 100);
[31m-        
(B[m[32m+
(B[m         // Allocation too large
         let result = SafeMemoryOps::safe_stack_alloc(2000, 1000);
         assert!(result.is_err());
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_execution.rs:208:
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:1:
 //! Safe type conversion utilities for the VM
[31m-//! 
(B[m[32m+//!
(B[m //! This module provides safe alternatives to unsafe transmute operations
 //! by using proper type conversion and validation.
 
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:6:
[31m-use crate::{VmResult, VmError};
(B[m[31m-use neo_core::{Signer as CoreSigner, TransactionAttribute as CoreAttribute, OracleResponseCode, UInt256, WitnessScope};
(B[m[32m+use crate::{VmError, VmResult};
(B[m[32m+use neo_core::{
(B[m[32m+    OracleResponseCode, Signer as CoreSigner, TransactionAttribute as CoreAttribute, UInt256,
(B[m[32m+    WitnessScope,
(B[m[32m+};
(B[m use std::convert::TryFrom;
 
 /// Safe type converter for VM types
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:12:
 
 impl SafeTypeConverter {
     /// Safely convert core signers to VM signers
[31m-    /// 
(B[m[32m+    ///
(B[m     /// This avoids unsafe transmute by properly converting each signer
     pub fn convert_signers(core_signers: &[CoreSigner]) -> Vec<Signer> {
         core_signers.iter().map(|s| Signer::from_core(s)).collect()
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:19:
     }
[31m-    
(B[m[32m+
(B[m     /// Safely convert core attributes to VM attributes
[31m-    /// 
(B[m[32m+    ///
(B[m     /// This avoids unsafe transmute by properly converting each attribute
     pub fn convert_attributes(core_attrs: &[CoreAttribute]) -> Vec<TransactionAttribute> {
[31m-        core_attrs.iter().map(|a| TransactionAttribute::from_core(a)).collect()
(B[m[32m+        core_attrs
(B[m[32m+            .iter()
(B[m[32m+            .map(|a| TransactionAttribute::from_core(a))
(B[m[32m+            .collect()
(B[m     }
[31m-    
(B[m[32m+
(B[m     /// Safe memory layout validation
[31m-    /// 
(B[m[32m+    ///
(B[m     /// Verifies that types have compatible memory layouts before conversion
     pub fn validate_layout<T, U>() -> bool {
[31m-        std::mem::size_of::<T>() == std::mem::size_of::<U>() &&
(B[m[31m-        std::mem::align_of::<T>() == std::mem::align_of::<U>()
(B[m[32m+        std::mem::size_of::<T>() == std::mem::size_of::<U>()
(B[m[32m+            && std::mem::align_of::<T>() == std::mem::align_of::<U>()
(B[m     }
 }
 
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:50:
         Self {
             account: core.account.to_array().to_vec(),
             scopes: core.scopes.to_byte(),
[31m-            allowed_contracts: core.allowed_contracts.iter()
(B[m[32m+            allowed_contracts: core
(B[m[32m+                .allowed_contracts
(B[m[32m+                .iter()
(B[m                 .map(|c| c.to_array().to_vec())
                 .collect(),
             allowed_groups: core.allowed_groups.clone(),
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:57:
[31m-            rules: core.rules.iter()
(B[m[32m+            rules: core
(B[m[32m+                .rules
(B[m[32m+                .iter()
(B[m                 .map(|r| WitnessRule::from_core(r))
                 .collect(),
         }
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:75:
     pub fn from_core(core: &CoreAttribute) -> Self {
         match core {
             CoreAttribute::HighPriority => Self::HighPriority,
[31m-            CoreAttribute::OracleResponse { id, code, result } => {
(B[m[31m-                Self::OracleResponse {
(B[m[31m-                    id: *id,
(B[m[31m-                    code: *code as u8,
(B[m[31m-                    result: result.clone(),
(B[m[31m-                }
(B[m[31m-            }
(B[m[31m-            CoreAttribute::NotValidBefore { height } => {
(B[m[31m-                Self::NotValidBefore { height: *height }
(B[m[31m-            }
(B[m[31m-            CoreAttribute::Conflicts { hash } => {
(B[m[31m-                Self::Conflicts { hash: hash.to_array().to_vec() }
(B[m[31m-            }
(B[m[32m+            CoreAttribute::OracleResponse { id, code, result } => Self::OracleResponse {
(B[m[32m+                id: *id,
(B[m[32m+                code: *code as u8,
(B[m[32m+                result: result.clone(),
(B[m[32m+            },
(B[m[32m+            CoreAttribute::NotValidBefore { height } => Self::NotValidBefore { height: *height },
(B[m[32m+            CoreAttribute::Conflicts { hash } => Self::Conflicts {
(B[m[32m+                hash: hash.to_array().to_vec(),
(B[m[32m+            },
(B[m         }
     }
 }
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:113:
 }
 
 /// Safe static access wrapper
[31m-/// 
(B[m[32m+///
(B[m /// Provides thread-safe access to static variables without unsafe blocks
 pub struct SafeStatic<T: Clone> {
     value: std::sync::RwLock<Option<T>>,
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:126:
             value: std::sync::RwLock::new(None),
         }
     }
[31m-    
(B[m[32m+
(B[m     /// Get or initialize the static value
[31m-    pub fn get_or_init<F>(&self, init: F) -> T 
(B[m[32m+    pub fn get_or_init<F>(&self, init: F) -> T
(B[m     where
[31m-        F: FnOnce() -> T
(B[m[32m+        F: FnOnce() -> T,
(B[m     {
         // Try to read first
         if let Ok(guard) = self.value.read() {
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:138:
                 return val.clone();
             }
         }
[31m-        
(B[m[32m+
(B[m         // Need to initialize
         if let Ok(mut guard) = self.value.write() {
             if guard.is_none() {
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:161:
         if ptr.is_null() {
             return None;
         }
[31m-        
(B[m[32m+
(B[m         // Check alignment requirements
         let t_align = std::mem::align_of::<T>();
         let u_align = std::mem::align_of::<U>();
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:168:
[31m-        
(B[m[32m+
(B[m         if (ptr as usize) % u_align != 0 {
             return None; // Misaligned pointer
         }
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:172:
[31m-        
(B[m[32m+
(B[m         // Only allow if target alignment is less restrictive
         if u_align > t_align {
             return None;
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:176:
         }
[31m-        
(B[m[32m+
(B[m         Some(ptr as *const U)
     }
[31m-    
(B[m[32m+
(B[m     /// Safe slice conversion with bounds checking
[31m-    /// 
(B[m[32m+    ///
(B[m     /// Note: This returns None as a safe alternative to unsafe transmutation.
     /// In production, use proper type conversion traits or serialization.
[31m-    pub fn safe_slice_cast<T, U>(slice: &[T]) -> Option<Vec<U>> 
(B[m[32m+    pub fn safe_slice_cast<T, U>(slice: &[T]) -> Option<Vec<U>>
(B[m     where
         T: Clone,
         U: Default + Clone,
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:190:
         // Validate size compatibility
         let t_size = std::mem::size_of::<T>();
         let u_size = std::mem::size_of::<U>();
[31m-        
(B[m[32m+
(B[m         if t_size == 0 || u_size == 0 {
             return None; // Zero-sized types
         }
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:197:
[31m-        
(B[m[32m+
(B[m         let total_bytes = slice.len() * t_size;
         if total_bytes % u_size != 0 {
             return None; // Size mismatch
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:201:
         }
[31m-        
(B[m[32m+
(B[m         let new_len = total_bytes / u_size;
[31m-        
(B[m[32m+
(B[m         // Safe alternative: create new vector with default values
         // In production, implement proper conversion traits
         let mut result = Vec::with_capacity(new_len);
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:208:
         for _ in 0..new_len {
             result.push(U::default());
         }
[31m-        
(B[m[32m+
(B[m         // Return the safe vector
         Some(result)
     }
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:217:
 #[cfg(test)]
 mod tests {
     use super::*;
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_static() {
         static COUNTER: SafeStatic<u32> = SafeStatic::new();
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:224:
[31m-        
(B[m[32m+
(B[m         let val1 = COUNTER.get_or_init(|| 42);
         assert_eq!(val1, 42);
[31m-        
(B[m[32m+
(B[m         let val2 = COUNTER.get_or_init(|| 100); // Should return 42, not 100
         assert_eq!(val2, 42);
     }
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:231:
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_layout_validation() {
         // Same size types
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:235:
         assert!(SafeTypeConverter::validate_layout::<u32, i32>());
         assert!(SafeTypeConverter::validate_layout::<[u8; 4], u32>());
[31m-        
(B[m[32m+
(B[m         // Different size types
         assert!(!SafeTypeConverter::validate_layout::<u32, u64>());
         assert!(!SafeTypeConverter::validate_layout::<u8, u16>());
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:241:
     }
[31m-    
(B[m[32m+
(B[m     #[test]
     fn test_safe_pointer_cast() {
         let value: u32 = 42;
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:246:
         let ptr = &value as *const u32;
[31m-        
(B[m[32m+
(B[m         // Valid cast to u8 (less restrictive alignment)
         let u8_ptr = SafePointerOps::safe_cast::<u32, u8>(ptr);
         assert!(u8_ptr.is_some());
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:251:
[31m-        
(B[m[32m+
(B[m         // Null pointer returns None
         let null_ptr: *const u32 = std::ptr::null();
         let result = SafePointerOps::safe_cast::<u32, u8>(null_ptr);
Diff in /home/ubuntu/neo-rs/crates/vm/src/safe_type_conversion.rs:255:
         assert!(result.is_none());
     }
 }
[32m+
(B[mDiff in /home/ubuntu/neo-rs/crates/vm/src/script.rs:4:
 
 use crate::error::VmError;
 use crate::error::VmResult;
[31m-use crate::instruction::{Instruction};
(B[m[32m+use crate::instruction::Instruction;
(B[m use crate::op_code::OpCode;
 use neo_io::MemoryReader;
 use std::collections::hash_map::DefaultHasher;
Diff in /home/ubuntu/neo-rs/crates/wallets/src/key_pair.rs:65:
     /// The encrypted_key should be base64-encoded NEP-2 data.
     pub fn from_nep2(encrypted_key: &[u8], password: &str) -> Result<Self> {
         // First try to decode as base64
[31m-        let decoded = base64::engine::general_purpose::STANDARD.decode(encrypted_key).map_err(|_| Error::InvalidNep2Key)?;
(B[m[32m+        let decoded = base64::engine::general_purpose::STANDARD
(B[m[32m+            .decode(encrypted_key)
(B[m[32m+            .map_err(|_| Error::InvalidNep2Key)?;
(B[m 
         let private_key = Self::decrypt_nep2(&decoded, password)?;
         Self::from_private_key(&private_key)
Diff in /home/ubuntu/neo-rs/crates/wallets/src/wallet.rs:4:
 //! converted from the C# Neo Wallet class (@neo-sharp/src/Neo/Wallets/Wallet.cs).
 
 use crate::{
[31m-    contract::Contract,
(B[m[31m-    key_pair::KeyPair,
(B[m[31m-    wallet_account::WalletAccount,
(B[m[31m-    wallet_factory::IWalletFactory,
(B[m[31m-    Version,
(B[m[32m+    contract::Contract, key_pair::KeyPair, wallet_account::WalletAccount,
(B[m[32m+    wallet_factory::IWalletFactory, Version,
(B[m };
 use async_trait::async_trait;
 use neo_core::{Transaction, UInt160, UInt256};
Diff in /home/ubuntu/neo-rs/src/lib.rs:73:
 
 /// Common imports for Neo development
 pub mod prelude {
[31m-    pub use crate::core::{UInt160, UInt256, Transaction, Block};
(B[m[31m-    pub use crate::crypto::{PublicKey, PrivateKey, Signature};
(B[m[31m-    pub use crate::vm::{ApplicationEngine, Script, StackItem};
(B[m[31m-    pub use crate::ledger::{Blockchain, BlockHeader};
(B[m[32m+    pub use crate::core::{Block, Transaction, UInt160, UInt256};
(B[m[32m+    pub use crate::crypto::{PrivateKey, PublicKey, Signature};
(B[m[32m+    pub use crate::ledger::{BlockHeader, Blockchain};
(B[m     pub use crate::network::{NetworkConfig, P2pNode};
     pub use crate::persistence::Storage;
[31m-    
(B[m[32m+    pub use crate::vm::{ApplicationEngine, Script, StackItem};
(B[m[32m+
(B[m     #[cfg(feature = "consensus")]
     pub use crate::consensus::ConsensusService;
[31m-    
(B[m[32m+
(B[m     #[cfg(feature = "rpc")]
     pub use crate::rpc_server::RpcServer;
 }
Diff in /home/ubuntu/neo-rs/src/lib.rs:128:
         let blockchain = std::sync::Arc::new(
             ledger::Blockchain::new_with_storage_suffix(
                 neo_config::NetworkType::MainNet,
[31m-                Some("node")
(B[m[31m-            ).await?
(B[m[32m+                Some("node"),
(B[m[32m+            )
(B[m[32m+            .await?,
(B[m         );
 
         Ok(Self {
Diff in /home/ubuntu/neo-rs/src/lib.rs:193:
 
 /// Neo protocol version
 pub const PROTOCOL_VERSION: u32 = 0;
[32m+
(B[mDiff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:5:
 
 use neo_core::{
     safe_error_handling::{SafeError, SafeResult},
[32m+    safe_memory::{MemoryPool, SafeBuffer},
(B[m     system_monitoring::{self, SYSTEM_MONITOR},
     transaction_validator::TransactionValidator,
[31m-    safe_memory::{SafeBuffer, MemoryPool},
(B[m };
 use neo_vm::{
[31m-    safe_execution::{SafeVmExecutor, ExecutionGuard},
(B[m[31m-    safe_type_conversion::SafeTypeConverter,
(B[m     performance_opt::SmartCloneStrategy,
[32m+    safe_execution::{ExecutionGuard, SafeVmExecutor},
(B[m[32m+    safe_type_conversion::SafeTypeConverter,
(B[m };
[31m-use std::time::Duration;
(B[m use std::sync::Arc;
 use std::thread;
[32m+use std::time::Duration;
(B[m 
 #[test]
 fn test_safe_error_handling_integration() {
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:23:
     // Test that errors are properly tracked and monitored
[31m-    let result: SafeResult<()> = Err(SafeError::new(
(B[m[31m-        "test_error",
(B[m[31m-        "test_module",
(B[m[31m-        42,
(B[m[31m-        "TestError"
(B[m[31m-    ));
(B[m[31m-    
(B[m[32m+    let result: SafeResult<()> = Err(SafeError::new("test_error", "test_module", 42, "TestError"));
(B[m[32m+
(B[m     // Error should be recorded in monitoring
     system_monitoring::record_error("test_module", false);
[31m-    
(B[m[32m+
(B[m     let snapshot = SYSTEM_MONITOR.errors.snapshot();
     assert!(snapshot.total_errors > 0);
     assert!(snapshot.warnings > 0);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:37:
[31m-    
(B[m[32m+
(B[m     // Verify error context is preserved
     if let Err(e) = result {
         assert_eq!(e.message, "test_error");
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:46:
 #[test]
 fn test_transaction_validation_with_monitoring() {
     let validator = TransactionValidator::new();
[31m-    
(B[m[32m+
(B[m     // Create a test transaction (mock)
     let tx_size = 1024u64;
     let verification_time = Duration::from_millis(10);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:53:
[31m-    
(B[m[32m+
(B[m     // Record transaction in monitoring
     system_monitoring::record_transaction(tx_size, verification_time, true);
[31m-    
(B[m[32m+
(B[m     // Verify metrics were recorded
     let snapshot = SYSTEM_MONITOR.transactions.snapshot();
     assert!(snapshot.total_count > 0);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:65:
 #[test]
 fn test_vm_safe_execution() {
     let executor = SafeVmExecutor::new();
[31m-    
(B[m[32m+
(B[m     // Test with execution guard
     let guard = ExecutionGuard::new(Duration::from_secs(1), 1000000);
[31m-    
(B[m[32m+
(B[m     // Simulate VM execution
     let gas_consumed = 5000u64;
     let execution_time = Duration::from_millis(5);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:75:
     let opcodes = 100u64;
[31m-    
(B[m[32m+
(B[m     // Record VM execution
     system_monitoring::record_vm_execution(gas_consumed, execution_time, opcodes, true);
[31m-    
(B[m[32m+
(B[m     // Verify metrics
     let snapshot = SYSTEM_MONITOR.vm.snapshot();
     assert!(snapshot.executions > 0);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:88:
 #[test]
 fn test_memory_pool_with_monitoring() {
     let pool: MemoryPool<Vec<u8>> = MemoryPool::new(10);
[31m-    
(B[m[32m+
(B[m     // Get buffer from pool
     let buffer = pool.get_or_create(|| Vec::with_capacity(1024));
     assert_eq!(buffer.capacity(), 1024);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:95:
[31m-    
(B[m[32m+
(B[m     // Update memory usage in monitoring
     SYSTEM_MONITOR.performance.update_memory_usage(1024);
[31m-    
(B[m[32m+
(B[m     // Return buffer to pool
     pool.return_item(buffer);
[31m-    
(B[m[32m+
(B[m     // Verify pool size
     assert_eq!(pool.size(), 1);
[31m-    
(B[m[32m+
(B[m     // Check memory metrics
     let snapshot = SYSTEM_MONITOR.performance.snapshot();
     assert!(snapshot.memory_usage_bytes > 0);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:111:
 fn test_concurrent_safety() {
     let monitor = Arc::clone(&SYSTEM_MONITOR);
     let mut handles = vec![];
[31m-    
(B[m[32m+
(B[m     // Spawn multiple threads to test thread safety
     for i in 0..10 {
         let monitor_clone = Arc::clone(&monitor);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:121:
                 system_monitoring::record_transaction(
                     (i * 100 + j) as u64,
                     Duration::from_micros(j as u64),
[31m-                    j % 2 == 0
(B[m[32m+                    j % 2 == 0,
(B[m                 );
             }
[31m-            
(B[m[32m+
(B[m             // Record some errors
             if i % 2 == 0 {
                 system_monitoring::record_error(format!("thread_{}", i), false);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:132:
         });
         handles.push(handle);
     }
[31m-    
(B[m[32m+
(B[m     // Wait for all threads to complete
     for handle in handles {
         handle.join().unwrap();
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:139:
     }
[31m-    
(B[m[32m+
(B[m     // Verify all operations were recorded
     let snapshot = SYSTEM_MONITOR.snapshot();
     assert_eq!(snapshot.transactions.total_count, 1000);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:150:
     let block_height = 12345u64;
     let block_size = 50000u64;
     let tx_count = 150u64;
[31m-    
(B[m[32m+
(B[m     // Record block
     system_monitoring::record_block(block_height, block_size, tx_count);
[31m-    
(B[m[32m+
(B[m     // Wait a bit and record another block
     thread::sleep(Duration::from_millis(10));
     system_monitoring::record_block(block_height + 1, block_size + 1000, tx_count + 10);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:160:
[31m-    
(B[m[32m+
(B[m     // Verify metrics
     let snapshot = SYSTEM_MONITOR.blocks.snapshot();
     assert_eq!(snapshot.total_count, 2);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:171:
 fn test_network_metrics() {
     // Update peer count
     SYSTEM_MONITOR.network.update_peer_count(8);
[31m-    
(B[m[32m+
(B[m     // Record message activity
     SYSTEM_MONITOR.network.record_message_sent(1024);
     SYSTEM_MONITOR.network.record_message_received(2048);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:178:
     SYSTEM_MONITOR.network.record_connection_failure();
     SYSTEM_MONITOR.network.update_average_latency(50);
[31m-    
(B[m[32m+
(B[m     // Verify metrics
     let snapshot = SYSTEM_MONITOR.network.snapshot();
     assert_eq!(snapshot.peer_count, 8);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:192:
 #[test]
 fn test_storage_metrics() {
     // Record storage operations
[31m-    SYSTEM_MONITOR.storage.record_read(Duration::from_micros(100), true);  // cache hit
(B[m[31m-    SYSTEM_MONITOR.storage.record_read(Duration::from_micros(500), false); // cache miss
(B[m[31m-    SYSTEM_MONITOR.storage.record_write(Duration::from_micros(1000));
(B[m[32m+    SYSTEM_MONITOR
(B[m[32m+        .storage
(B[m[32m+        .record_read(Duration::from_micros(100), true); // cache hit
(B[m[32m+    SYSTEM_MONITOR
(B[m[32m+        .storage
(B[m[32m+        .record_read(Duration::from_micros(500), false); // cache miss
(B[m[32m+    SYSTEM_MONITOR
(B[m[32m+        .storage
(B[m[32m+        .record_write(Duration::from_micros(1000));
(B[m     SYSTEM_MONITOR.storage.record_delete();
     SYSTEM_MONITOR.storage.update_disk_usage(1024 * 1024 * 100); // 100MB
[31m-    
(B[m[32m+
(B[m     // Verify metrics
     let snapshot = SYSTEM_MONITOR.storage.snapshot();
     assert_eq!(snapshot.reads, 2);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:214:
 fn test_consensus_metrics() {
     // Record consensus operations
     SYSTEM_MONITOR.consensus.record_view_change();
[31m-    SYSTEM_MONITOR.consensus.record_block_proposal(true, Duration::from_millis(100));
(B[m[31m-    SYSTEM_MONITOR.consensus.record_block_proposal(false, Duration::from_millis(150));
(B[m[32m+    SYSTEM_MONITOR
(B[m[32m+        .consensus
(B[m[32m+        .record_block_proposal(true, Duration::from_millis(100));
(B[m[32m+    SYSTEM_MONITOR
(B[m[32m+        .consensus
(B[m[32m+        .record_block_proposal(false, Duration::from_millis(150));
(B[m     SYSTEM_MONITOR.consensus.record_timeout();
[31m-    
(B[m[32m+
(B[m     // Verify metrics
     let snapshot = SYSTEM_MONITOR.consensus.snapshot();
     assert_eq!(snapshot.view_changes, 1);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:232:
 fn test_performance_tracking() {
     // Update performance metrics
     SYSTEM_MONITOR.performance.update_cpu_usage(45);
[31m-    SYSTEM_MONITOR.performance.update_memory_usage(1024 * 1024 * 512); // 512MB
(B[m[32m+    SYSTEM_MONITOR
(B[m[32m+        .performance
(B[m[32m+        .update_memory_usage(1024 * 1024 * 512); // 512MB
(B[m     SYSTEM_MONITOR.performance.update_thread_count(24);
[31m-    SYSTEM_MONITOR.performance.record_gc(Duration::from_millis(5));
(B[m[31m-    
(B[m[32m+    SYSTEM_MONITOR
(B[m[32m+        .performance
(B[m[32m+        .record_gc(Duration::from_millis(5));
(B[m[32m+
(B[m     // Verify metrics
     let snapshot = SYSTEM_MONITOR.performance.snapshot();
     assert_eq!(snapshot.cpu_usage_percent, 45);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:251:
     system_monitoring::record_transaction(1024, Duration::from_millis(1), true);
     system_monitoring::record_block(1, 1000, 10);
     system_monitoring::record_error("test", false);
[31m-    
(B[m[32m+
(B[m     // Verify metrics exist
     let snapshot = SYSTEM_MONITOR.snapshot();
     assert!(snapshot.transactions.total_count > 0);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:258:
     assert!(snapshot.blocks.total_count > 0);
     assert!(snapshot.errors.total_errors > 0);
[31m-    
(B[m[32m+
(B[m     // Reset all metrics
     SYSTEM_MONITOR.reset();
[31m-    
(B[m[32m+
(B[m     // Verify metrics are cleared
     let snapshot = SYSTEM_MONITOR.snapshot();
     assert_eq!(snapshot.transactions.total_count, 0);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:272:
 fn test_safe_type_conversion() {
     // Test safe type conversions
     let converter = SafeTypeConverter;
[31m-    
(B[m[32m+
(B[m     // These would normally test actual conversions
     // For now, we verify the module exists and can be instantiated
     assert!(std::mem::size_of::<SafeTypeConverter>() == 0); // Zero-sized type
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:281:
 #[test]
 fn test_smart_clone_strategy() {
     let strategy = SmartCloneStrategy::default();
[31m-    
(B[m[32m+
(B[m     // Test with different data sizes
     let small_data = vec![1u8; 100];
     let large_data = vec![1u8; 10000];
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:288:
[31m-    
(B[m[32m+
(B[m     // Small data should be cloned
     assert!(strategy.should_clone(small_data.len()));
[31m-    
(B[m[32m+
(B[m     // Large data should use Arc
     assert!(!strategy.should_clone(large_data.len()));
 }
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:300:
     system_monitoring::record_block(100, 50000, 150);
     system_monitoring::record_vm_execution(5000, Duration::from_millis(2), 100, true);
     system_monitoring::record_error("test_error", false);
[31m-    
(B[m[32m+
(B[m     // Get complete snapshot
     let snapshot = system_monitoring::get_metrics_snapshot();
[31m-    
(B[m[32m+
(B[m     // Verify snapshot contains all components
     assert!(snapshot.timestamp_ms > 0);
     assert!(snapshot.transactions.total_count > 0);
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:310:
     assert!(snapshot.blocks.total_count > 0);
     assert!(snapshot.vm.executions > 0);
     assert!(snapshot.errors.total_errors > 0);
[31m-    
(B[m[32m+
(B[m     // Verify snapshot can be serialized (for monitoring dashboard)
     let json = serde_json::to_string_pretty(&snapshot).unwrap();
     assert!(json.contains("timestamp_ms"));
Diff in /home/ubuntu/neo-rs/tests/safety_integration_tests.rs:318:
     assert!(json.contains("blocks"));
     assert!(json.contains("vm"));
 }
[32m+
(B[m