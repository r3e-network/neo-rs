#!/usr/bin/env node
/**
 * Production Readiness Check
 * Checks for TODO, FIXME, placeholders, and incomplete implementations
 * Auto-generated by AutoClaude
 */

const fs = require('fs');
const path = require('path');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        // Patterns that indicate incomplete or non-production code
        const patterns = [
            { pattern: /TODO/gi, message: 'TODO comment found' },
            { pattern: /FIXME/gi, message: 'FIXME comment found' },
            { pattern: /PLACEHOLDER/gi, message: 'Placeholder found' },
            { pattern: /XXX/gi, message: 'XXX marker found' },
            { pattern: /HACK/gi, message: 'HACK comment found' },
            { pattern: /temporary/gi, message: 'Temporary code found' },
            { pattern: /quick\s+fix/gi, message: 'Quick fix found' },
            { pattern: /for\s+now/gi, message: '"for now" comment found' },
            { pattern: /simplified/gi, message: 'Simplified implementation found' },
            { pattern: /\.\.\./, message: 'Ellipsis (...) found - possible incomplete code' },
            { pattern: /<<<|>>>/, message: 'Merge conflict markers found' },
            { pattern: /not\s+implemented/gi, message: 'Not implemented found' },
            { pattern: /throw\s+new\s+Error\(['`]not\s+implemented/gi, message: 'Not implemented error found' },
            { pattern: /console\.(log|debug|trace)/g, message: 'Debug console statement found' },
            { pattern: /debugger;/g, message: 'Debugger statement found' }
        ];
        
        // File extensions to check
        const extensions = ['.js', '.ts', '.jsx', '.tsx', '.go', '.cpp', '.cc', '.h', '.hpp', '.rs', '.cs', '.java', '.py', '.rb', '.php', '.swift', '.kt', '.scala', '.vue', '.svelte'];
        
        // Directories to skip
        const skipDirs = ['.git', 'node_modules', 'dist', 'build', 'out', 'target', 'bin', 'obj', '.next', '.nuxt', 'coverage', '.nyc_output', 'vendor', '.autoclaude'];
        
        function scanDirectory(dir) {
            const files = fs.readdirSync(dir);
            
            for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                
                if (stat.isDirectory()) {
                    if (!skipDirs.includes(file) && !file.startsWith('.')) {
                        scanDirectory(filePath);
                    }
                } else if (stat.isFile()) {
                    const ext = path.extname(file);
                    if (extensions.includes(ext)) {
                        checkFile(filePath, patterns);
                    }
                }
            }
        }
        
        function checkFile(filePath, patterns) {
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n');
            const relativePath = path.relative(process.cwd(), filePath);
            const ext = path.extname(filePath);
            
            patterns.forEach(({ pattern, message }) => {
                lines.forEach((line, index) => {
                    if (pattern.test(line)) {
                        errors.push(`${relativePath}:${index + 1} - ${message}`);
                    }
                });
            });
            
            // Check for empty catch blocks
            const emptyCatchPattern = /catch\s*\([^)]*\)\s*{\s*}/g;
            if (emptyCatchPattern.test(content)) {
                warnings.push(`${relativePath} - Empty catch block found`);
            }
            
            // Check for any(...) type in TypeScript files
            if (ext === '.ts' || ext === '.tsx') {
                const anyTypePattern = /:\s*any\b/g;
                const anyMatches = content.match(anyTypePattern) || [];
                if (anyMatches.length > 0) {
                    warnings.push(`${relativePath} - Found ${anyMatches.length} uses of 'any' type`);
                }
            }
        }
        
        // Start scanning from current directory
        scanDirectory(process.cwd());
        
        // Additional checks
        if (errors.length === 0 && warnings.length === 0) {
            console.error('Production readiness check completed successfully');
        }
        
    } catch (error) {
        errors.push(`Production readiness check failed: ${error.message}`);
    }
    
    // Output results
    console.log(JSON.stringify({
        passed: errors.length === 0,
        errors: errors,
        warnings: warnings
    }, null, 2));
}

// Run the check
check().catch(error => {
    console.error(`Unexpected error during production readiness check: ${error.message}`);
    console.log(JSON.stringify({
        passed: false,
        errors: [`Unexpected error: ${error.message}`]
    }, null, 2));
    process.exit(1);
});